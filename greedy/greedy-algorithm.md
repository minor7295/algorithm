# 그리디 알고리즘(Greedy Algorithm) 정리

## 1️⃣ 그리디 알고리즘의 핵심 개념

### 🎯 동전 문제로 이해하기

먼저 구체적인 예시를 통해 그리디 알고리즘이 어떻게 작동하는지 살펴보겠습니다.

#### 문제 상황

**목표**: 4,200원을 만드는 최소 동전 개수  
**동전 종류**: [1원, 5원, 10원, 50원, 100원, 500원, 1000원]  
**조건**: 각 동전을 무한히 많이 사용할 수 있고, 큰 동전은 작은 동전의 배수입니다.

#### 그리디 접근 방법

**전략**: 큰 동전부터 최대한 많이 사용하기

**단계별 과정**:
1. **1000원 확인**: 4,200원에 1000원이 몇 개 들어갈까?
   - 4,200 ÷ 1,000 = 4개 사용 가능
   - 4개 사용 → 사용한 동전: 4개, 남은 금액: 200원

2. **500원 확인**: 200원에 500원이 몇 개 들어갈까?
   - 200 ÷ 500 = 0개 사용 가능
   - 0개 사용 → 사용한 동전: 4개, 남은 금액: 200원

3. **100원 확인**: 200원에 100원이 몇 개 들어갈까?
   - 200 ÷ 100 = 2개 사용 가능
   - 2개 사용 → 사용한 동전: 6개, 남은 금액: 0원

4. **결과**: 총 6개의 동전 사용 (1000원 4개 + 100원 2개) ✅

#### 왜 이 방법이 최적해인가?

**만약 1000원을 3개만 사용한다면?**
- 1000원 3개 사용 → 남은 금액: 1,200원
- 1,200원을 만들려면: 500원 2개 + 100원 2개 = 4개 필요
- **총 7개 필요** (3 + 4 = 7개) ❌

**1000원을 4개 사용하면?**
- 1000원 4개 사용 → 남은 금액: 200원
- 200원을 만들려면: 100원 2개 = 2개 필요
- **총 6개 필요** (4 + 2 = 6개) ✅

➡️ **큰 동전을 최대한 많이 사용하는 것이 항상 최소 개수를 보장합니다!**

---

### 📌 탐욕 선택 속성(Greedy Choice Property)

위의 동전 문제에서 보았듯이, **매 순간의 최선의 선택이 전체 최적해를 보장**해야 합니다.

**쉽게 이해하기**: "지금 당장 가장 좋은 선택을 하면, 나중에도 최종적으로 최선의 결과가 나온다"

**동전 문제에서의 탐욕 선택 속성**:
- 매 순간 "가장 큰 동전을 최대한 많이 사용"하는 선택
- 이 선택이 전체 최적해(최소 동전 개수)를 보장함
- 왜냐하면 큰 동전을 적게 사용하면 작은 동전으로 대체할 때 더 많은 동전이 필요하기 때문

---

### 📌 최적 부분 구조(Optimal Substructure)

**전체 문제의 최적해가 부분 문제의 최적해로 구성**될 수 있어야 합니다.

**쉽게 이해하기**: "큰 문제를 작은 문제로 나눴을 때, 작은 문제의 최적해를 합치면 큰 문제의 최적해가 된다"

**동전 문제에서의 최적 부분 구조**:

**전체 문제**: 4,200원을 만드는 최소 동전 개수  
**부분 문제**: 200원을 만드는 최소 동전 개수

**최적 부분 구조 확인**:
```
4,200원 최적해 = 1,000원 4개 + 200원 최적해
                = 4개 + 2개 = 6개 ✅
```

**설명**:
- 4,200원을 만드는 최적해는 1,000원 4개를 사용한 후
- 남은 200원을 만드는 최적해(100원 2개)를 합친 것
- 각 부분의 최적해를 합치면 전체 최적해가 됨 ✅

**만약 최적 부분 구조가 없다면?**
- 200원을 만드는 최적해가 2개가 아니라 3개라면?
- 전체 최적해도 4 + 3 = 7개가 되어 최적해가 아님
- 하지만 실제로는 200원 최적해가 2개이므로, 전체 최적해도 6개가 됨 ✅

---

## 2️⃣ 그리디 알고리즘의 구조

### 기본 템플릿

```java
int greedy(int[] items) {
    // 1. 정렬 또는 우선순위 설정
    Arrays.sort(items, Comparator.reverseOrder());
    
    int result = 0;
    int remaining = target;
    
    // 2. 매 순간 최선의 선택 반복
    for (int item : items) {
        if (remaining <= 0) break;
        
        // 현재 상황에서 최선의 선택
        int count = remaining / item;
        result += count;
        remaining %= item;
    }
    
    return result;
}
```

### 📝 단계별 설명 (동전 문제 예시)

**목표**: 4,200원을 만드는 최소 동전 개수
**동전**: [1, 5, 10, 50, 100, 500, 1000]

```java
// 1단계: 정렬 (큰 값부터)
동전: [1000, 500, 100, 50, 10, 5, 1]

// 2단계: 초기화
result = 0 (사용한 동전 개수)
remaining = 4200 (남은 금액)

// 3단계: 그리디 선택 반복
반복 1: item = 1000
  count = 4200 / 1000 = 4개
  result = 0 + 4 = 4
  remaining = 4200 % 1000 = 200

반복 2: item = 500
  count = 200 / 500 = 0개
  result = 4 + 0 = 4
  remaining = 200 % 500 = 200

반복 3: item = 100
  count = 200 / 100 = 2개
  result = 4 + 2 = 6
  remaining = 200 % 100 = 0

// 4단계: 종료 (remaining = 0)
return 6
```

**결과**: 총 6개의 동전 사용 (1000원 4개 + 100원 2개)

---

## 3️⃣ 그리디 알고리즘의 장단점

### ✅ 장점

#### 1. 구현이 간단
**예시**: 동전 문제
- 그리디: 큰 동전부터 사용하는 간단한 반복문
- 동적 계획법: 2차원 배열과 복잡한 점화식 필요

```java
// 그리디 (간단)
for (int i = N-1; i >= 0; i--) {
    count += remaining / coins[i];
    remaining %= coins[i];
}

// 동적 계획법 (복잡)
int[][] dp = new int[N+1][K+1];
for (int i = 1; i <= N; i++) {
    for (int j = 0; j <= K; j++) {
        // 복잡한 점화식...
    }
}
```

#### 2. 효율적
- **시간 복잡도**: 보통 O(N) 또는 O(N log N)
- **예시**: 동전 문제는 O(N) - 동전 종류 수만큼만 반복
- 동적 계획법은 보통 O(N × K) - 훨씬 느림

#### 3. 메모리 효율
- 추가 메모리 사용이 적음 (보통 O(1) 또는 O(N))
- 동적 계획법은 보통 O(N × K) 메모리 필요

### ❌ 단점

#### 1. 최적해 보장 어려움
**모든 문제에 적용할 수 없습니다!**

**예시**: 배수 조건이 없는 동전 문제
```
동전: [1, 3, 4]
목표: 6원

그리디 방법:
- 4원 1개 사용 → 남은 금액: 2원
- 1원 2개 사용 → 총 3개 ❌ (최적해 아님!)

실제 최적해:
- 3원 2개 사용 → 총 2개 ✅
```

➡️ **배수 조건이 없으면 그리디가 최적해를 보장하지 않음!**

#### 2. 증명 필요
- 그리디 선택이 최적해를 보장하는지 수학적으로 증명해야 함
- 증명 없이 사용하면 틀린 답을 낼 수 있음

#### 3. 제한적 적용
- 특정 조건을 만족하는 문제에만 사용 가능
- 예: 동전 문제는 "큰 동전이 작은 동전의 배수" 조건 필요

---

## 4️⃣ 그리디 vs 다른 알고리즘

### 📊 비교표

| 기법 | 특징 | 시간 복잡도 | 예시 | 최적해 보장 |
|------|------|------------|------|-----------|
| **그리디** | 매 순간 최선의 선택 | O(N) 또는 O(N log N) | 동전 문제(배수 조건), MST | 조건부 보장 |
| **동적 계획법** | 중복되는 하위 문제를 메모이제이션 | O(N × K) | 동전 문제(일반), 배낭 문제 | 항상 보장 |
| **분할정복** | 문제를 나누어 해결 후 결합 | O(N log N) | 병합 정렬, 퀵 정렬 | 항상 보장 |
| **완전 탐색** | 모든 경우를 탐색 | 지수 시간 | 백트래킹, 브루트 포스 | 항상 보장 |

### 🔍 구체적인 비교: 동전 문제

#### 상황: 4,200원을 만드는 최소 동전 개수
**동전**: [1, 5, 10, 50, 100, 500, 1000] (배수 조건 만족)

| 방법 | 시간 복잡도 | 공간 복잡도 | 코드 복잡도 | 최적해 |
|------|------------|-----------|-----------|--------|
| **그리디** | O(N) = O(10) | O(N) = O(10) | ⭐ 간단 | ✅ 보장 |
| **동적 계획법** | O(N × K) = O(10 × 4,200,000,000) | O(K) = O(4,200,000,000) | ⭐⭐⭐ 복잡 | ✅ 보장 |
| **완전 탐색** | 지수 시간 | O(깊이) | ⭐⭐⭐⭐ 매우 복잡 | ✅ 보장 |

**결론**: 배수 조건이 있으면 **그리디가 압도적으로 효율적**입니다!

### 💡 언제 어떤 방법을 사용할까?

#### 그리디를 사용하는 경우 ✅
- **조건**: 탐욕 선택 속성과 최적 부분 구조를 만족
- **예시**: 
  - 동전 문제 (배수 조건)
  - 활동 선택 문제
  - MST (크루스칼, 프림)
  - 최단 경로 (다익스트라, 양수 가중치)

#### 동적 계획법을 사용하는 경우 ✅
- **조건**: 그리디가 최적해를 보장하지 않음
- **예시**:
  - 동전 문제 (배수 조건 없음)
  - 배낭 문제
  - 최장 공통 부분 수열 (LCS)

#### 완전 탐색을 사용하는 경우 ✅
- **조건**: 가능한 경우의 수가 적음
- **예시**:
  - 작은 크기의 조합/순열 문제
  - N-Queen (작은 N)

---

## 5️⃣ 그리디 알고리즘 구현 패턴

### 패턴 1: 정렬 후 선택 (동전 문제)

**사용 시나리오**: 동전 문제처럼 큰 값부터 선택해야 하는 경우

```java
// 1. 정렬 (큰 값부터)
Arrays.sort(items, Comparator.reverseOrder());

// 2. 큰 값부터 선택
for (int item : items) {
    if (canUse(item)) {
        use(item);
    }
}
```

**실제 예시**: 동전 문제
```java
int[] coins = {1, 5, 10, 50, 100, 500, 1000};
int K = 4200;

// 역순으로 순회 (큰 동전부터)
for (int i = coins.length - 1; i >= 0; i--) {
    int count = K / coins[i];
    result += count;
    K %= coins[i];
}
```

### 패턴 2: 우선순위 큐 사용 (활동 선택 문제)

**사용 시나리오**: 매 순간 가장 좋은 항목을 선택해야 하는 경우

```java
PriorityQueue<Item> pq = new PriorityQueue<>(Comparator.reverseOrder());

while (!pq.isEmpty()) {
    Item best = pq.poll();
    if (canUse(best)) {
        use(best);
    }
}
```

**실제 예시**: 회의실 배정 문제
```java
// 종료 시간이 빠른 순서로 정렬
PriorityQueue<Meeting> pq = new PriorityQueue<>(
    (a, b) -> a.end - b.end
);

int lastEnd = 0;
int count = 0;

while (!pq.isEmpty()) {
    Meeting m = pq.poll();
    if (m.start >= lastEnd) {  // 겹치지 않으면
        count++;
        lastEnd = m.end;
    }
}
```

### 패턴 3: 반복 선택 (동전 문제 최적화)

**사용 시나리오**: 한 번에 여러 개를 선택할 수 있는 경우

```java
int remaining = target;
int result = 0;

for (int item : items) {
    int count = remaining / item;  // 최대 개수 계산
    result += count;
    remaining %= item;  // 나머지 계산
}
```

**실제 예시**: 동전 문제
```java
int K = 4200;
int[] coins = {1000, 500, 100, 50, 10, 5, 1};

int count = 0;
int remaining = K;

for (int coin : coins) {
    if (remaining <= 0) break;
    
    int coinCount = remaining / coin;  // 4200 / 1000 = 4
    count += coinCount;                // 4개 추가
    remaining %= coin;                 // 4200 % 1000 = 200
}
// 결과: count = 6 (1000원 4개 + 100원 2개)
```

---

## 6️⃣ 그리디 알고리즘의 증명 방법

### 1. 탐욕 선택 속성 증명

**매 순간의 최선의 선택이 최적해에 포함될 수 있음을 증명**

**증명 방법**:
- 현재 선택을 포함하는 최적해가 존재함을 보임
- 또는 현재 선택을 포함하지 않는 최적해를 현재 선택을 포함하는 최적해로 변환 가능함을 보임

#### 구체적인 예시: 동전 문제

**명제**: 큰 동전을 최대한 많이 사용하는 것이 최적해에 포함된다.

**증명**:
1. 최적해에 큰 동전이 적게 사용되었다고 가정
2. 큰 동전을 작은 동전으로 대체하면 더 많은 동전이 필요함
3. 따라서 큰 동전을 최대한 많이 사용하는 것이 최적 ✅

**예시**:
```
목표: 4,200원
최적해: 1000원 4개 + 100원 2개 = 6개

만약 1000원을 3개만 사용한다면?
- 남은 금액: 1,200원
- 1,200원을 만드려면: 500원 2개 + 100원 2개 = 4개
- 총: 3 + 4 = 7개 ❌ (6개보다 많음)

따라서 1000원을 최대한 많이(4개) 사용하는 것이 최적 ✅
```

### 2. 최적 부분 구조 증명

**부분 문제의 최적해가 전체 최적해를 구성함을 증명**

**증명 방법**:
- 부분 문제의 최적해를 합치면 전체 최적해가 됨을 보임

#### 구체적인 예시: 동전 문제

**명제**: 4,200원을 만드는 최적해 = 1,000원 4개 + 200원을 만드는 최적해

**증명**:
1. 4,200원 최적해: 1000원 4개 + 100원 2개 = 6개
2. 200원 최적해: 100원 2개 = 2개
3. 4 + 2 = 6 ✅ (일치)

**만약 최적 부분 구조가 없다면?**
- 200원 최적해가 2개가 아니라 3개라면?
- 전체 최적해도 4 + 3 = 7개가 되어 최적해가 아님
- 하지만 실제로는 200원 최적해가 2개이므로, 전체 최적해도 6개가 됨 ✅

---

## 7️⃣ 정리

그리디 알고리즘은 **매 순간 최선의 선택을 반복**하여 문제를 해결하는 방법입니다.

### ✅ 핵심 요약

1. **기본 원리**: 지금 당장 가장 좋아 보이는 선택을 반복
2. **적용 조건**: 
   - 탐욕 선택 속성: 매 순간의 최선 선택이 전체 최적해 보장
   - 최적 부분 구조: 부분 문제의 최적해가 전체 최적해 구성
3. **장점**: 구현 간단, 효율적, 메모리 효율
4. **단점**: 모든 문제에 적용 불가, 증명 필요, 제한적 적용

### 🎯 실전 팁

1. **문제 분석**: 그리디가 최적해를 보장하는지 먼저 확인
2. **증명**: 수학적으로 증명하거나 반례를 찾아 확인
3. **구현**: 정렬 → 선택 → 반복 패턴 사용
4. **테스트**: 다양한 예시로 검증

### 📚 학습 순서

1. **동전 문제 (BOJ 11047)** - 가장 기본적인 그리디 문제
2. **활동 선택 문제** - 종료 시간 기준 정렬
3. **MST 문제** - 크루스칼/프림 알고리즘
4. **최단 경로** - 다익스트라 알고리즘

적절한 문제에 그리디 알고리즘을 적용하면 **효율적이고 간단한 해결책**을 얻을 수 있습니다!

