# Main.java 설계 근거 정리

이 문서는 **BOJ 1931 회의실 배정 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **알고리즘 선택 과정, 그리디 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 과정

### 고려한 알고리즘들과 평가

#### 1. 완전 탐색 (DFS)

**초기 접근**: DFS를 사용하여 모든 경우를 탐색하는 방법을 고려

**사고 과정**:
* 끝나는 시간 기준으로 정렬한 다음 뒤에서부터 각 회의를 선택하거나 선택하지 않는 이진 트리 구조
* 가장 깊은 리프노드의 깊이를 구하는 것과 같은 문제로 이해

**평가**:
* 시간 복잡도: 2^N (각 회의마다 선택/비선택 2가지 경우)
* N = 100,000일 때: 2^100,000 → 시간 제한(2초) 초과 예상

**소거 이유**: 시간 복잡도가 지수적으로 증가하여 비현실적 ❌

---

#### 2. 백트래킹

**평가**:
* 가지치기를 통해 일부 경우를 제외할 수 있음
* 하지만 최악의 경우 여전히 지수 시간 가능성

**소거 이유**: N = 100,000일 때 비효율적 ❌

---

#### 3. 동적 계획법 (DP)

**평가**:
* 각 회의를 포함했을 때의 최대 개수를 계산
* 이진 탐색 최적화 시: O(N log N) 시간 복잡도
* 단순 구현 시: O(N²) 시간 복잡도
* 공간 복잡도: O(N) (DP 배열 추가)
* 구현이 상대적으로 복잡함

**소거 이유**: 
* 시간 복잡도: O(N log N) - 그리디와 동일하지만, 각 회의마다 이진 탐색을 수행하므로 실제 연산 횟수가 더 많음
* 공간 복잡도: O(N) - DP 배열 추가 필요
* 구현이 복잡함
* (다음에 DP로도 풀어볼 예정)

---

#### 4. 그리디 알고리즘 ✅

**평가**:
* 끝나는 시간이 빠른 회의를 우선 선택
* 시간 복잡도: O(N log N) (정렬 + 순회)
* 공간 복잡도: O(N)
* 구현이 간단하고 직관적

**선택 이유**:
* 시간 복잡도: O(N log N) - DP와 동일하지만, 정렬 후 단순 순회만 하므로 실제 연산 횟수가 더 적음
* 공간 복잡도: O(N) - DP 배열 불필요
* 구현 난이도: 매우 간단
* 가독성: 매우 직관적
* 문제 특성: 활동 선택 문제는 그리디 알고리즘의 전형적인 예시

**결론**: 그리디 알고리즘을 선택 ✅

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 끝나는 시간 기준 정렬

```java
Arrays.sort(meetings, (a, b) -> {
    if (a[1] == b[1]) {
        return a[0] - b[0];  // 끝나는 시간이 같으면 시작 시간 기준
    }
    return a[1] - b[1];  // 끝나는 시간 기준 오름차순
});
```

* 알고리즘 문서에서 설명한 대로, **끝나는 시간이 빠른 회의를 우선 선택**하기 위해 정렬
* 끝나는 시간이 같으면 시작 시간 기준으로 정렬
* 이는 알고리즘 문서의 **"정렬 후 선택"** 패턴과 정확히 일치한다

➡️ **그리디 선택 전략**이 코드에 직접 반영된 것이다.

---

### ② 그리디 선택 구현

```java
for (int[] meeting : meetings) {
    if (meeting[0] >= lastEnd) {  // 겹치지 않으면
        count++;
        lastEnd = meeting[1];
    }
}
```

* **현재 회의의 시작 시간이 마지막 선택한 회의의 끝 시간 이상**: `meeting[0] >= lastEnd`
  * 겹치지 않을 때만 선택 가능
* **선택 후 마지막 끝 시간 업데이트**: `lastEnd = meeting[1]`
  * 다음 회의 선택을 위한 기준점 설정

이 과정은 알고리즘 문서에서 설명한 **"매 순간 최선의 선택 반복"**과 정확히 일치한다:

* 끝나는 시간이 빠른 회의부터 확인
* 겹치지 않으면 선택
* 선택 후 마지막 끝 시간 업데이트

➡️ 알고리즘 문서에서 설명한 **"그리디 선택"** 패턴이 코드에 구현되어 있다.

---

### ③ 그리디 선택 속성의 증명

**핵심 아이디어**: 끝나는 시간이 가장 빠른 회의를 선택해도 이후 선택 기회가 줄어들지 않는다.

**증명**:
* 끝나는 시간이 가장 빠른 회의(A)를 선택하면
* A의 끝나는 시간 ≤ 다른 회의(B)의 끝나는 시간
* 따라서 A 이후에 선택 가능한 회의는 B 이후에 선택 가능한 회의를 포함
* 즉, A를 선택해도 최소한 B를 선택한 것과 같거나 더 많은 선택 가능

**코드에서의 반영**:
```java
if (meeting[0] >= lastEnd) {  // 겹치지 않으면
    count++;
    lastEnd = meeting[1];  // 끝나는 시간이 빠른 회의를 선택
}
```

➡️ 알고리즘 문서에서 설명한 **"탐욕 선택 속성"**이 코드에 명확히 구현되어 있다.

---

## 3️⃣ 정렬 방법 선택

### 고려한 방법들

#### 방법 1: 이분 탐색을 사용한 삽입 정렬

**평가**:
* 이분 탐색으로 삽입 위치 찾기 + 삽입
* 시간 복잡도: O(N²)

**소거 이유**: 비효율적 ❌

#### 방법 2: Arrays.sort() (선택) ✅

**평가**:
* Java 라이브러리가 최적화되어 있음
* 시간 복잡도: O(N log N)
* 구현이 간단함

**선택 근거**:
* 시간 복잡도: O(N log N)
* 최적화: Java 라이브러리가 최적화되어 있음
* 구현 간단: 한 줄로 해결
* 안정성: 검증된 라이브러리 사용

---

## 4️⃣ 시간/공간 복잡도와 코드의 대응

### 시간 복잡도 분석

* **정렬**: O(N log N) - 끝나는 시간 기준 정렬
* **그리디 선택**: O(N) - 회의 배열을 한 번 순회
* **전체 시간 복잡도**: **O(N log N)**

제약 조건 `N ≤ 100,000`으로 인해 O(N log N)은 충분히 빠르게 동작한다.

### 공간 복잡도 분석

* **회의 배열 저장**: O(N)
* **추가 공간**: O(1) - 카운터와 마지막 끝 시간만 저장
* **전체 공간 복잡도**: **O(N)**

### 코드에서의 대응

```java
Arrays.sort(meetings, ...);  // O(N log N) - 정렬

for (int[] meeting : meetings) {  // O(N) - 그리디 선택
    if (meeting[0] >= lastEnd) {  // O(1)
        count++;                   // O(1)
        lastEnd = meeting[1];      // O(1)
    }
}
```

➡️ **시간 복잡도 O(N log N), 공간 복잡도 O(N)**이 코드의 실제 동작과 일치한다.

---

## 5️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **활동 선택 구조**를 인식하고
* 알고리즘 문서([2.algorithm.md](./2.algorithm.md))에서 설명한 **그리디 선택 전략**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 6️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 동적 계획법 없이 그리디 알고리즘 활용
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(N log N))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **최적화**: 불필요한 연산 없이 최적의 구현

