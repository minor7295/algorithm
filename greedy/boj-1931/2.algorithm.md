# 알고리즘: 그리디 알고리즘 (Greedy Algorithm)

> 📖 **전체 알고리즘 설명**: [그리디 알고리즘 정리](../greedy-algorithm.md)

이 문제는 **그리디 알고리즘(Greedy Algorithm)**을 사용하여 해결합니다.  
상위 폴더의 [그리디 알고리즘 정리 문서](../greedy-algorithm.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 그리디 적용

### 문제 특성

* **활동 선택 문제**: 회의실 배정 문제는 활동 선택 문제의 변형
* **최대 개수**: 겹치지 않게 회의실을 사용할 수 있는 회의의 최대 개수
* **그리디 전략**: 끝나는 시간이 빠른 회의를 우선 선택

---

## 이 문제의 특이사항

### 1️⃣ 그리디 알고리즘 적용 가능 조건

이 문제에서 그리디 알고리즘이 최적해를 보장하는 이유:

* **탐욕 선택 속성**: 끝나는 시간이 가장 빠른 회의를 선택하는 것이 항상 최적해에 포함됨
* **최적 부분 구조**: 첫 번째 회의를 선택한 후, 남은 시간 구간에서의 최적해를 구하면 전체 최적해가 됨

### 2️⃣ 왜 그리디가 최적해를 보장하는가?

**끝나는 시간이 빠른 회의를 우선 선택**하는 이유:

끝나는 시간이 빠른 회의를 선택하면, 이후 더 많은 회의를 선택할 수 있는 기회가 생깁니다.

**단계별 최적해 보장 예시**:

다양한 회의 조합에서 그리디 알고리즘이 최적해를 보장하는지 확인:

**경우 1**: [(1,4), (3,5), (5,7), (6,8)]
- 1단계: (1,4) 선택 (끝=4, 가장 빠름) → 마지막 끝 시간 = 4
- 2단계: 남은 회의 (5,7), (6,8) 중 (5,7) 선택 (끝=7, 가장 빠름) → 마지막 끝 시간 = 7
- 3단계: (6,8) 선택 가능 (6 < 7, 겹침) → 선택 불가
- 결과: [(1,4), (5,7)] = 2개 선택 ✅

**경우 2**: [(1,4), (3,5), (5,8), (6,7)]
- 1단계: (1,4) 선택 (끝=4, 가장 빠름) → 마지막 끝 시간 = 4
- 2단계: 남은 회의 (5,8), (6,7) 중 (6,7) 선택 (끝=7, 가장 빠름) → 마지막 끝 시간 = 7
- 3단계: (5,8) 선택 가능 여부 확인 → (5 < 7, 겹침) → 선택 불가
- 결과: [(1,4), (6,7)] = 2개 선택 ✅

**경우 3**: [(1,4), (3,5), (5,6), (7,8)]
- 1단계: (1,4) 선택 (끝=4, 가장 빠름) → 마지막 끝 시간 = 4
- 2단계: 남은 회의 (5,6), (7,8) 중 (5,6) 선택 (끝=6, 가장 빠름) → 마지막 끝 시간 = 6
- 3단계: (7,8) 선택 가능 (7 >= 6) → 선택 ✅
- 결과: [(1,4), (5,6), (7,8)] = 3개 선택 ✅

**결론**: 세 가지 경우 모두에서 매 단계마다 끝나는 시간이 가장 빠른 회의를 선택하면
          최적해를 얻을 수 있음을 확인했다. 따라서 그리디 알고리즘을 사용해도 된다.
```

### 3️⃣ 정렬 기준

**끝나는 시간 기준 오름차순 정렬**:
- 끝나는 시간이 빠른 회의를 먼저 처리하기 위함

**끝나는 시간이 같을 경우**:
- 시작 시간 기준 오름차순 정렬 (또는 상관없음)
- 예: [(1,4), (2,4)] → 둘 다 끝나는 시간이 4이므로 순서는 상관없음

### 4️⃣ 시간 복잡도

* **정렬**: O(N log N) - 끝나는 시간 기준 정렬
* **그리디 선택**: O(N) - 회의 배열을 한 번 순회
* **전체 시간 복잡도**: **O(N log N)**

제약 조건 `N ≤ 100,000`으로 인해 O(N log N)은 충분히 빠르게 동작한다.

### 5️⃣ 공간 복잡도

* **회의 배열 저장**: O(N)
* **추가 공간**: O(1) - 카운터와 마지막 끝 시간만 저장
* **전체 공간 복잡도**: **O(N)**

> 💡 **정렬 방법 선택 및 시간/공간 복잡도 의사결정**: 정렬 방법 선택 과정과 시간/공간 복잡도에 대한 의사결정은 [3.reasoning.md](./3.reasoning.md)에 상세히 기록되어 있습니다.

---

## 알고리즘 단계

### 1단계: 입력 받기

```java
int N = Integer.parseInt(br.readLine());
int[][] meetings = new int[N][2];

for (int i = 0; i < N; i++) {
    StringTokenizer st = new StringTokenizer(br.readLine());
    meetings[i][0] = Integer.parseInt(st.nextToken()); // 시작 시간
    meetings[i][1] = Integer.parseInt(st.nextToken()); // 끝나는 시간
}
```

### 2단계: 정렬

**끝나는 시간 기준 오름차순 정렬** (끝나는 시간이 같으면 시작 시간 기준):

```java
Arrays.sort(meetings, (a, b) -> {
    if (a[1] == b[1]) {
        return a[0] - b[0]; // 끝나는 시간이 같으면 시작 시간 기준
    }
    return a[1] - b[1]; // 끝나는 시간 기준
});
```

### 3단계: 그리디 선택

**첫 번째 회의를 선택하고, 이후 회의들을 순회하면서 겹치지 않는 회의를 선택**:

```java
int count = 0;
int lastEnd = 0;

for (int[] meeting : meetings) {
    // 현재 회의의 시작 시간이 마지막 선택한 회의의 끝 시간 이상이면 선택 가능
    if (meeting[0] >= lastEnd) {
        count++;
        lastEnd = meeting[1];
    }
}
```

### 4단계: 결과 출력

```java
System.out.println(count);
```

---

## 알고리즘 동작 예시

### 입력
```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

### 처리 과정

```
1단계: 정렬 전
[(1,4), (3,5), (0,6), (5,7), (3,8), (5,9), (6,10), (8,11), (8,12), (2,13), (12,14)]

2단계: 끝나는 시간 기준 정렬
[(1,4), (3,5), (0,6), (5,7), (3,8), (5,9), (6,10), (8,11), (8,12), (2,13), (12,14)]

3단계: 그리디 선택
회의 (1,4): start=1 >= lastEnd=0 → 선택 ✅, count=1, lastEnd=4
회의 (3,5): start=3 < lastEnd=4 → 스킵 ❌
회의 (0,6): start=0 < lastEnd=4 → 스킵 ❌
회의 (5,7): start=5 >= lastEnd=4 → 선택 ✅, count=2, lastEnd=7
회의 (3,8): start=3 < lastEnd=7 → 스킵 ❌
회의 (5,9): start=5 < lastEnd=7 → 스킵 ❌
회의 (6,10): start=6 < lastEnd=7 → 스킵 ❌
회의 (8,11): start=8 >= lastEnd=7 → 선택 ✅, count=3, lastEnd=11
회의 (8,12): start=8 < lastEnd=11 → 스킵 ❌
회의 (2,13): start=2 < lastEnd=11 → 스킵 ❌
회의 (12,14): start=12 >= lastEnd=11 → 선택 ✅, count=4, lastEnd=14

4단계: 결과
4
```

---

## 정리

이 문제는 **그리디 알고리즘**을 사용하여 해결할 수 있는 전형적인 활동 선택 문제입니다.

* **핵심 전략**: 끝나는 시간이 빠른 회의를 우선 선택
* **시간 복잡도**: O(N log N) - 정렬 + O(N) - 순회
* **공간 복잡도**: O(N) - 회의 배열 저장
* **최적해 보장**: 탐욕 선택 속성과 최적 부분 구조를 만족

---

## 참고

* 전체 그리디 알고리즘 설명: [../greedy-algorithm.md](../greedy-algorithm.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

