# 알고리즘: 그리디 알고리즘 (Greedy Algorithm)

> 📖 **전체 알고리즘 설명**: [그리디 알고리즘 정리](../greedy-algorithm.md)

이 문제는 **그리디 알고리즘(Greedy Algorithm)**을 사용하여 해결합니다.  
상위 폴더의 [그리디 알고리즘 정리 문서](../greedy-algorithm.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 그리디 적용

### 문제 특성

* **동전 문제**: 동전을 사용하여 목표 금액 K를 만듦
* **무한 공급**: 각 동전을 제한 없이 사용 가능
* **최소 개수**: 사용하는 동전의 개수를 최소화
* **배수 조건**: 큰 동전이 작은 동전의 배수 (그리디 최적해 보장)

---

## 이 문제의 특이사항

### 1️⃣ 그리디 알고리즘 적용 가능 조건

이 문제에서 그리디 알고리즘이 최적해를 보장하는 이유:

* **배수 조건**: Ai는 Ai-1의 배수 (i ≥ 2)
  * 예: [1, 5, 10, 50, 100, ...] → 5는 1의 배수, 10은 5의 배수, ...
* **탐욕 선택 속성**: 큰 동전을 최대한 많이 사용하는 것이 항상 최적
* **최적 부분 구조**: 남은 금액에 대해서도 같은 전략이 최적

### 2️⃣ 왜 그리디가 최적해를 보장하는가?

큰 동전이 작은 동전의 배수이기 때문에:

* 큰 동전을 사용하지 않고 작은 동전으로 대체하면
* 더 많은 동전이 필요함
* 따라서 큰 동전을 최대한 많이 사용하는 것이 최적

**예시:**
```
K = 1000, 동전: [1, 10, 100, 1000]

그리디: 1000 × 1 = 1개 ✅
다른 방법: 100 × 10 = 10개 ❌ (더 많음)
```

### 3️⃣ 시간 복잡도

* **동전 배열 읽기**: O(N)
* **그리디 선택 반복**: O(N) - 최대 N번 반복
* **전체 시간 복잡도**: **O(N)**

제약 조건 `N ≤ 10`으로 인해 매우 빠르게 동작한다.

### 4️⃣ 공간 복잡도

* **동전 배열 저장**: O(N)
* **전체 공간 복잡도**: **O(N)**

---

## 핵심 구현 패턴

이 문제에 특화된 그리디 구현 방법 3가지를 비교합니다.

### 📊 방법 비교표

| 비교 기준 | 방법 1: 역순 순회 | 방법 2: 내림차순 정렬 | 방법 3: 반복문 최적화 |
|----------|-----------------|---------------------|-------------------|
| **시간 복잡도** | O(N) | O(N log N) | O(N) |
| **공간 복잡도** | O(N) | O(N) | O(N) |
| **추가 연산** | 없음 | 정렬 필요 | 없음 |
| **입력 조건 활용** | ✅ 오름차순 조건 활용 | ❌ 정렬 필요 | ✅ 오름차순 조건 활용 |
| **코드 간결성** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **가독성** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **조기 종료** | 명시적 (`if` 문) | 명시적 (`if` 문) | 조건문에 통합 |
| **권장도** | ✅ **권장** | ⚠️ 비권장 | ✅ 권장 |

---

### 방법 1: 역순 순회 (권장) ✅

```java
int[] coins = new int[N];
// ... 동전 입력 (오름차순)

int count = 0;
int remaining = K;

// 큰 동전부터 역순으로 순회
for (int i = N - 1; i >= 0; i--) {
    if (remaining <= 0) break;
    
    // 현재 동전으로 만들 수 있는 최대 개수
    int coinCount = remaining / coins[i];
    count += coinCount;
    remaining %= coins[i];
}

System.out.println(count);
```

#### ✅ 장점

1. **효율적**: O(N) 시간 복잡도, 정렬 불필요
2. **입력 조건 활용**: 문제에서 동전이 오름차순으로 주어진다는 조건을 그대로 활용
3. **가독성**: 조기 종료 조건이 명시적으로 드러남
4. **메모리 효율**: 기본 타입 배열(`int[]`) 사용

#### ❌ 단점

1. **인덱스 관리**: 역순 인덱스(`N-1`부터 시작)에 주의 필요

#### 💡 언제 사용?

- **권장**: 문제에서 입력이 이미 정렬되어 있는 경우
- 이 문제의 경우 동전이 오름차순으로 주어지므로 **가장 적합한 방법**

---

### 방법 2: 내림차순 정렬 후 순회

```java
Integer[] coins = new Integer[N];
// ... 동전 입력

// 내림차순 정렬
Arrays.sort(coins, Comparator.reverseOrder());

int count = 0;
int remaining = K;

for (int coin : coins) {
    if (remaining <= 0) break;
    
    int coinCount = remaining / coin;
    count += coinCount;
    remaining %= coin;
}

System.out.println(count);
```

#### ✅ 장점

1. **직관적**: 정렬 후 순회하는 일반적인 패턴
2. **향상된 for문**: 인덱스 관리 불필요

#### ❌ 단점

1. **비효율적**: O(N log N) 시간 복잡도 (정렬 비용)
2. **불필요한 연산**: 입력이 이미 정렬되어 있는데 다시 정렬
3. **메모리**: 래퍼 클래스(`Integer[]`) 사용으로 약간의 오버헤드

#### 💡 언제 사용?

- **비권장**: 이 문제에서는 입력이 이미 정렬되어 있어 불필요
- 입력 순서가 보장되지 않는 다른 문제에서는 유용할 수 있음

---

### 방법 3: 반복문 최적화 (권장) ✅

```java
int count = 0;
int remaining = K;

for (int i = N - 1; i >= 0 && remaining > 0; i--) {
    count += remaining / coins[i];
    remaining %= coins[i];
}

System.out.println(count);
```

#### ✅ 장점

1. **가장 간결**: 코드가 가장 짧고 간단함
2. **효율적**: O(N) 시간 복잡도, 정렬 불필요
3. **조기 종료 통합**: 조건을 반복문에 통합하여 코드 간결성 향상
4. **입력 조건 활용**: 오름차순 조건 활용

#### ❌ 단점

1. **가독성**: 조기 종료 조건이 반복문 조건에 숨어있어 덜 명시적
2. **디버깅**: 조건이 복합되어 있어 디버깅 시 약간 불편할 수 있음

#### 💡 언제 사용?

- **권장**: 코드 간결성을 중시하는 경우
- 숙련된 개발자에게 적합한 스타일

---

### 🎯 최종 권장사항

이 문제(BOJ 11047)의 경우:

1. **방법 1 (역순 순회)**: **가장 권장** ⭐
   - 입력이 오름차순으로 주어지는 조건을 활용
   - 가독성과 효율성의 균형이 좋음
   - 초보자도 이해하기 쉬움

2. **방법 3 (반복문 최적화)**: **권장** ⭐
   - 가장 간결한 코드
   - 숙련된 개발자에게 적합

3. **방법 2 (내림차순 정렬)**: **비권장** ⚠️
   - 이 문제에서는 불필요한 정렬로 인한 성능 저하
   - 입력이 이미 정렬되어 있으므로 사용할 이유 없음

---

## 다른 동전 문제와의 차이점

| 특징 | 일반 동전 문제 | 이 문제 (11047) |
|------|--------------|----------------|
| 배수 조건 | 없음 (DP 필요) | 있음 (그리디 가능) |
| 알고리즘 | 동적 계획법 | 그리디 알고리즘 |
| 시간 복잡도 | O(N × K) | O(N) |
| 최적해 보장 | 항상 보장 | 배수 조건 하에서 보장 |

### 배수 조건이 없는 경우

만약 동전이 [1, 3, 4]이고 K = 6이라면:

* **그리디**: 4 + 1 + 1 = 3개 ❌ (최적해 아님)
* **최적해**: 3 + 3 = 2개 ✅

➡️ 배수 조건이 없으면 그리디가 최적해를 보장하지 않으므로 **동적 계획법**을 사용해야 한다.

---

## 주의사항

### 1️⃣ 오버플로우 방지

* K는 최대 100,000,000이므로 `int` 타입으로 충분
* 동전 가치는 최대 1,000,000이므로 `int` 타입으로 충분

### 2️⃣ 남은 금액 체크

* `remaining <= 0`이면 더 이상 처리할 필요 없음
* 불필요한 반복을 줄이기 위해 조기 종료

### 3️⃣ 동전 배열 순서

* 입력은 오름차순으로 주어지므로
* 역순으로 순회하거나 내림차순 정렬 필요

---

## 참고

* 전체 그리디 알고리즘 설명: [../greedy-algorithm.md](../greedy-algorithm.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

