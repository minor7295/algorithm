# Main.java 설계 근거 정리

이 문서는 **BOJ 11047 동전 0 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **그리디 알고리즘 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 그리디 알고리즘

### 문제 특성과의 적합성

* 문제 요구사항
  * N종류의 동전을 사용하여 목표 금액 K를 만듦
  * 각 동전을 무한히 많이 사용 가능
  * 사용하는 동전의 개수를 최소화
* 제약 조건
  * `1 ≤ N ≤ 10` (동전 종류 수)
  * `1 ≤ K ≤ 100,000,000` (목표 금액)
  * **큰 동전이 작은 동전의 배수** (핵심 조건)

이 문제는 **그리디 알고리즘**을 사용할 수 있는 전형적인 동전 문제로, 다음과 같은 특성이 있다:

* **탐욕 선택 속성**: 큰 동전을 최대한 많이 사용하는 것이 항상 최적
* **최적 부분 구조**: 남은 금액에 대해서도 같은 전략이 최적
* **배수 조건**: 큰 동전이 작은 동전의 배수 → 그리디 최적해 보장

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **그리디 알고리즘(Greedy Algorithm)**이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 동전 배열 역순 순회

```java
for (int i = N - 1; i >= 0; i--) {
    // 큰 동전부터 처리
}
```

* 알고리즘 문서에서 설명한 대로, **큰 동전부터 최대한 많이 사용**하는 것이 최적
* 입력은 오름차순으로 주어지므로 **역순으로 순회**하여 큰 동전부터 처리
* 이는 알고리즘 문서의 **"정렬 후 선택"** 패턴과 정확히 일치한다

➡️ **그리디 선택 전략**이 코드에 직접 반영된 것이다.

---

### ② 그리디 선택 구현

```java
int coinCount = remaining / coins[i];
count += coinCount;
remaining %= coins[i];
```

* **현재 동전으로 만들 수 있는 최대 개수**: `remaining / coins[i]`
  * 현재 상황에서 가장 많은 개수를 선택 (그리디 선택)
* **사용한 동전 개수 추가**: `count += coinCount`
* **남은 금액 계산**: `remaining %= coins[i]`
  * 다음 단계에서 처리할 남은 금액

이 과정은 알고리즘 문서에서 설명한 **"매 순간 최선의 선택 반복"**과 정확히 일치한다:

* 현재 동전(큰 동전)을 최대한 많이 사용
* 남은 금액에 대해서도 같은 전략 적용
* 최적 부분 구조를 활용

➡️ 알고리즘 문서에서 설명한 **"반복 선택"** 패턴이 코드에 구현되어 있다.

---

### ③ 조기 종료 최적화

```java
if (remaining <= 0) break;
```

* 남은 금액이 0 이하이면 더 이상 처리할 필요 없음
* 불필요한 반복을 줄여 성능 향상
* 알고리즘 문서의 **"최적화 고려사항"**과 일치

---

## 3️⃣ 입력 처리 방식

### BufferedReader 사용

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
int K = Integer.parseInt(br.readLine());
```

* 대량의 입력을 효율적으로 처리하기 위해 `BufferedReader` 사용
* `N ≤ 10`이므로 입력 크기는 작지만, 표준적인 입력 처리 방식 사용

### 동전 배열 입력

```java
int[] coins = new int[N];
for (int i = 0; i < N; i++) {
    coins[i] = Integer.parseInt(br.readLine());
}
```

* 동전 가치를 배열에 저장
* 입력은 오름차순으로 주어지므로 별도 정렬 불필요

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 연산별 시간 복잡도

* **동전 배열 읽기**: O(N)
* **그리디 선택 반복**: O(N) - 최대 N번 반복
* **전체 시간 복잡도**: **O(N)**

### 코드에서의 대응

```java
for (int i = 0; i < N; i++) {  // O(N) - 동전 입력
    coins[i] = Integer.parseInt(br.readLine());
}

for (int i = N - 1; i >= 0; i--) {  // O(N) - 그리디 선택
    if (remaining <= 0) break;
    
    int coinCount = remaining / coins[i];  // O(1)
    count += coinCount;                     // O(1)
    remaining %= coins[i];                 // O(1)
}
```

* 첫 번째 루프: N번 반복 (동전 입력)
* 두 번째 루프: 최대 N번 반복 (그리디 선택)
* 각 반복마다 O(1) 연산 수행
* 전체 시간 복잡도: **O(N)**

➡️ 알고리즘 문서에서 설명한 **"시간 복잡도 분석"**이 코드의 실제 동작과 일치한다.

---

## 5️⃣ 공간 복잡도 분석

### 동전 배열 저장

* `int[] coins`: N개의 동전 가치 저장
* 공간: **O(N)**

### 전체 공간 복잡도

* **O(N)** - 동전 배열에 저장할 수 있는 최대 원소 개수에 비례

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 그리디 알고리즘 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 시간 복잡도 O(N)으로 매우 효율적
* 코드가 간결함
* 배수 조건 하에서 최적해 보장

**단점:**
* 배수 조건이 없으면 사용 불가

### 방법 2: 동적 계획법 (DP)

```java
int[] dp = new int[K + 1];
Arrays.fill(dp, Integer.MAX_VALUE);
dp[0] = 0;

for (int i = 1; i <= K; i++) {
    for (int coin : coins) {
        if (i >= coin && dp[i - coin] != Integer.MAX_VALUE) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
}
```

**장점:**
* 배수 조건이 없어도 최적해 보장
* 모든 경우를 고려

**단점:**
* 시간 복잡도 O(N × K)로 비효율적
* K가 최대 100,000,000이므로 메모리와 시간 초과 가능
* 구현이 복잡함

### 방법 3: 완전 탐색 (백트래킹)

**단점:**
* 시간 복잡도가 지수적으로 증가
* K가 크면 불가능
* 비효율적

➡️ **그리디 알고리즘을 사용하는 것이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N) 시간 복잡도로 문제 제약 조건 내에서 충분히 빠름
* **최적화**: 조기 종료로 불필요한 반복 제거

### 추가 최적화 가능성

* **조기 종료**: 이미 적용됨 (`if (remaining <= 0) break`)
* **변수 최적화**: 현재 구현이 이미 최적화됨

현재 구현이 문제 제약 조건 내에서 충분히 효율적이다.

---

## 8️⃣ 그리디 알고리즘의 최적해 보장

### 배수 조건의 중요성

문제 조건: **"Ai는 Ai-1의 배수 (i ≥ 2)"**

이 조건이 있기 때문에 그리디 알고리즘이 최적해를 보장한다:

* 큰 동전을 사용하지 않고 작은 동전으로 대체하면
* 더 많은 동전이 필요함
* 따라서 큰 동전을 최대한 많이 사용하는 것이 최적

**예시:**
```
동전: [1, 5, 10, 50, 100, 500, 1000]
K = 4200

그리디: 1000×4 + 100×2 = 6개 ✅
다른 방법: 500×8 + 100×2 = 10개 ❌ (더 많음)
```

### 코드에서의 반영

```java
for (int i = N - 1; i >= 0; i--) {  // 큰 동전부터
    int coinCount = remaining / coins[i];  // 최대한 많이 사용
    count += coinCount;
    remaining %= coins[i];
}
```

➡️ 알고리즘 문서에서 설명한 **"탐욕 선택 속성"**이 코드에 명확히 구현되어 있다.

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **그리디 구조**를 인식하고
* 알고리즘 문서에서 설명한 **그리디 선택 전략**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **단순성**: 복잡한 동적 계획법 없이 그리디 알고리즘 활용
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(N))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **최적화**: 조기 종료로 불필요한 연산 제거

