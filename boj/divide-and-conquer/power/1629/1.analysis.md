# 곱셈 (분할정복 거듭제곱)

## 📌 문제 요약

자연수 A를 B번 곱한 수를 C로 나눈 나머지를 구하는 프로그램을 작성한다.

단, 구하려는 수가 매우 커질 수 있으므로 모듈로 연산을 사용해야 한다.

---

## 🔍 문제 설명

* 자연수 **A**를 **B**번 곱한 수: `A^B`
* 이 값을 **C**로 나눈 나머지: `A^B mod C`
* A, B, C는 모두 매우 큰 수 (최대 2,147,483,647)

---

## 📥 입력 조건

* 첫째 줄에 정수 `A`, `B`, `C`가 빈 칸을 사이에 두고 순서대로 주어짐
* `A, B, C는 모두 2,147,483,647 이하의 자연수`

---

## 📤 출력 조건

* 첫째 줄에 `A^B mod C`를 출력

---

## 💡 문제 핵심 해석

### 문제의 핵심

* **거듭제곱 계산**: `A^B`를 계산해야 함
* **모듈로 연산**: 결과가 매우 커질 수 있으므로 `mod C` 연산 필요
* **큰 지수 처리**: B가 최대 2,147,483,647이므로 선형 시간 알고리즘으로는 시간 초과

### 왜 분할정복이 필요한가?

* **일반적인 방법 (O(B))**: A를 B번 곱하면 시간 초과
  * B가 최대 2,147,483,647이므로 약 21억 번의 연산 필요
  * 시간 제한 0.5초 내에 불가능
* **분할정복 방법 (O(log B))**: 지수를 절반으로 나누어 계산
  * 최대 약 31번의 재귀 호출로 해결 가능
  * 시간 제한 내에 충분히 해결 가능

➡️ **분할정복을 이용한 거듭제곱 알고리즘**이 필요하다.

---

## 🔗 분할정복 일반론과의 연관관계

> 📖 **상위 개념**: [분할정복(Divide and Conquer) 정리](../../divide-and-conquer.md)

이 문제는 **분할정복 알고리즘 설계 기법**의 전형적인 적용 사례입니다.  
상위 문서인 [분할정복 정리](../../divide-and-conquer.md)에서 설명하는 분할정복의 일반 원리가 이 문제에 어떻게 적용되는지 살펴보겠습니다.

### 분할정복의 3단계 프로세스 적용

분할정복 알고리즘은 일반적으로 **Divide(분할) → Conquer(정복) → Combine(결합)** 3단계로 구성됩니다.  
이 문제에서 각 단계는 다음과 같이 대응됩니다:

#### 1️⃣ Divide (분할)

**일반 원리**: 문제를 더 작은 하위 문제들로 나눈다.

**이 문제에서의 적용**:
* 원래 문제: `A^B mod C` 계산
* 하위 문제로 분할: `A^B = A^(B/2) * A^(B/2)` (B가 짝수인 경우)
* 지수 B를 절반으로 나누어 더 작은 거듭제곱 문제로 변환

**예시**:
```
A^B (원래 문제)
  ↓ Divide
A^(B/2) (하위 문제 1) × A^(B/2) (하위 문제 2)
```

#### 2️⃣ Conquer (정복)

**일반 원리**: 하위 문제들을 재귀적으로 해결한다.

**이 문제에서의 적용**:
* 하위 문제 `A^(B/2) mod C`를 재귀적으로 계산
* 더 작은 지수에 대해 동일한 분할정복 과정 반복
* Base Case에 도달할 때까지 재귀 호출

**예시**:
```
A^(B/2) 계산
  ↓ 재귀 호출
A^(B/4) 계산
  ↓ 재귀 호출
...
  ↓ Base Case
A^1 또는 A^0
```

#### 3️⃣ Combine (결합)

**일반 원리**: 하위 문제들의 해를 결합하여 원래 문제의 해를 구한다.

**이 문제에서의 적용**:
* 하위 문제들의 해를 곱셈으로 결합: `A^(B/2) × A^(B/2) = A^B`
* 지수가 홀수인 경우 추가 곱셈: `A^B = A^(B/2) × A^(B/2) × A`
* 각 단계에서 모듈로 연산 적용: `(result × result) % C`

**예시**:
```
A^(B/2) mod C (하위 해 1)
A^(B/2) mod C (하위 해 2)
  ↓ Combine
(A^(B/2) × A^(B/2)) mod C = A^B mod C
```

### 분할정복의 구조와 이 문제의 대응

상위 문서에서 설명하는 분할정복의 일반적인 구조:

```
원래 문제
    │
    ├─ Divide: 작은 문제들로 분할
    │
    ├─ Conquer: 각 하위 문제 해결
    │   ├─ 하위 문제 1
    │   ├─ 하위 문제 2
    │   └─ ...
    │
    └─ Combine: 해를 결합
```

이 문제에서의 구체적인 적용:

```
A^B mod C (원래 문제)
    │
    ├─ Divide: A^B = A^(B/2) × A^(B/2)
    │
    ├─ Conquer: 각 하위 문제 재귀적으로 해결
    │   ├─ A^(B/2) mod C 계산
    │   └─ A^(B/2) mod C 계산 (같은 값)
    │
    └─ Combine: (A^(B/2) × A^(B/2)) mod C = A^B mod C
```

### 분할정복의 핵심 요소와 이 문제

상위 문서에서 설명하는 분할정복의 핵심 요소:

1. **Base Case**: 더 이상 나눌 수 없는 가장 작은 문제
   * 이 문제: `exponent == 0` → `1 mod C`, `exponent == 1` → `A mod C`

2. **Divide**: 문제를 작은 하위 문제들로 분할
   * 이 문제: 지수를 절반으로 나누기 (`B → B/2`)

3. **Conquer**: 하위 문제들을 재귀적으로 해결
   * 이 문제: `power(A, B/2, C)` 재귀 호출

4. **Combine**: 하위 문제들의 해를 결합
   * 이 문제: 곱셈으로 결합 (`half × half mod C`)

### 마스터 정리와 시간 복잡도

상위 문서의 **마스터 정리(Master Theorem)**를 이 문제에 적용하면:

```
T(B) = T(B/2) + O(1)

여기서:
- a = 1 (하위 문제 1개)
- b = 2 (각 하위 문제의 크기 비율 1/2)
- f(B) = O(1) (분할과 결합에 드는 시간)

log_b(a) = log_2(1) = 0
c = 0 (f(B) = O(1) = O(B^0))

f(B) = Θ(B^c) where c = log_b(a) 이므로 경우 2
→ T(B) = Θ(B^0 × log B) = Θ(log B)
```

➡️ **이 문제의 시간 복잡도 O(log B)는 마스터 정리로 정확히 분석 가능**합니다.

---

## 🧠 해결 전략 개요

* 분할정복을 이용한 거듭제곱 알고리즘 사용
* 지수를 절반으로 나누어 재귀적으로 계산
* 각 단계에서 모듈로 연산을 적용하여 오버플로우 방지
* 시간 복잡도: `O(log B)`

---

## ✨ 예시

### 예시 1: 기본 케이스

**입력**
```
10 11 12
```

**출력**
```
4
```

**설명**: 
* `10^11 = 100000000000`
* `100000000000 mod 12 = 4`

**분할정복 과정**:
```
10^11
  = 10^5 * 10^5 * 10
  = (10^2 * 10^2 * 10) * (10^2 * 10^2 * 10) * 10
  = ...
```

---

### 예시 2: 큰 수

**입력**
```
2147483647 2147483647 1000000007
```

**출력**
* 매우 큰 수의 거듭제곱을 모듈로 연산으로 계산

**설명**: 
* 선형 시간 알고리즘으로는 절대 불가능
* 분할정복으로 O(log 2147483647) ≈ O(31) 시간에 해결

---

## 📝 정리

이 문제는 **분할정복을 이용한 거듭제곱**의 전형적인 문제이다.

* 큰 지수의 거듭제곱을 효율적으로 계산
* 모듈로 연산과 함께 사용하여 큰 수 처리
* O(log B) 시간 복잡도로 해결 가능

