# Main.java 설계 근거 정리

이 문서는 **BOJ 1629 곱셈 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **분할정복 거듭제곱 개념과 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 분할정복 거듭제곱

### 문제 특성과의 적합성

* **입력 크기**
  * A, B, C: 최대 2,147,483,647
  * 특히 B가 매우 큰 지수
* **시간 제한**
  * 0.5초 (매우 짧음)
* **출력 조건**
  * `A^B mod C` 계산

이 문제는 **큰 지수의 거듭제곱을 모듈로 연산과 함께 계산**하는 문제이다.

따라서 다음 조건을 만족하는 알고리즘이 필요하다:

* `O(log B)` 시간 복잡도
* 모듈로 연산을 각 단계에서 적용
* 오버플로우 방지

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **분할정복을 이용한 거듭제곱** 알고리즘이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① Base Case 처리

```java
if (exponent == 0) {
    return 1 % mod;
}
if (exponent == 1) {
    return base % mod;
}
```

* **exponent == 0**: `A^0 = 1` (모든 수의 0제곱은 1)
* **exponent == 1**: `A^1 = A`
* 각 경우에 `mod` 연산을 적용하여 일관성 유지

➡️ **Base Case는 더 이상 나눌 수 없는 가장 작은 문제**를 의미하며, 코드에 명시적으로 반영되어 있다.

---

### ② Divide: 지수를 반으로 나누기

```java
long half = power(base, exponent / 2, mod);
```

* 지수를 절반으로 나누어 재귀 호출
* `exponent / 2`는 정수 나눗셈 (홀수일 경우 자동으로 내림)
* 각 재귀 호출에서도 모듈로 연산이 적용됨

➡️ **Divide 단계는 문제를 작은 하위 문제로 나누는 과정**이며, 코드에서 재귀 호출로 구현되어 있다.

---

### ③ Conquer: 절반의 거듭제곱 계산

```java
long result = (half * half) % mod;
```

* 하위 문제의 해(`half`)를 이용하여 결과 계산
* `half * half`는 `A^(B/2) * A^(B/2) = A^B` (B가 짝수인 경우)
* **모듈로 연산을 곱셈 직후에 적용**하여 오버플로우 방지

➡️ **Conquer 단계는 하위 문제의 해를 이용하여 원래 문제의 해를 구하는 과정**이며, 곱셈 연산으로 구현되어 있다.

---

### ④ Combine: 홀수 지수 처리

```java
if (exponent % 2 == 1) {
    result = (result * base) % mod;
}
```

* 지수가 홀수인 경우 추가 곱셈 필요
* `A^B = A^(B/2) * A^(B/2) * A` (B가 홀수인 경우)
* 모듈로 연산을 적용하여 오버플로우 방지

➡️ **Combine 단계는 하위 문제들의 해를 결합하는 과정**이며, 조건문과 곱셈으로 구현되어 있다.

---

## 3️⃣ 모듈로 연산의 중요성

### 왜 각 단계에서 모듈로 연산이 필요한가?

```java
// 잘못된 예: 오버플로우 발생 가능
long result = half * half;
if (exponent % 2 == 1) {
    result = result * base;
}
return result % mod;

// 올바른 예: 각 단계에서 모듈로 연산
long result = (half * half) % mod;
if (exponent % 2 == 1) {
    result = (result * base) % mod;
}
```

**문제점:**

* `half`가 최대 `mod - 1`이어도 `half * half`는 `(mod - 1)^2`가 될 수 있음
* `mod`가 최대 2,147,483,647이면 `(mod - 1)^2`는 약 4.6 × 10^18
* long 타입의 최대값은 약 9.2 × 10^18이므로 오버플로우 가능성 있음
* 더 큰 수를 곱하면 확실히 오버플로우 발생

**해결책:**

* 각 곱셈 연산마다 모듈로 연산을 적용
* 중간 결과를 항상 `mod` 범위 내로 유지
* 오버플로우 방지 및 정확한 결과 보장

➡️ **모듈로 연산은 단순히 결과를 줄이는 것이 아니라, 오버플로우를 방지하는 필수적인 요소**이다.

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 재귀 호출 깊이

* 각 재귀 호출마다 지수가 절반으로 줄어듦
* B → B/2 → B/4 → ... → 1
* 총 재귀 깊이: `⌊log₂(B)⌋ + 1`

**예시:**
* B = 2,147,483,647 (약 2^31)
* 재귀 깊이: 약 31번
* 각 재귀 호출에서 O(1) 시간 소요
* 전체 시간: O(31) = O(log B)

➡️ **코드의 재귀 구조는 시간 복잡도 O(log B)를 보장**한다.

---

### 각 재귀 호출의 연산

* 나눗셈: `exponent / 2` → O(1)
* 곱셈: `half * half` → O(1)
* 모듈로 연산: `% mod` → O(1)
* 조건문: `exponent % 2` → O(1)

➡️ **각 재귀 호출은 상수 시간에 수행**되므로, 전체 시간 복잡도는 재귀 깊이에 비례한다.

---

## 5️⃣ 공간 복잡도와 코드의 대응

### 재귀 호출 스택

* 최대 재귀 깊이: O(log B)
* 각 재귀 호출마다 스택 프레임 생성
* 스택 프레임 크기: O(1) (변수 몇 개만 저장)

➡️ **공간 복잡도는 O(log B)**이며, B가 최대 21억이어도 약 31개의 스택 프레임만 필요하다.

---

## 6️⃣ 일반적인 방법과의 비교

### 일반적인 방법 (O(B))

```java
long result = 1;
for (int i = 0; i < B; i++) {
    result = (result * A) % C;
}
```

**문제점:**
* B가 최대 2,147,483,647이면 약 21억 번의 반복 필요
* 시간 제한 0.5초 내에 불가능
* 시간 초과 발생

### 분할정복 방법 (O(log B))

```java
long power(long base, long exponent, long mod) {
    // ... 재귀 호출
}
```

**장점:**
* 약 31번의 재귀 호출로 해결
* 시간 제한 내에 충분히 해결 가능
* 효율적인 알고리즘

➡️ **분할정복 방법이 이 문제에 필수적**이다.

---

## 7️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **큰 지수 거듭제곱**을 효율적으로 계산하고
* 알고리즘 논의에서 설명한 **분할정복 구조**를 그대로 구현하며
* **모듈로 연산을 적절히 적용**하여 오버플로우를 방지하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

