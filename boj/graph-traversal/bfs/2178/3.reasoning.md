# Main.java 설계 근거 정리

이 문서는 **BOJ 2178 미로 탐색 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **BFS 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: BFS

### 문제 특성과의 적합성

* **2차원 격자**에서의 경로 찾기
* **가중치 없는 그래프** (모든 이동의 비용이 동일)
* **최단 경로**를 찾아야 함
* 입력 크기: N, M ≤ 100

이 문제는 **가중치가 없는 그래프에서의 최단 경로 문제**입니다.

따라서 다음 조건을 만족하는 알고리즘이 필요합니다:

* 가중치 없는 그래프에서 최단 경로 보장
* O(N × M) 시간 복잡도
* 구현이 간단하고 직관적

➡️ 이러한 조건을 가장 잘 만족하는 방법이 **BFS (너비 우선 탐색)** 입니다.

---

## 2️⃣ 코드 구조와 BFS 논의의 1:1 대응

### ① 2차원 격자 초기화

```java
int N = Integer.parseInt(st.nextToken());
int M = Integer.parseInt(st.nextToken());
int[][] map = new int[N][M];
boolean[][] visited = new boolean[N][M];
int[][] distance = new int[N][M];
```

* BFS 문서에서 설명한 **2차원 격자 탐색 패턴**을 사용
* `map[][]`: 미로 정보 저장 (1: 이동 가능, 0: 이동 불가)
* `visited[][]`: 방문 체크 배열
* `distance[][]`: 각 칸까지의 최단 거리 저장

### ② 4방향 이동 배열

```java
// 좌표계 기준: x는 가로(왼쪽→오른쪽), y는 세로(아래→위)
int[] dx = {0, 0, -1, 1};  // 상, 하, 좌, 우의 x(가로) 변화량
int[] dy = {1, -1, 0, 0};  // 상, 하, 좌, 우의 y(세로) 변화량
```

* BFS 문서의 **패턴 2: 2차원 격자 탐색**에서 설명한 방식
* 상하좌우 4방향 이동을 배열로 표현하여 반복문으로 처리
* 수학 좌표계 기준: x는 가로, y는 세로

### ③ BFS 시작점 처리

```java
queue.offer(new int[]{0, 0});
visited[0][0] = true;
distance[0][0] = 1;
```

* BFS 문서에서 설명한 **시작 정점 처리** 패턴
* 큐에 시작점 추가, 방문 체크, 거리 초기화 (시작 위치 포함하므로 1)

### ④ BFS 메인 루프

```java
while (!queue.isEmpty()) {
    int[] current = queue.poll();
    int y = current[0];  // y는 세로 (행)
    int x = current[1];  // x는 가로 (열)
    
    // 도착점 확인
    // 주의: 배열은 map[y][x] 형태로 사용 (y가 행, x가 열)
    if (y == N - 1 && x == M - 1) {
        return distance[y][x];
    }
    
    // 4방향 탐색
    // i=0: 상, i=1: 하, i=2: 좌, i=3: 우
    for (int i = 0; i < 4; i++) {
        int ny = y + dy[i];  // y(세로) 변화
        int nx = x + dx[i];  // x(가로) 변화
        
        // 범위 체크, 방문 체크, 이동 가능 체크
        // 주의: 배열 인덱스는 [y][x] 순서
        if (ny >= 0 && ny < N && nx >= 0 && nx < M 
            && !visited[ny][nx] && map[ny][nx] == 1) {
            visited[ny][nx] = true;
            distance[ny][nx] = distance[y][x] + 1;
            queue.offer(new int[]{ny, nx});
        }
    }
}
```

이 코드는 BFS 문서의 **기본 구현**과 **2차원 격자 탐색 패턴**을 결합한 것입니다.

**BFS 문서의 핵심 원칙과의 대응:**

1. **큐에서 정점 꺼내기**: `queue.poll()` → 현재 칸 처리
2. **도착점 확인**: 도착점에 도달하면 즉시 거리 반환 (최단 경로 보장)
3. **인접 정점 탐색**: `for (int i = 0; i < 4; i++)` → 4방향 탐색
4. **방문 체크**: `!visited[ny][nx]` → 방문하지 않은 칸만 처리
5. **거리 업데이트**: `distance[ny][nx] = distance[y][x] + 1` → 최단 거리 계산
6. **큐에 추가**: `queue.offer(new int[]{ny, nx})` → 다음 탐색 대상 추가

### ⑤ 방문 체크 시점

```java
if (ny >= 0 && ny < N && nx >= 0 && nx < M 
    && !visited[ny][nx] && map[ny][nx] == 1) {
    visited[ny][nx] = true;  // 먼저 체크
    distance[ny][nx] = distance[y][x] + 1;
    queue.offer(new int[]{ny, nx});
}
```

* BFS 문서의 **주의사항: 방문 체크 시점**에서 설명한 올바른 패턴
* 큐에 넣기 **전에** 방문 체크를 수행하여 중복 방문 방지
* 배열 인덱스는 `[y][x]` 순서로 사용 (y가 행, x가 열)

---

## 3️⃣ BFS의 최단 경로 보장

### 왜 BFS가 최단 경로를 보장하는가?

* BFS는 **레벨별 탐색**을 수행
* 거리 0 → 거리 1 → 거리 2 순서로 탐색
* 따라서 **처음 도착점에 도달했을 때**가 항상 최단 경로

이 문제에서:
* `distance[y][x]`는 시작점 `(0, 0)`에서 `(y, x)`까지의 최단 거리
* 주의: 배열은 `map[y][x]` 형태로 사용 (y가 행, x가 열)
* 도착점 `(N-1, M-1)`에 처음 도달했을 때의 거리가 최단 경로

---

## 4️⃣ 2차원 격자 BFS의 특징

### 범위 체크

```java
if (ny >= 0 && ny < N && nx >= 0 && nx < M 
    && !visited[ny][nx] && map[ny][nx] == 1)
```

* 2차원 격자에서는 **배열 범위를 벗어나지 않도록** 체크 필요
* `map[ny][nx] == 1`: 이동 가능한 칸인지 확인
* 주의: 배열 인덱스는 `[y][x]` 순서 (y가 행, x가 열)

### 거리 계산

```java
distance[ny][nx] = distance[y][x] + 1;
```

* 이전 칸의 거리 + 1로 업데이트
* BFS의 레벨별 탐색 특성상 항상 최단 거리 보장
* 주의: 배열 인덱스는 `[y][x]` 순서로 사용

---

## 5️⃣ 시간 복잡도와 코드의 대응

### 시간 복잡도: O(N × M)

* **각 칸을 최대 한 번씩 방문**: O(N × M)
* **각 칸에서 4방향 확인**: O(1) (상수 시간)
* **전체**: O(N × M)

코드에서:
* `while (!queue.isEmpty())`: 최대 N × M번 반복
* `for (int i = 0; i < 4; i++)`: 항상 4번 반복 (상수)

---

## 6️⃣ 공간 복잡도와 코드의 대응

### 공간 복잡도: O(N × M)

* **미로 저장**: `map[N][M]` → O(N × M)
* **방문 배열**: `visited[N][M]` → O(N × M)
* **거리 배열**: `distance[N][M]` → O(N × M)
* **큐**: 최악의 경우 O(N × M)

---

## 7️⃣ 다른 접근 방법과의 비교

### DFS를 사용하지 않은 이유

* **최단 경로 보장 불가**: DFS는 깊이 우선 탐색이므로 최단 경로를 보장하지 않음
* **비효율적**: 모든 경로를 탐색해야 할 수 있음

### 다익스트라를 사용하지 않은 이유

* **가중치가 없음**: 모든 간선의 가중치가 1로 동일
* **과도한 복잡도**: 다익스트라는 가중치가 있는 그래프에 적합
* **BFS로 충분**: 가중치 없는 그래프에서는 BFS가 더 간단하고 효율적

---

## ✨ 결론

이 문제는 **가중치 없는 2차원 격자에서의 최단 경로 문제**로, BFS 알고리즘을 사용하는 것이 가장 적합합니다. BFS의 레벨별 탐색 특성을 활용하여 시작점에서 도착점까지의 최단 거리를 효율적으로 계산할 수 있습니다.

