# 순열 사이클

## 📌 문제 요약

1부터 N까지 정수 N개로 이루어진 순열이 주어졌을 때, 순열을 방향 그래프로 표현했을 때 존재하는 **사이클의 개수**를 구하는 문제입니다.

순열을 배열로 표현하면 다음과 같습니다:

```
(1  2  ...  i  ...  n)
(π₁ π₂ ... πᵢ ... πₙ)
```

이를 그래프로 표현하면 각 정점 i에서 정점 πi로 가는 간선이 있는 방향 그래프가 됩니다.

---

## 🔍 문제 설명

* 순열은 **1부터 N까지의 정수**로 이루어짐
* 순열을 **방향 그래프**로 표현: 정점 i에서 정점 πi로 간선이 존재
* 이 그래프에서 **사이클의 개수**를 구해야 함
* 각 정점은 **정확히 하나의 나가는 간선**을 가짐 (순열의 특성)
* 각 정점은 **정확히 하나의 들어오는 간선**을 가짐 (순열의 특성)

> **순열의 특성**:
> * 각 정점은 정확히 하나의 나가는 간선을 가짐 (i → πi)
> * 각 정점은 정확히 하나의 들어오는 간선을 가짐 (어떤 j에 대해 j → i)
> * 따라서 그래프는 **여러 개의 사이클**로 구성됨
> * 모든 정점은 정확히 하나의 사이클에 속함

---

## 📥 입력 조건

* 첫째 줄에 테스트 케이스의 개수 T
* 각 테스트 케이스의 첫째 줄에는 순열의 크기 N (2 ≤ N ≤ 1,000)
* 각 테스트 케이스의 둘째 줄에는 순열이 주어지며, 각 정수는 공백으로 구분됨

---

## 📤 출력 조건

* 각 테스트 케이스마다, 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력

---

## 💡 문제 핵심 해석

* 순열을 **방향 그래프**로 모델링
* 각 정점 i에서 정점 πi로 가는 간선이 존재
* 순열의 특성상 그래프는 **여러 개의 사이클**로 구성됨
* 모든 정점은 정확히 하나의 사이클에 속함
* **사이클의 개수**를 구하는 문제

➡️ **연결 요소(Connected Component) 찾기** 문제로 볼 수 있으며, **DFS** 알고리즘을 사용하여 해결할 수 있습니다.

---

## 🧠 해결 전략 개요

* **DFS (깊이 우선 탐색)** 사용
* 방문하지 않은 각 정점에서 DFS를 시작
* DFS가 완료되면 하나의 사이클을 찾은 것
* DFS를 시작한 횟수가 사이클의 개수

---

## ✨ 예시

### 예시 1: 문제에서 제공한 예시

**입력**
```
8
3 2 7 8 1 4 5 6
```

**순열 표현**
```
1 → 3
2 → 2
3 → 7
4 → 8
5 → 1
6 → 4
7 → 5
8 → 6
```

**그래프 구조**
```
1 → 3 → 7 → 5 → 1  (사이클 1)
2 → 2              (사이클 2)
4 → 8 → 6 → 4      (사이클 3)
```

**출력**
```
3
```

**설명**: 총 3개의 사이클이 존재합니다.

### 예시 2: 두 번째 예시

**입력**
```
10
2 1 3 4 5 6 7 9 10 8
```

**순열 표현**
```
1 → 2
2 → 1
3 → 3
4 → 4
5 → 5
6 → 6
7 → 7
8 → 9
9 → 10
10 → 8
```

**그래프 구조**
```
1 → 2 → 1        (사이클 1)
3 → 3            (사이클 2)
4 → 4            (사이클 3)
5 → 5            (사이클 4)
6 → 6            (사이클 5)
7 → 7            (사이클 6)
8 → 9 → 10 → 8  (사이클 7)
```

**출력**
```
7
```

**설명**: 총 7개의 사이클이 존재합니다.

---

## 📝 정리

이 문제는 **순열을 방향 그래프로 모델링하여 사이클의 개수를 찾는** 문제로, DFS 알고리즘을 사용하여 효율적으로 해결할 수 있습니다. 순열의 특성상 각 정점은 정확히 하나의 사이클에 속하므로, 방문하지 않은 정점에서 DFS를 시작할 때마다 하나의 사이클을 찾을 수 있습니다.

