# Main.java 설계 근거 정리

이 문서는 **BOJ 15651 N과 M (3) 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **백트래킹 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 백트래킹

### 문제 특성과의 적합성

* 문제 요구사항
  * 1부터 N까지의 자연수 중 M개를 선택
  * **중복 허용** (같은 수를 여러 번 선택 가능)
  * **사전 순으로 출력**
* 제약 조건
  * `1 ≤ M ≤ N ≤ 7`
  * 최대 경우의 수: 7^7 = 823,543 (충분히 처리 가능)

이 문제는 **중복 순열 생성** 문제로, 다음과 같은 특성이 있다:

* 각 자리마다 **독립적으로** 1부터 N까지 선택 가능
* **방문 체크가 필요 없음** (중복 허용)
* **가지치기가 필요 없음** (모든 경로가 유효한 해)
* **사전 순 출력**이 자연스럽게 보장됨

➡️ 이러한 조건을 가장 직관적으로 만족하는 방법이 **백트래킹(재귀)** 이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 재귀 함수 구조

```java
static void backtrack(int depth) {
    // 종료 조건
    if (depth == M) {
        printResult();
        return;
    }
    
    // 선택지 탐색
    for (int i = 1; i <= N; i++) {
        result[depth] = i;
        backtrack(depth + 1);
    }
}
```

* 알고리즘 문서에서 설명한 **백트래킹 기본 템플릿**과 정확히 일치한다
* `depth == M`: 종료 조건 - M개의 자리를 모두 채웠을 때
* `for (int i = 1; i <= N; i++)`: 각 자리마다 1부터 N까지 모든 수를 선택
* `backtrack(depth + 1)`: 다음 자리로 재귀 호출

➡️ **상태 공간 트리를 깊이 우선으로 탐색**하는 구조가 코드에 그대로 반영되어 있다.

---

### ② 중복 허용의 구현

```java
for (int i = 1; i <= N; i++) {
    result[depth] = i;
    backtrack(depth + 1);
    // 선택 취소 불필요
}
```

* 알고리즘 문서에서 설명한 대로, **중복이 허용되므로 방문 체크가 필요 없다**
* 각 자리마다 **독립적으로** 1부터 N까지 선택 가능
* 선택 취소(Unmake Choice) 단계가 필요 없음

➡️ 이는 **중복 순열의 핵심 특징**이 코드에 직접 반영된 것이다.

---

### ③ 사전 순 출력 보장

```java
for (int i = 1; i <= N; i++) {
    result[depth] = i;
    backtrack(depth + 1);
}
```

* 각 자리에서 **1부터 N까지 순서대로** 선택함
* 이는 자연스럽게 **사전 순 정렬**을 보장한다
  * 첫 번째 자리가 작은 수열이 먼저 생성됨
  * 첫 번째 자리가 같으면 두 번째 자리가 작은 수열이 먼저 생성됨
  * 이는 사전 순 정렬과 정확히 일치함

➡️ 알고리즘 문서에서 설명한 **"사전 순 출력이 자연스럽게 되는 이유"**가 코드에 구현되어 있다.

---

## 3️⃣ 결과 저장 방식

### 배열 기반 저장

```java
int[] result = new int[M];
```

* 각 자리에 선택한 수를 저장하는 배열 사용
* 인덱스 `depth`에 현재 자리의 값을 저장
* 메모리 효율적이고 접근이 빠름

### 출력 방식

```java
if (depth == M) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < M; i++) {
        sb.append(result[i]);
        if (i < M - 1) sb.append(' ');
    }
    System.out.println(sb.toString());
    return;
}
```

* 완전한 해를 찾았을 때(`depth == M`) 결과를 출력
* `StringBuilder`를 사용하여 출력 최적화
* 공백으로 구분하여 출력

---

## 4️⃣ 재귀 호출의 의미

### 상태 공간 트리 탐색

재귀 호출 `backtrack(depth + 1)`은 다음과 같은 의미를 가진다:

1. **현재 자리에 값을 선택한 상태**에서
2. **다음 자리로 진행**하여
3. **상태 공간 트리의 다음 레벨을 탐색**

### 예시: N=3, M=2인 경우

```
backtrack(0) 호출
  ├─ result[0] = 1
  │   └─ backtrack(1) 호출
  │       ├─ result[1] = 1 → 출력: "1 1"
  │       ├─ result[1] = 2 → 출력: "1 2"
  │       └─ result[1] = 3 → 출력: "1 3"
  ├─ result[0] = 2
  │   └─ backtrack(1) 호출
  │       ├─ result[1] = 1 → 출력: "2 1"
  │       ├─ result[1] = 2 → 출력: "2 2"
  │       └─ result[1] = 3 → 출력: "2 3"
  └─ result[0] = 3
      └─ backtrack(1) 호출
          ├─ result[1] = 1 → 출력: "3 1"
          ├─ result[1] = 2 → 출력: "3 2"
          └─ result[1] = 3 → 출력: "3 3"
```

➡️ 이는 알고리즘 문서에서 설명한 **상태 공간 트리**를 그대로 탐색하는 과정이다.

---

## 5️⃣ 시간 복잡도와 코드의 대응

### 상태 공간 크기

* 각 자리마다 N개의 선택지
* M개의 자리
* 총 경우의 수: **N^M**

### 재귀 호출 횟수

* 각 노드에서 N개의 자식 노드 생성
* 깊이 M까지 탐색
* 총 노드 수: 1 + N + N^2 + ... + N^M = (N^(M+1) - 1) / (N - 1)
* 하지만 실제로는 리프 노드만 출력하므로, **O(N^M)** 시간 복잡도

### 코드에서의 대응

```java
for (int i = 1; i <= N; i++) {  // N번 반복
    result[depth] = i;
    backtrack(depth + 1);        // 깊이 M까지
}
```

* 외부 루프: N번 반복
* 재귀 깊이: M
* 전체 시간 복잡도: **O(N^M)**

---

## 6️⃣ 공간 복잡도 분석

### 재귀 호출 스택

* 최대 재귀 깊이: M
* 각 재귀 호출마다 스택 프레임 생성
* 스택 공간: **O(M)**

### 결과 저장

* `result` 배열: 크기 M
* 공간: **O(M)**

### 전체 공간 복잡도

* **O(M)** - 재귀 스택과 결과 배열 모두 M에 비례

---

## 7️⃣ 다른 접근 방법과의 비교

### 방법 1: 백트래킹 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 메모리 효율적 (O(M))
* 사전 순 출력이 자연스럽게 보장됨

**단점:**
* 재귀 호출로 인한 스택 오버플로우 가능성 (하지만 M ≤ 7이므로 문제 없음)

### 방법 2: 반복문 중첩

```java
for (int i1 = 1; i1 <= N; i1++) {
    for (int i2 = 1; i2 <= N; i2++) {
        // ... M번 중첩
    }
}
```

**단점:**
* M이 변수이므로 반복문 중첩이 불가능
* 동적 중첩이 필요하므로 결국 재귀와 유사한 구조 필요

### 방법 3: 비트마스크

**단점:**
* 중복 순열에는 적합하지 않음
* 비트마스크는 중복을 허용하지 않는 조합/순열에 적합

➡️ **백트래킹이 이 문제에 가장 적합한 방법이다.**

---

## 8️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **출력 최적화**: StringBuilder 사용

### 추가 최적화 가능성

* 출력 버퍼링: 모든 결과를 메모리에 저장 후 한 번에 출력 (하지만 메모리 사용량 증가)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **중복 순열 구조**를 백트래킹으로 모델링하고
* 알고리즘 문서에서 설명한 **상태 공간 트리 탐색**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응

