# Main.java 설계 근거 정리

이 문서는 **BOJ 2252 줄 세우기 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **위상 정렬 개념, UML, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: Kahn 알고리즘

### 문제 특성과의 적합성

* 입력 크기

  * 정점(N): 최대 32,000
  * 간선(M): 최대 100,000
* 출력 조건

  * 가능한 정답이 여러 개
  * 임의의 올바른 순서 허용

이 문제는 **부분 순서(partial order)** 가 주어졌을 때 이를 만족하는 **전체 순서(total order)** 를 구하는 문제이다.

따라서 다음 조건을 만족하는 알고리즘이 필요하다:

* `O(N + M)` 시간 복잡도
* 여러 정답을 자연스럽게 허용
* 대규모 입력에서 안정적으로 동작

➡️ 이러한 조건을 가장 직관적으로 만족하는 방법이 **Kahn 알고리즘(진입 차수 기반 위상 정렬)** 이다.

---

## 2️⃣ 코드 구조와 UML 논의의 1:1 대응

### ① 선행 조건이 없는 정점부터 시작

```java
for (int i = 1; i <= N; i++) {
    if (indegree[i] == 0) {
        queue.offer(i);
    }
}
```

* UML에서 설명한 것처럼

  * `indegree == 0` 은 **아직 아무 제약도 받지 않는 상태**를 의미한다
* 이러한 정점들은

  * "지금 바로 줄에 세울 수 있는 학생" 이므로 Queue에 삽입된다

➡️ **Queue = 현재 배치 가능한 정점 집합** 이라는 해석이 코드에 그대로 반영되어 있다.

---

### ② 정점 배치 → 제약 해제 반복

```java
int current = queue.poll();
result.append(current).append(' ');

for (int next : graph[current]) {
    indegree[next]--;
    if (indegree[next] == 0) {
        queue.offer(next);
    }
}
```

* `poll()` 은

  * 현재 시점에서 가장 먼저 배치할 수 있는 정점을 확정하는 행위
* 이후 수행되는 `indegree[next]--` 는

  * UML에서 표현한 **간선 제거 = 제약 해제** 에 해당한다
* 모든 제약이 제거된 순간

  * 해당 정점이 다시 Queue에 들어간다

➡️ 이 로직은 UML 시퀀스 다이어그램에서 설명한
➡️ **"정점을 하나 확정할 때마다 그래프가 축소되는 과정"** 을 정확히 구현한다.

---

## 3️⃣ Queue 사용의 의미

```java
Queue<Integer> queue = new ArrayDeque<>();
```

* `offer` : 큐에 정점 추가 (배치 가능 상태 진입)
* `poll`  : 큐에서 정점 제거 (배치 확정)

Stack이 아닌 Queue를 사용하는 이유는 다음과 같다:

* Kahn 알고리즘은

  * **"지금 가능한 정점들"** 중 어떤 것을 먼저 선택해도 무방
* FIFO 구조는

  * 알고리즘의 의도를 해치지 않으면서
  * 구현을 단순하게 유지한다

➡️ 문제에서 정답이 여러 개 허용되므로, Queue 선택은 합리적이다.

---

## 4️⃣ DFS를 사용하지 않은 이유

DFS 기반 위상 정렬도 이론적으로는 가능하지만, 본 문제에서는 다음과 같은 이유로 채택하지 않았다.

* 재귀 호출로 인한 스택 깊이 문제 가능성
* DFS는

  * "가장 뒤에 올 정점부터 확정"하는 방식으로
  * 문제 직관(앞에서부터 줄 세우기)과 거리감이 있음

➡️ **Kahn 알고리즘이 문제의 도메인 의미와 더 자연스럽게 맞는다.**

---

## 5️⃣ 시간 복잡도와 코드의 대응

### 그래프 구성

* 정점 초기화: `O(N)`
* 간선 입력 처리: `O(M)`

➡️ 전체 그래프 구성 비용은 `O(N + M)`

---

### 위상 정렬 수행

* 각 정점은

  * 최대 한 번 Queue에 들어가고
  * 한 번 결과에 추가된다 → `O(N)`
* 각 간선은

  * 정확히 한 번만 처리된다 → `O(M)`

➡️ 위상 정렬 수행 비용 역시 `O(N + M)`

---

## 6️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **부분 순서 구조**를 그래프로 모델링하고
* UML로 설명한 **제약 제거 흐름**을 그대로 구현하며
* 대규모 입력에서도 안정적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → UML → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.
