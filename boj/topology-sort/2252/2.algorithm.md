# 위상 정렬(Topological Sort) 정리

## 1️⃣ 위상 정렬이란?

**위상 정렬(Topological Sort)** 이란

> **방향 그래프(Directional Graph)** 에서
> 모든 간선의 방향을 거스르지 않도록 정점을 나열하는 것
> 을 의미한다.

즉, `A → B` 라는 간선이 있다면 **반드시 A가 B보다 앞에 위치**해야 한다.

---

## 2️⃣ 언제 사용할까?

위상 정렬은 다음과 같은 상황에서 사용된다:

* 선후 관계가 존재하는 작업 순서 결정
* 일부 비교 정보만 주어진 상태에서 전체 순서 복원
* 의존성 그래프 처리

### 대표적인 예시

* 과목 선수 과목 관계
* 빌드 시스템의 컴파일 순서
* 작업 스케줄링
* **줄 세우기 문제 (키 비교 결과)**

---

## 3️⃣ 위상 정렬이 가능한 조건

위상 정렬은 **사이클이 없는 방향 그래프(DAG)** 에서만 가능하다.

* 사이클이 존재하면

  * `A → B → C → A` 처럼
  * 누가 먼저인지 결정 불가능
* 따라서 **DAG (Directed Acyclic Graph)** 가 전제 조건

---

## 4️⃣ 그래프 모델링 방법

### 📌 최대한 간소화된 문제 상황

학생이 3명 있고, 다음과 같은 비교 결과만 알고 있다고 가정한다.

* `1 → 3` : 1번 학생은 3번 학생보다 앞
* `2 → 3` : 2번 학생은 3번 학생보다 앞

가능한 줄 세우기 결과:

```
1 2 3
2 1 3
```

즉, **3번 학생은 반드시 마지막**이지만, 1번과 2번의 상대적 순서는 정해지지 않았다.
이처럼 일부 관계만 주어진 상태를 **부분 순서(partial order)** 라고 한다.

---

### 📐 그래프 + UML 관점에서의 모델링

* 학생 → 정점(Vertex)
* `A가 B보다 앞` → 방향 간선 `A → B`

이를 UML 관계로 표현하면 다음과 같다.

```mermaid
classDiagram
    Student1 --> Student3 : before
    Student2 --> Student3 : before
```

이 다이어그램이 의미하는 바는 다음과 같다.

* `Student1`, `Student2`는 서로 독립
* `Student3`은 반드시 두 학생 이후에 배치되어야 함

➡️ 이 관계를 **모두 만족하는 정점 나열**이 바로 위상 정렬 결과이다.

---

### 📐 그래프 모델링

* 학생 → 정점(Vertex)
* `A가 B보다 앞` → 방향 간선 `A → B`

위 예시는 다음과 같은 그래프가 된다.

```
1 ─▶ 3
2 ─▶ 3
```

이 그래프에서 **모든 간선 방향을 만족하는 정점 나열**이 곧 위상 정렬 결과이다.

---

줄 세우기 문제 기준으로:

* 학생 → 정점(Vertex)
* `A가 B보다 앞` → 방향 간선 `A → B`

이렇게 모델링하면,

> 모든 간선을 만족하는 정점 나열 = 위상 정렬 결과

---

## 5️⃣ 위상 정렬의 해결 방법 개요

위상 정렬을 수행하는 대표적인 방법은 크게 두 가지가 있다.

* **진입 차수(In-degree)를 이용하는 방법 (Kahn 알고리즘)**
* **DFS 탐색 순서를 이용하는 방법 (DFS 기반 위상 정렬)**

두 방법 모두 DAG에서 올바른 위상 정렬 결과를 보장하지만, **문제 성격과 구현 관점**에서 차이가 있다.

---

### ✅ 방법 1: Kahn 알고리즘 (진입 차수 기반)

#### 핵심 아이디어

* 각 정점은 자신보다 **앞에 와야 할 정점의 개수**를 진입 차수로 가진다
* 진입 차수가 0이라는 것은
  → **아무 제약 없이 지금 바로 배치할 수 있는 상태**임을 의미한다

즉, 이 알고리즘은

> "현재 시점에서 실행 가능한 정점 집합을 반복적으로 선택"하는 방식이다.

---

### ✨ 최소 Java 코드 스니펫 (핵심 로직만)

```java
Queue<Integer> queue = new ArrayDeque<>(); // offer: 큐에 데이터 추가, poll: 큐에서 데이터 꺼내기
List<Integer> result = new ArrayList<>();

// 1. 선행 조건이 없는 정점부터 시작
for (int i = 1; i <= N; i++) {
    if (indegree[i] == 0) {
        queue.offer(i);
    }
}

// 2. 정점 배치 → 제약 해제 반복
while (!queue.isEmpty()) {
    int current = queue.poll();
    result.add(current);

    for (int next : graph[current]) {
        indegree[next]--;          // 제약 하나 제거
        if (indegree[next] == 0) { // 모든 제약 해제
            queue.offer(next);
        }
    }
}
```

이 코드의 의미는 다음과 같다.

* Queue에는 항상 **"지금 줄에 세울 수 있는 정점"** 만 존재한다
* 한 정점을 결과에 추가하는 행위는
  → 그 정점이 갖고 있던 **후행 제약을 해제**하는 것이다
* 여러 정점이 동시에 queue에 들어갈 수 있으므로 결과는 여러 개가 될 수 있다

---

### 📊 UML 시퀀스 관점에서 본 Kahn 알고리즘

Kahn 알고리즘의 흐름은 크게 두 단계로 나누어 이해하면 직관적이다.

---

#### ① 선행 조건이 없는 정점부터 시작

```mermaid
sequenceDiagram
    participant Q as Queue
    participant S1 as Student(1)
    participant S2 as Student(2)

    Note over Q: indegree == 0 인 정점 탐색
    Q->>S1: offer(1)
    Q->>S2: offer(2)
```

설명:

* 진입 차수가 0인 정점은
  → **아직 아무 제약도 받지 않는 상태**
* 이 정점들은
  → 지금 바로 줄에 세울 수 있으므로 Queue에 들어간다

---

#### ② 정점 배치 → 제약 해제 반복

```mermaid
sequenceDiagram
    participant Q as Queue
    participant S1 as Student(1)
    participant S2 as Student(2)
    participant S3 as Student(3)

    Q->>S1: poll()
    Note over S1: 결과에 추가

    S1->>S3: indegree-- (간선 1→3 제거)
    S2->>S3: indegree-- (간선 2→3 제거)

    Note over S3: indegree == 0
    Q->>S3: offer(3)
```

설명:

* Queue에서 하나를 꺼내 결과에 배치하면
  → 해당 정점에서 나가던 **모든 간선이 제거**된다
* 간선이 제거되며
  → 후행 정점의 선행 조건이 하나씩 해제된다
* 모든 선행 조건이 사라진 순간
  → 해당 정점이 다시 Queue에 들어간다

---

### ✅ 방법 2: DFS 기반 위상 정렬

#### 핵심 아이디어

DFS 기반 방법은 관점이 다르다.

* 어떤 정점이 결과에 들어가기 위해서는
  → **그 정점에서 출발하는 모든 경로가 먼저 처리**되어야 한다
* 따라서 DFS 탐색 중
  → 더 이상 갈 곳이 없을 때 해당 정점을 결과에 추가한다

즉,

> "가장 뒤에 와야 할 정점부터 확정"하는 방식이다.

---

### ✨ 최소 Java 코드 스니펫 (DFS 기반 핵심 로직)

아래 코드는 **DFS 기반 위상 정렬의 핵심 아이디어만 담은 최소 예제**이다.

```java
List<Integer> result = new ArrayList<>();
boolean[] visited = new boolean[N + 1];

void dfs(int current) {
    visited[current] = true;

    for (int next : graph[current]) {
        if (!visited[next]) {
            dfs(next);
        }
    }

    // 모든 후행 정점 처리 후 결과에 추가
    result.add(current);
}

// 모든 정점에 대해 DFS 수행
for (int i = 1; i <= N; i++) {
    if (!visited[i]) {
        dfs(i);
    }
}

// 결과를 뒤집으면 위상 정렬 순서
Collections.reverse(result);
```

이 코드의 의미는 다음과 같다.

* 한 정점은 **자신 이후에 와야 할 모든 정점이 먼저 처리된 뒤** 결과에 추가된다
* 따라서 `result`에는
  → "뒤에 와야 할 정점부터" 쌓이게 된다
* 마지막에 결과를 뒤집으면 위상 정렬 순서가 된다

---

### 📊 UML 시퀀스 관점에서 본 DFS 기반 위상 정렬

DFS 기반 위상 정렬에서는 **어떤 간선이 언제 처리되는지**를 함께 보는 것이 중요하다.

아래 예시는 간선 `1→3`, `2→3` 이 존재하는 경우를 나타낸다.

```mermaid
sequenceDiagram
    participant DFS as DFS Call Stack
    participant S1 as Student(1)
    participant S2 as Student(2)
    participant S3 as Student(3)

    DFS->>S1: dfs(1)
    Note over S1: 간선 1→3 따라 이동
    S1->>S3: dfs(3)

    Note over S3: 더 이상 나가는 간선 없음
    S3-->>DFS: add to result
    Note over S3: 간선 1→3 처리 완료

    DFS->>S2: dfs(2)
    Note over S2: 간선 2→3 확인
    Note over S2: 3은 이미 처리됨

    S2-->>DFS: add to result
    Note over S2: 간선 2→3 처리 완료

    S1-->>DFS: add to result
```

설명:

* DFS는 간선을 따라 **끝까지 내려간 뒤** 되돌아온다
* `Student(3)`은 두 간선 `1→3`, `2→3`이 모두 처리된 뒤 가장 먼저 결과에 추가된다
* 이후 `Student(1)`, `Student(2)`는
  → 자신이 가진 모든 간선이 처리된 것이 확인된 뒤 결과에 추가된다
* 따라서 결과 리스트는 **뒤에 와야 할 정점부터 쌓이고**, 마지막에 역순으로 정렬된다

---

#### 개념적 흐름

1. 방문하지 않은 정점에서 DFS 시작
2. 인접 정점을 먼저 DFS로 방문
3. 더 이상 갈 곳이 없으면 스택에 push
4. 모든 DFS 종료 후 스택을 뒤에서부터 출력

---

#### 특징 및 주의점

* 재귀 또는 명시적 스택 사용 필요
* 방문 상태(미방문 / 방문 중 / 방문 완료)를 통해
  → **사이클 검출이 자연스럽게 가능**
* 구현 난이도는 Kahn 알고리즘보다 다소 높음

---

| 구분     | Kahn 알고리즘 | DFS 방식            |
| ------ | --------- | ----------------- |
| 핵심 개념  | 진입 차수     | 탐색 완료 순서          |
| 자료구조   | Queue     | Stack / Recursion |
| 사이클 검출 | 결과 개수로 판단 | 방문 상태로 판단         |
| 구현 난이도 | 쉬움        | 상대적으로 복잡          |
| 실전 사용  | ⭐⭐⭐⭐      | ⭐⭐                |

➡️ **BOJ 줄 세우기 문제는 Kahn 알고리즘이 가장 적합**

---

## 7️⃣ 시간 복잡도

위상 정렬의 시간 복잡도는 **그래프 구성 단계**와 **정렬 수행 단계**로 나누어 이해하는 것이 자연스럽다.

---

### ⏱️ 그래프 구성 단계: `O(N + M)`

* 모든 학생(정점)을 한 번씩 초기화한다 → `O(N)`
* 입력으로 주어지는 비교 관계 `M`개에 대해

  * 인접 리스트에 간선을 추가하고
  * 진입 차수를 증가시킨다 → `O(M)`

따라서 그래프를 구성하는 전체 비용은 `O(N + M)` 이다.

---

### ⏱️ 위상 정렬 수행 단계: `O(N + M)`

* 각 정점은

  * 최대 한 번 queue(또는 스택)에 들어가고
  * 한 번 결과에 추가된다 → `O(N)`
* 각 간선은

  * 정확히 한 번만 제거(또는 검사)된다 → `O(M)`

즉, 불필요한 반복이나 중복 탐색 없이

> **정점과 간선을 각각 한 번씩만 처리**한다.

---

### ✅ 전체 시간 복잡도

```
O(N + M)
```

이는 입력 크기가 큰 줄 세우기 문제에서도
안정적으로 동작하는 이유이다.

---

## 8️⃣ 줄 세우기 문제와의 연결

* 학생 수 최대 32,000
* 비교 횟수 최대 100,000
* 일부 순서만 주어짐

➡️ UML로 보았듯이, 이 문제는
➡️ **부분 순서를 관계 그래프로 표현하고**
➡️ **제약을 하나씩 제거하며 전체 순서를 구성하는 위상 정렬 문제**이다.

* 학생 수 최대 32,000
* 비교 횟수 최대 100,000
* 일부 순서만 주어짐

➡️ **부분 순서를 만족하는 전체 순서를 구하는 문제**
➡️ 위상 정렬의 전형적인 활용 사례

---

## ✨ 한 줄 요약

> 위상 정렬은 **"선후 관계가 있는 대상들을 조건을 지키며 나열하는 알고리즘"** 이며, 줄 세우기 문제는 이를 그대로 적용하는 DAG 위상 정렬 문제이다.
