# Main.java 설계 근거 정리

이 문서는 **BOJ 11279 최대 힙 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **힙 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 최대 힙

### 문제 특성과의 적합성

* 문제 요구사항
  * 자연수 x를 배열에 추가
  * 배열에서 가장 큰 값을 출력하고 제거
  * 빈 배열일 때는 0 출력
* 제약 조건
  * `1 ≤ N ≤ 100,000` (최대 100,000번의 연산)
  * 입력되는 자연수는 2^31보다 작음

이 문제는 **최대 힙 자료구조**를 직접 구현하거나 활용하는 문제로, 다음과 같은 특성이 있다:

* **최댓값 빠른 접근**: O(1) - 루트 노드가 항상 최댓값
* **효율적인 삽입/삭제**: O(log N) - 힙의 높이만큼만 연산
* **빈 힙 처리**: `isEmpty()` 체크 필요

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **최대 힙(Max Heap)** 이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① PriorityQueue를 최대 힙으로 사용

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
```

* 알고리즘 문서에서 설명한 대로, **Java의 PriorityQueue는 기본적으로 최소 힙**이다
* 최대 힙을 만들기 위해 **`Comparator.reverseOrder()`를 사용**하여 역순 정렬
* 이는 알고리즘 문서의 **"최대 힙 vs 최소 힙"** 섹션과 정확히 일치한다

➡️ **최대 힙 구현 방법**이 코드에 직접 반영된 것이다.

---

### ② push 연산 구현

```java
if (x > 0) {
    maxHeap.offer(x);
}
```

* 자연수 x가 입력되면 `offer(x)` 메서드로 힙에 추가
* `PriorityQueue.offer()`는 내부적으로 **Up-Heap 연산**을 수행
  * 새 원소를 맨 끝에 추가
  * 부모 노드와 비교하여 위로 올리기
  * 힙 성질을 만족할 때까지 반복
* 시간 복잡도: **O(log N)**

➡️ 알고리즘 문서에서 설명한 **"Up-Heap (삽입 시)"** 과정이 `PriorityQueue` 내부에서 자동으로 수행된다.

---

### ③ pop 연산 구현

```java
else {
    if (maxHeap.isEmpty()) {
        System.out.println(0);
    } else {
        System.out.println(maxHeap.poll());
    }
}
```

* 0이 입력되면 `poll()` 메서드로 최댓값을 반환하고 제거
* `PriorityQueue.poll()`은 내부적으로 **Down-Heap 연산**을 수행
  * 루트 노드를 반환
  * 마지막 노드를 루트로 이동
  * 자식 노드와 비교하여 아래로 내리기
  * 힙 성질을 만족할 때까지 반복
* **빈 힙 처리**: `isEmpty()` 체크 후 0 출력
* 시간 복잡도: **O(log N)**

➡️ 알고리즘 문서에서 설명한 **"Down-Heap (삭제 시)"** 과정과 **"빈 힙 처리"**가 코드에 구현되어 있다.

---

## 3️⃣ 입력 처리 방식

### BufferedReader 사용

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
```

* 대량의 입력을 효율적으로 처리하기 위해 `BufferedReader` 사용
* `N ≤ 100,000`이므로 입력 최적화가 중요

### StringBuilder 사용 (선택사항)

```java
StringBuilder answer = new StringBuilder();
// ... 연산 수행 ...
answer.append(result).append('\n');
System.out.print(answer.toString());
```

* 여러 번의 출력을 한 번에 처리하여 성능 향상
* 각 연산마다 `System.out.println()`을 호출하는 것보다 효율적

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 연산별 시간 복잡도

* **push 연산**: O(log N) - `offer()` 메서드
* **pop 연산**: O(log N) - `poll()` 메서드
* **전체 시간 복잡도**: O(N log N) - N번의 연산

### 코드에서의 대응

```java
for (int i = 0; i < N; i++) {  // N번 반복
    int x = Integer.parseInt(br.readLine());
    
    if (x > 0) {
        maxHeap.offer(x);      // O(log N)
    } else {
        if (maxHeap.isEmpty()) {
            System.out.println(0);  // O(1)
        } else {
            System.out.println(maxHeap.poll());  // O(log N)
        }
    }
}
```

* 외부 루프: N번 반복
* 각 반복마다 O(log N) 연산 수행
* 전체 시간 복잡도: **O(N log N)**

➡️ 알고리즘 문서에서 설명한 **"시간 복잡도 분석"**이 코드의 실제 동작과 일치한다.

---

## 5️⃣ 공간 복잡도 분석

### 힙 저장 공간

* `PriorityQueue` 내부 배열: 최대 N개의 원소 저장
* 공간: **O(N)**

### 전체 공간 복잡도

* **O(N)** - 힙에 저장할 수 있는 최대 원소 개수에 비례

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: PriorityQueue 사용 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* Java 표준 라이브러리 활용
* 내부적으로 최적화된 힙 구현 사용
* 코드가 간결함

**단점:**
* 없음 (이 문제에서는 최적의 방법)

### 방법 2: 배열 기반 직접 구현

```java
class MaxHeap {
    private List<Integer> heap;
    // ... push, pop, downHeap, upHeap 구현 ...
}
```

**장점:**
* 힙의 동작 원리를 직접 학습할 수 있음
* 커스터마이징 가능

**단점:**
* 구현이 복잡함
* 버그 발생 가능성
* 성능상 이점 없음 (PriorityQueue가 이미 최적화됨)

### 방법 3: 정렬된 리스트 사용

**단점:**
* 삽입 시 O(N) 시간 소요 (정렬 유지)
* 전체 시간 복잡도: O(N²)
* 비효율적

➡️ **PriorityQueue를 사용하는 것이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N log N) 시간 복잡도로 문제 제약 조건 내에서 충분히 빠름
* **표준 라이브러리 활용**: 검증된 구현 사용

### 추가 최적화 가능성

* **StringBuilder 사용**: 여러 출력을 한 번에 처리 (이미 적용 가능)
* **직접 힙 구현**: 특수한 경우에만 필요 (일반적으로 불필요)

현재 구현이 문제 제약 조건 내에서 충분히 효율적이다.

---

## 8️⃣ 빈 힙 처리의 중요성

### 문제 요구사항

> 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.

### 코드 구현

```java
if (maxHeap.isEmpty()) {
    System.out.println(0);
} else {
    System.out.println(maxHeap.poll());
}
```

* `PriorityQueue.poll()`은 빈 큐에서 호출 시 `null`을 반환
* 하지만 문제 요구사항은 **0을 출력**해야 함
* 따라서 **`isEmpty()` 체크가 필수적**이다

➡️ 알고리즘 문서에서 설명한 **"빈 힙 처리"**가 코드에 명확히 구현되어 있다.

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **최대 힙 구조**를 PriorityQueue로 모델링하고
* 알고리즘 문서에서 설명한 **힙 연산 (push, pop)**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **단순성**: 복잡한 직접 구현 없이 표준 라이브러리 활용
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(N log N))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **안전성**: 빈 힙 처리 등 엣지 케이스 고려

