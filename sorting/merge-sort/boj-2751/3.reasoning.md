# Main.java 설계 근거 정리

이 문서는 **BOJ 2751 수 정렬하기 2 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **병합 정렬 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 병합 정렬

### 문제 특성과의 적합성

* 문제 요구사항
  * N개의 수를 오름차순으로 정렬
  * N은 최대 1,000,000
  * 각 수는 절댓값이 1,000,000보다 작거나 같은 정수
* 제약 조건
  * `1 ≤ N ≤ 1,000,000`
  * 시간 제한이 있어 O(N²) 알고리즘은 시간 초과

이 문제는 **대량의 데이터를 정렬**하는 문제로, 다음과 같은 특성이 있다:

* **대량 데이터**: 최대 1,000,000개의 수를 정렬해야 함
* **시간 제한**: O(N²) 알고리즘은 시간 초과
* **필요한 알고리즘**: O(N log N) 정렬 알고리즘
* **최악의 경우 성능**: 병합 정렬은 최악의 경우에도 O(N log N) 보장

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **병합 정렬(Merge Sort)** 이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 분할정복의 3단계 프로세스

```java
void mergeSort(int[] arr, int left, int right) {
    // Base Case: 더 이상 나눌 수 없는 경우
    if (left >= right) return;
    
    // Divide: 배열을 반으로 나눔
    int mid = (left + right) / 2;
    
    // Conquer: 각 부분을 재귀적으로 정렬
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    
    // Combine: 정렬된 두 부분을 병합
    merge(arr, left, mid, right);
}
```

* 알고리즘 문서에서 설명한 **분할정복의 3단계 프로세스**가 코드에 정확히 반영되어 있다
* **Divide**: `mid = (left + right) / 2`로 배열을 반으로 나눔
* **Conquer**: `mergeSort(arr, left, mid)`, `mergeSort(arr, mid + 1, right)`로 각 부분을 재귀적으로 정렬
* **Combine**: `merge(arr, left, mid, right)`로 정렬된 두 부분을 병합

➡️ **분할정복 알고리즘의 기본 구조**가 코드에 그대로 구현되어 있다.

---

### ② 병합(Merge) 함수 구현

```java
void merge(int[] arr, int left, int mid, int right) {
    // 임시 배열 생성
    int[] temp = new int[right - left + 1];
    int i = left;      // 왼쪽 부분의 시작 인덱스
    int j = mid + 1;   // 오른쪽 부분의 시작 인덱스
    int k = 0;         // 임시 배열의 인덱스
    
    // 두 부분을 비교하며 병합
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // 남은 요소들 복사
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    
    // 임시 배열의 내용을 원본 배열로 복사
    for (i = left, k = 0; i <= right; i++, k++) {
        arr[i] = temp[k];
    }
}
```

* 알고리즘 문서에서 설명한 **병합 함수의 구조**와 정확히 일치한다
* **두 부분 비교**: `while (i <= mid && j <= right)`로 두 부분을 비교하며 병합
* **남은 요소 복사**: 한쪽 부분이 먼저 끝나면 나머지 요소를 복사
* **원본 배열로 복사**: 임시 배열의 내용을 원본 배열로 복사

➡️ 알고리즘 문서에서 설명한 **"병합(Merge) 함수"**가 코드에 구현되어 있다.

---

### ③ Base Case 처리

```java
if (left >= right) return;
```

* **Base Case**: 더 이상 나눌 수 없는 경우 (원소가 1개 이하)
* `left >= right`일 때 재귀 종료
* 이는 알고리즘 문서에서 설명한 **"Base Case: 더 이상 나눌 수 없는 경우"**와 일치한다

---

## 3️⃣ 시간 복잡도와 코드의 대응

### 분할 단계

* 배열을 반으로 나누는 과정이 `log N`번 반복
* 각 단계에서 O(1) 시간 소요
* **시간 복잡도: O(log N)**

### 병합 단계

* 각 레벨에서 전체 배열을 한 번씩 순회: O(N)
* 레벨의 개수: O(log N)
* **시간 복잡도: O(N log N)**

### 전체 시간 복잡도

* **O(N log N)** - 모든 경우(최선, 평균, 최악)에 동일

### 코드에서의 대응

```java
void mergeSort(int[] arr, int left, int right) {
    if (left >= right) return;  // O(1)
    
    int mid = (left + right) / 2;  // O(1)
    
    mergeSort(arr, left, mid);      // T(N/2)
    mergeSort(arr, mid + 1, right);  // T(N/2)
    
    merge(arr, left, mid, right);   // O(N)
}
```

* 재귀 호출: T(N) = 2T(N/2) + O(N)
* 마스터 정리에 의해: T(N) = O(N log N)

➡️ 알고리즘 문서에서 설명한 **"시간 복잡도 분석"**이 코드의 실제 동작과 일치한다.

---

## 4️⃣ 공간 복잡도 분석

### 재귀 호출 스택

* 최대 재귀 깊이: `log N`
* 각 재귀 호출마다 스택 프레임 생성
* **공간: O(log N)**

### 임시 배열

* 병합 과정에서 사용하는 임시 배열
* 최대 크기: N
* **공간: O(N)**

### 전체 공간 복잡도

* **O(N)** - 임시 배열이 지배적

---

## 5️⃣ 다른 접근 방법과의 비교

### 방법 1: 병합 정렬 (현재 방법) ✅

**장점:**
* 최악의 경우에도 O(N log N) 보장
* 안정 정렬 (같은 값의 상대적 순서 유지)
* 일관된 성능

**단점:**
* 추가 메모리 필요 (O(N))
* 구현이 상대적으로 복잡

### 방법 2: 퀵 정렬

**단점:**
* 최악의 경우 O(N²) 시간 소요
* 이 문제에서는 최악의 경우가 발생할 수 있음
* 불안정 정렬

### 방법 3: 힙 정렬

**단점:**
* 구현이 복잡
* 불안정 정렬
* 캐시 효율이 떨어짐

### 방법 4: Arrays.sort() (Java 라이브러리)

**장점:**
* 구현이 간단
* 최적화된 정렬 알고리즘 사용

**단점:**
* 이 문제는 병합 정렬을 직접 구현하는 학습 목적
* 내부 구현을 이해하지 못함

➡️ **병합 정렬이 이 문제에 가장 적합한 방법이다.**

---

## 6️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N log N) 시간 복잡도로 문제 제약 조건 내에서 충분히 빠름
* **안정 정렬**: 같은 값의 상대적 순서 유지

### 추가 최적화 가능성

* **작은 배열에 대한 삽입 정렬**: 작은 배열(N < 10)에 대해서는 삽입 정렬 사용 (하지만 이 문제에서는 불필요)
* **임시 배열 재사용**: 매번 새로 생성하지 않고 재사용 (메모리 최적화)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적이다.

---

## 7️⃣ 출력 최적화

### StringBuilder 사용

```java
StringBuilder answer = new StringBuilder();
for (int i = 0; i < N; i++) {
    answer.append(arr[i]).append('\n');
}
System.out.print(answer.toString());
```

* 여러 번의 출력을 한 번에 처리하여 성능 향상
* 각 수마다 `System.out.println()`을 호출하는 것보다 효율적

---

## 8️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **대량 데이터 정렬 구조**를 병합 정렬로 모델링하고
* 알고리즘 문서에서 설명한 **분할정복의 3단계 프로세스**를 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 9️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(N log N))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **안정성**: 안정 정렬로 같은 값의 상대적 순서 유지

