# ì•Œê³ ë¦¬ì¦˜: ë³‘í•© ì •ë ¬ (Merge Sort)

> ğŸ“– **ì „ì²´ ì•Œê³ ë¦¬ì¦˜ ì„¤ëª…**: [ë³‘í•© ì •ë ¬(Merge Sort) ì •ë¦¬](../merge-sort.md)

ì´ ë¬¸ì œëŠ” **ë³‘í•© ì •ë ¬(Merge Sort)** ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ í•´ê²°í•©ë‹ˆë‹¤.  
ìƒìœ„ í´ë”ì˜ [ë³‘í•© ì •ë ¬ ì •ë¦¬ ë¬¸ì„œ](../merge-sort.md)ì—ì„œ ì•Œê³ ë¦¬ì¦˜ì˜ ì „ì²´ ì´ë¡ ê³¼ ê°œë…ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ì´ ë¬¸ì œì—ì„œì˜ ë³‘í•© ì •ë ¬ ì ìš©

### ë¬¸ì œ íŠ¹ì„±

* **ëŒ€ëŸ‰ ë°ì´í„° ì •ë ¬**: ìµœëŒ€ 1,000,000ê°œì˜ ìˆ˜ë¥¼ ì •ë ¬
* **ì‹œê°„ ì œí•œ**: O(NÂ²) ì•Œê³ ë¦¬ì¦˜ì€ ì‹œê°„ ì´ˆê³¼
* **í•„ìš”í•œ ì•Œê³ ë¦¬ì¦˜**: O(N log N) ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
* **ì œì•½ ì¡°ê±´**: `1 â‰¤ N â‰¤ 1,000,000`

---

## ì´ ë¬¸ì œì˜ íŠ¹ì´ì‚¬í•­

### 1ï¸âƒ£ ë³‘í•© ì •ë ¬ì˜ ì¥ì  í™œìš©

ì´ ë¬¸ì œì—ì„œ ë³‘í•© ì •ë ¬ì„ ì„ íƒí•œ ì´ìœ :

* **ìµœì•…ì˜ ê²½ìš°ì—ë„ O(N log N)**: ì¼ê´€ëœ ì„±ëŠ¥ ë³´ì¥
* **ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬**: 1,000,000ê°œì˜ ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì •ë ¬
* **ì•ˆì • ì •ë ¬**: ê°™ì€ ê°’ì˜ ìƒëŒ€ì  ìˆœì„œ ìœ ì§€ (ì´ ë¬¸ì œì—ì„œëŠ” ì¤‘ë³µì´ ì—†ì§€ë§Œ)

### 2ï¸âƒ£ ë¶„í• ì •ë³µì˜ 3ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤

ë³‘í•© ì •ë ¬ì€ ë¶„í• ì •ë³µì˜ ì „í˜•ì ì¸ ì˜ˆì‹œë¡œ ë‹¤ìŒ 3ë‹¨ê³„ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

1. **Divide (ë¶„í• )**: ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆˆë‹¤
2. **Conquer (ì •ë³µ)**: ê° ë¶€ë¶„ì„ ì¬ê·€ì ìœ¼ë¡œ ì •ë ¬í•œë‹¤
3. **Combine (ë³‘í•©)**: ì •ë ¬ëœ ë‘ ë¶€ë¶„ì„ ë³‘í•©í•œë‹¤

### 3ï¸âƒ£ ì‹œê°„ ë³µì¡ë„

* **ë¶„í•  ë‹¨ê³„**: O(log N) - ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê³¼ì •ì´ log Në²ˆ ë°˜ë³µ
* **ë³‘í•© ë‹¨ê³„**: O(N log N) - ê° ë ˆë²¨ì—ì„œ ì „ì²´ ë°°ì—´ì„ í•œ ë²ˆì”© ìˆœíšŒ
* **ì „ì²´ ì‹œê°„ ë³µì¡ë„**: **O(N log N)**

ì œì•½ ì¡°ê±´ `N â‰¤ 1,000,000`ìœ¼ë¡œ ì¸í•´ O(N log N) ì‹œê°„ ë³µì¡ë„ë¡œ ì¶©ë¶„íˆ ì²˜ë¦¬ ê°€ëŠ¥í•©ë‹ˆë‹¤.

### 4ï¸âƒ£ ê³µê°„ ë³µì¡ë„

* **ì¬ê·€ í˜¸ì¶œ ìŠ¤íƒ**: O(log N) - ìµœëŒ€ ì¬ê·€ ê¹Šì´
* **ì„ì‹œ ë°°ì—´**: O(N) - ë³‘í•© ê³¼ì •ì—ì„œ ì‚¬ìš©
* **ì „ì²´ ê³µê°„ ë³µì¡ë„**: **O(N)**

---

## í•µì‹¬ êµ¬í˜„ íŒ¨í„´

ì´ ë¬¸ì œì— íŠ¹í™”ëœ ë³‘í•© ì •ë ¬ êµ¬í˜„:

```java
void mergeSort(int[] arr, int left, int right) {
    // Base Case: ë” ì´ìƒ ë‚˜ëˆŒ ìˆ˜ ì—†ëŠ” ê²½ìš°
    if (left >= right) return;
    
    // Divide: ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆ”
    int mid = (left + right) / 2;
    
    // Conquer: ê° ë¶€ë¶„ì„ ì¬ê·€ì ìœ¼ë¡œ ì •ë ¬
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    
    // Combine: ì •ë ¬ëœ ë‘ ë¶€ë¶„ì„ ë³‘í•©
    merge(arr, left, mid, right);
}

void merge(int[] arr, int left, int mid, int right) {
    // ì„ì‹œ ë°°ì—´ ìƒì„±
    int[] temp = new int[right - left + 1];
    int i = left;      // ì™¼ìª½ ë¶€ë¶„ì˜ ì‹œì‘ ì¸ë±ìŠ¤
    int j = mid + 1;   // ì˜¤ë¥¸ìª½ ë¶€ë¶„ì˜ ì‹œì‘ ì¸ë±ìŠ¤
    int k = 0;         // ì„ì‹œ ë°°ì—´ì˜ ì¸ë±ìŠ¤
    
    // ë‘ ë¶€ë¶„ì„ ë¹„êµí•˜ë©° ë³‘í•©
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    
    // ë‚¨ì€ ìš”ì†Œë“¤ ë³µì‚¬
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    
    // ì„ì‹œ ë°°ì—´ì˜ ë‚´ìš©ì„ ì›ë³¸ ë°°ì—´ë¡œ ë³µì‚¬
    for (i = left, k = 0; i <= right; i++, k++) {
        arr[i] = temp[k];
    }
}
```

---

## ë‹¤ë¥¸ ì •ë ¬ ë¬¸ì œì™€ì˜ ì°¨ì´ì 

| íŠ¹ì§• | ì¼ë°˜ ì •ë ¬ ë¬¸ì œ | ì´ ë¬¸ì œ (2751) |
|------|--------------|---------------|
| ë°ì´í„° í¬ê¸° | ì‘ìŒ (N â‰¤ 1,000) | í¼ (N â‰¤ 1,000,000) |
| ì•Œê³ ë¦¬ì¦˜ | O(NÂ²) ê°€ëŠ¥ | O(N log N) í•„ìˆ˜ |
| ìµœì•…ì˜ ê²½ìš° | ì¤‘ìš”í•˜ì§€ ì•ŠìŒ | ì¤‘ìš”í•¨ (ë³‘í•© ì •ë ¬ ì„ íƒ ì´ìœ ) |
| êµ¬í˜„ ë³µì¡ë„ | ë‚®ìŒ | ì¤‘ê°„ (ë³‘í•© í•¨ìˆ˜ êµ¬í˜„ í•„ìš”) |

---

## ì°¸ê³ 

* ì „ì²´ ë³‘í•© ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì„¤ëª…: [../merge-sort.md](../merge-sort.md)
* ë¬¸ì œ ë¶„ì„: [1.analysis.md](./1.analysis.md)
* ì•Œê³ ë¦¬ì¦˜ ì ìš© ê·¼ê±°: [3.reasoning.md](./3.reasoning.md)

