# 알고리즘: 정렬을 활용한 최근접 점 찾기

이 문제는 **정렬을 도구로 활용**하여 해결합니다.  
상위 폴더의 [정렬 알고리즘 정리 문서](../../sorting.md)에서 정렬 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 알고리즘 단계

### 1단계: 색깔별 그룹화

배열을 사용하여 색깔별로 위치를 저장합니다.

```java
List<Integer>[] colorLists = new ArrayList[N+1];
for (int i = 1; i <= N; i++) {
    colorLists[i] = new ArrayList<>();
}

// 입력 받기
for (int i = 0; i < N; i++) {
    int x = ...; // 위치
    int y = ...; // 색깔
    colorLists[y].add(x);
}
```

**시간 복잡도**: O(N)

### 2단계: 각 색깔 그룹 정렬

각 색깔 그룹을 위치 기준으로 정렬합니다.

```java
for (int color = 1; color <= N; color++) {
    Collections.sort(colorLists[color]);
}
```

**시간 복잡도**: O(N log N) (전체 N개 항목 정렬)

### 3단계: 인접 항목 비교

정렬된 배열에서 각 점의 왼쪽과 오른쪽 인접 항목 중 더 가까운 것을 선택합니다.

```java
for (int color = 1; color <= N; color++) {
    List<Integer> list = colorLists[color];
    for (int i = 0; i < list.size(); i++) {
        int minDist = Integer.MAX_VALUE;
        
        // 왼쪽 항목 확인
        if (i > 0) {
            minDist = Math.min(minDist, list.get(i) - list.get(i-1));
        }
        
        // 오른쪽 항목 확인
        if (i < list.size() - 1) {
            minDist = Math.min(minDist, list.get(i+1) - list.get(i));
        }
        
        totalSum += minDist;
    }
}
```

**시간 복잡도**: O(N) (각 점마다 상수 시간)

---

## 시간 복잡도

**전체 시간 복잡도: `O(N log N)`**

- 색깔별 그룹화: O(N)
- 정렬: O(N log N)
- 인접 항목 비교: O(N)
- **총합**: O(N log N)

**BOJ 15970 제약 조건 (N ≤ 10⁵, 시간 제한: 2초):**
- 연산 횟수: 약 10⁵ × log(10⁵) ≈ 1.7 × 10⁶
- 예상 실행 시간: 0.017초 (시간 제한 내 충분)

---

## 공간 복잡도

**전체 공간 복잡도: `O(N)`**

- 색깔별 리스트 배열: O(N)
- 입력 데이터: O(N)

**BOJ 15970 제약 조건 (N ≤ 10⁵, 메모리 제한: 512 MB):**
- 메모리 사용량: 약 10⁵ × 24 bytes ≈ 2.4 MB
- 메모리 제한 내에서 충분히 여유 있음 ✅

---

## 핵심 구현 패턴

### 패턴 1: 배열을 사용한 색깔별 그룹화

색깔이 1부터 N까지의 정수이므로 HashMap 대신 배열을 사용합니다.

```java
// HashMap 대신 배열 사용 (더 효율적)
List<Integer>[] colorLists = new ArrayList[N+1];
```

**장점:**
- 직접 인덱싱: O(1) 접근
- 해시 계산 오버헤드 없음
- 메모리 효율적

### 패턴 2: 정렬 후 인접 항목만 확인

정렬된 배열에서 최근접 점은 항상 인접한 항목 중 하나입니다.

```java
// 정렬 후 인접 항목만 확인
Collections.sort(list);
for (int i = 0; i < list.size(); i++) {
    // 왼쪽과 오른쪽만 확인
    if (i > 0) { /* 왼쪽 확인 */ }
    if (i < list.size() - 1) { /* 오른쪽 확인 */ }
}
```

**핵심**: 정렬된 배열에서 최근접 점은 인접 항목 중 하나라는 성질 활용
