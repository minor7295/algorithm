# 알고리즘 선택 및 코드 설계 근거

## 대안 1: 브루트 포스 (모든 쌍 확인)

각 점에 대해 같은 색깔을 가진 모든 점을 확인하여 가장 가까운 점을 찾는 방법입니다.

**시간 복잡도**: O(N²)
- 각 점마다 같은 색깔의 모든 점을 확인: O(N)
- 총 N개의 점: O(N) × O(N) = O(N²)

**BOJ 15970 제약 조건 (N ≤ 10⁵, 시간 제한: 2초):**
- 연산 횟수: 약 10¹⁰
- 예상 실행 시간: 약 10초 (시간 제한 초과)

**결론**: ❌ 시간 초과로 사용 불가

---

## 대안 2: 정렬 활용 (현재 방식) ✅

색깔별로 그룹화한 후 각 그룹을 정렬하고, 정렬된 배열에서 인접 항목만 확인하는 방법입니다.

**시간 복잡도**: O(N log N)
- 색깔별 그룹화: O(N)
- 정렬: O(N log N)
- 인접 항목 비교: O(N)
- 총합: O(N log N)

**BOJ 15970 제약 조건 (N ≤ 10⁵, 시간 제한: 2초):**
- 연산 횟수: 약 1.7 × 10⁶
- 예상 실행 시간: 약 0.017초 (시간 제한 내 충분)

**핵심 설계 원칙:**
- 정렬된 배열에서 최근접 점은 인접 항목 중 하나라는 성질 활용
- 색깔이 1~N 정수이므로 배열 사용 (HashMap보다 효율적)

**결론**: ✅ 시간 제한 내 해결 가능

---

## 자료구조 선택: 배열 vs HashMap

### 배열 사용 (현재 방식) ✅

```java
List<Integer>[] colorLists = new ArrayList[N+1];
```

**장점:**
- 직접 인덱싱: O(1) 접근
- 해시 계산 오버헤드 없음
- 메모리 효율적 (HashMap의 버킷/노드 오버헤드 없음)

**단점:**
- 색깔 범위가 연속된 정수여야 함 (이 문제는 만족)

### HashMap 사용

```java
Map<Integer, List<Integer>> colorMap = new HashMap<>();
```

**장점:**
- 색깔 범위가 불연속적이어도 사용 가능

**단점:**
- 해시 계산 오버헤드
- 메모리 오버헤드 (버킷, 노드 등)

**결론**: 색깔이 1~N 정수이므로 배열이 더 효율적 ✅

---

## 정렬 후 인접 항목만 확인하는 이유

### 핵심 성질

**정렬된 배열에서 각 점의 최근접 점은 항상 인접한 항목 중 하나입니다.**

**증명:**
- 점 p의 위치를 x라고 하자
- 왼쪽 인접 항목: x₁
- 오른쪽 인접 항목: x₂
- 다른 점 x₃ (x₁ < x₃ < x₂)가 있다고 가정
- 그러면 |x - x₃| < max(|x - x₁|, |x - x₂|)가 될 수 없음
- 따라서 최근접 점은 x₁ 또는 x₂ 중 하나

**결과:**
- 각 점마다 왼쪽과 오른쪽만 확인하면 됨
- O(N) 시간에 모든 점의 최근접 점을 찾을 수 있음
