# 알고리즘 선택 및 코드 설계 근거

이 문서는 **BOJ 2166 다각형의 면적 문제**에서 왜 이 알고리즘을 선택했는지, 그리고 코드가 어떻게 설계되었는지를 설명합니다.

---

## 1️⃣ 알고리즘 선택 근거: 왜 "신발끈 공식(Shoelace Formula)"인가?

> 📖 **알고리즘 상세 설명**: [2.algorithm.md](./2.algorithm.md)를 참고하세요.

### 🔑 핵심 사고 과정: 다각형을 어떻게 나눌까?

**왜 "신발끈 공식"이라는 접근을 했을까?**

**핵심 사고 과정:**

1. **목표: 다각형의 면적을 구하기**
   - 문제: "N개의 점으로 이루어진 다각형의 면적은?"
   - 하지만 다각형은 복잡한 모양일 수 있어서 직접 계산하기 어려움

2. **전략: 다각형을 여러 개의 도형으로 나누기**
   - 삼각형으로 나누기: 다각형을 여러 삼각형으로 나눠서 각각의 넓이를 더하기
   - 사다리꼴로 나누기: 각 변과 원점을 연결한 사다리꼴의 넓이를 더하기
   - **신발끈 공식**: 사다리꼴 방법을 수식으로 간단하게 표현

3. **효율성**
   - 시간 복잡도: O(N) (각 점을 한 번씩만 방문)
   - 공간 복잡도: O(N) (점들의 좌표 저장)
   - 매우 간단하고 효율적인 방법

---

### 🔍 다른 접근 방식과의 비교

**알고리즘을 결정할 때, 여러 방식 중에서 왜 "신발끈 공식"을 선택했을까?**

#### 주요 접근 방식 요약

1. **삼각형으로 분할**: 다각형을 여러 삼각형으로 나눠서 각각의 넓이를 더하기
   - 복잡도: O(N) (삼각형 개수만큼)
   - 구현 복잡도: 높음 (삼각형으로 나누는 로직 필요)
   - 정확도: 높음

2. **사다리꼴로 분할**: 각 변과 원점을 연결한 사다리꼴의 넓이를 더하기
   - 복잡도: O(N) (변 개수만큼)
   - 구현 복잡도: 중간 (사다리꼴 넓이 계산 필요)
   - 정확도: 높음

3. **신발끈 공식 (현재 방식) ✅**: 사다리꼴 방법을 수식으로 간단하게 표현
   - 복잡도: O(N) (각 점을 한 번씩만 방문)
   - 구현 복잡도: 낮음 (간단한 공식)
   - 정확도: 높음

**왜 신발끈 공식을 선택했는가?**

**핵심 이유:**
- ✅ **구현이 매우 간단**: 복잡한 분할 로직 없이 공식만 사용
- ✅ **O(N) 시간 복잡도**: 매우 빠름
- ✅ **정확함**: 수학적으로 정확한 결과
- ✅ **표준 방법**: 계산 기하학에서 널리 사용되는 방법
- ✅ **메모리 효율적**: 추가 자료구조 불필요

**결론:**
- 각 방식의 장단점을 고려한 결과
- **"신발끈 공식"이 가장 적합함**
- 구현이 간단하고, 효율적이며, 계산 기하학의 표준 방법

---

## 2️⃣ 코드 설계 근거: 코드와 알고리즘의 1:1 대응

### ① 입력 처리

```java
int n = Integer.parseInt(br.readLine());
long[] x = new long[n];
long[] y = new long[n];

for (int i = 0; i < n; i++) {
    st = new StringTokenizer(br.readLine());
    x[i] = Long.parseLong(st.nextToken());
    y[i] = Long.parseLong(st.nextToken());
}
```

* **목적**: N개의 점의 좌표를 입력받음
* **long 타입 사용**: 오버플로우 방지 (좌표 범위가 -100,000 ~ 100,000이므로 곱셈 시 int 범위 초과 가능)

### ② 신발끈 공식 구현

```java
static double polygonArea(long[] x, long[] y, int n) {
    long area = 0;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;  // 다음 점 (마지막 점은 첫 번째 점과 연결)
        area += x[i] * y[j] - x[j] * y[i];
    }
    
    return Math.abs(area) / 2.0;
}
```

**왜 이렇게 구현했는가?**

**핵심 이유: 신발끈 공식을 그대로 구현**

1. **각 변에 대해 계산**: 다각형의 각 변 P[i] → P[i+1]에 대해
   - `x[i] * y[j] - x[j] * y[i]` 계산
   - 이는 해당 변과 원점을 연결한 사다리꼴의 넓이의 2배

2. **순환 구조**: 마지막 점과 첫 번째 점도 연결되어야 하므로
   - `j = (i + 1) % n`을 사용하여 순환 구조 구현

3. **절댓값과 나누기**: 
   - 면적은 항상 양수여야 하므로 `Math.abs(area)` 사용
   - 사다리꼴 넓이의 합이 실제 넓이의 2배이므로 `/ 2.0`으로 나눔

**경계 조건:**
* 모든 점을 정확히 한 번씩만 방문
* 마지막 점과 첫 번째 점도 연결
* long 타입 사용으로 오버플로우 방지

### ③ 반올림 처리

```java
double area = polygonArea(x, y, n);
System.out.printf("%.1f\n", area);
```

**문제 요구사항:**
- 소수점 아래 둘째 자리에서 반올림하여 첫째 자리까지 출력
- `printf("%.1f", ...)`를 사용하여 자동으로 반올림 처리

---

## 3️⃣ 시간/공간 복잡도와 코드의 대응

> **시간/공간 복잡도 분석**: [2.algorithm.md](./2.algorithm.md)의 시간/공간 복잡도 섹션을 참고하세요.

**코드와의 대응:**
- 시간 복잡도 O(N): 입력 읽기 O(N) + 면적 계산 O(N) + 출력 O(1)
- 공간 복잡도 O(N): 입력 변수 N개 점 × 2개 좌표 = O(N)

---

## 4️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N) 시간 복잡도
* **정확함**: long 타입 사용으로 오버플로우 방지
* **표준 방법**: 계산 기하학에서 널리 사용되는 방법

### 추가 최적화 가능성

* 입력 최적화: BufferedReader 사용 (이미 사용 중)
* 함수 분리: polygonArea 함수를 별도로 분리하여 재사용 가능하게 함 (이미 구현)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 5️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 계산 기하학의 **기본 도구인 신발끈 공식을 활용**하여
* 알고리즘 문서에서 설명한 **다각형 면적 계산 알고리즘을 그대로 구현**하며
* long 타입으로 **정확하고 효율적으로 동작**하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 6️⃣ 핵심 설계 원칙

1. **정확성**: long 타입 사용으로 오버플로우 방지
2. **효율성**: O(N) 시간 복잡도로 최적화
3. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **표준성**: 계산 기하학에서 널리 사용되는 표준 방법

---

## 참고

* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 상세 설명: [2.algorithm.md](./2.algorithm.md)
* 계산 기하학 개요: [../computational-geometry.md](../computational-geometry.md)

