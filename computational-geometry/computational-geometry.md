# 계산 기하학(Computational Geometry) 정리

## 1️⃣ 계산 기하학이란?

### 🎯 계산 기하학의 정의

**계산 기하학(Computational Geometry)**은 기하학적 객체(점, 선, 다각형 등)를 컴퓨터로 처리하고 분석하는 알고리즘 분야입니다.

#### 기본 개념

**기하학적 객체**를 수학적으로 표현하고, 이를 통해 문제를 해결합니다:
- **점(Point)**: 2차원 좌표 (x, y)
- **선분(Line Segment)**: 두 점을 연결한 선
- **다각형(Polygon)**: 여러 점을 연결한 닫힌 도형
- **벡터(Vector)**: 방향과 크기를 가진 수학적 객체

**예시**:
```
점: P1(1, 1), P2(5, 5), P3(7, 3)
선분: P1-P2, P2-P3
다각형: P1 → P2 → P3 → P1
```

#### 왜 계산 기하학이 필요한가?

**기하학적 문제를 수학적으로 해결**하기 위해:
- 점들의 위치 관계 판단
- 선분의 교차 여부 확인
- 다각형의 넓이 계산
- 볼록 껍질(Convex Hull) 찾기

**일반적인 접근의 한계**:
- 단순히 좌표만으로는 방향, 교차 등을 판단하기 어려움
- 수학적 도구(벡터, 외적 등)가 필요

**계산 기하학의 해결책**: 벡터와 외적을 활용하여 수학적으로 정확하게 판단

---

## 2️⃣ 계산 기하학의 핵심 도구: 벡터와 외적

### 💡 벡터(Vector)란?

**벡터**는 방향과 크기를 가진 수학적 객체입니다.

**2차원 벡터**:
- 두 점 P1(x1, y1), P2(x2, y2)가 주어지면
- 벡터 P1P2 = (x2 - x1, y2 - y1)

**예시**:
```
P1(1, 1), P2(5, 5)
벡터 P1P2 = (5-1, 5-1) = (4, 4)
```

### 💡 외적(Cross Product)이란?

**외적**은 두 벡터의 상대적 방향을 나타내는 수학적 연산입니다.

**2차원 벡터의 외적**:
- 두 벡터 v1 = (a, b), v2 = (c, d)의 외적
- v1 × v2 = a × d - b × c

**기하학적 의미**:
- **외적의 절댓값**: 두 벡터가 이루는 평행사변형의 넓이
- **외적의 부호**: 두 벡터의 상대적 방향
  - 양수: v1이 v2보다 반시계 방향
  - 음수: v1이 v2보다 시계 방향
  - 0: 두 벡터가 평행 (일직선)

**예시**:
```
v1 = (4, 4), v2 = (6, 2)
외적 = 4 × 2 - 4 × 6 = 8 - 24 = -16 < 0
→ v1이 v2보다 시계 방향
```

---

## 3️⃣ CCW (Counter Clockwise) 알고리즘

### 📌 CCW란?

**CCW (Counter Clockwise)**는 세 점의 방향을 판단하는 계산 기하학의 기본 알고리즘입니다.

**문제**: 세 점 P1, P2, P3가 주어졌을 때, P1 → P2 → P3의 방향은?

**해결 방법**: 외적을 활용
1. P1을 기준으로 벡터 P1P2, P1P3 생성
2. 두 벡터의 외적 계산
3. 외적의 부호로 방향 판단

**결과**:
- **외적 > 0**: 반시계 방향 (1)
- **외적 < 0**: 시계 방향 (-1)
- **외적 = 0**: 일직선 (0)

### 📌 CCW 알고리즘 구현

```java
static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) {
    // 벡터 P1P2: (x2-x1, y2-y1)
    // 벡터 P1P3: (x3-x1, y3-y1)
    // 외적 = (x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)
    long cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
    
    if (cross > 0) return 1;      // 반시계 방향
    else if (cross < 0) return -1; // 시계 방향
    else return 0;                 // 일직선
}
```

**예시 (P1(1,1), P2(5,5), P3(7,3))**:
- 벡터 P1P2: (4, 4)
- 벡터 P1P3: (6, 2)
- 외적 = 4 × 2 - 4 × 6 = 8 - 24 = -16 < 0
- 결과: -1 (시계 방향)

### 📌 CCW의 활용

CCW 알고리즘은 계산 기하학의 기본 도구로, 다음과 같은 문제에서 활용됩니다:

1. **볼록 껍질 (Convex Hull)**: 그라함 스캔 알고리즘에서 사용
2. **선분 교차 판단**: 두 선분이 교차하는지 확인
3. **다각형 내부 점 판단**: 점이 다각형 내부에 있는지 확인
4. **다각형의 넓이 계산**: 외적을 이용한 다각형 넓이 계산

---

## 4️⃣ 언제 사용할까?

### ✅ 계산 기하학을 사용할 수 있는 조건

1. **기하학적 객체 다루기** (필수)
   - 점, 선분, 다각형 등의 기하학적 객체를 다룰 때
   - 좌표 평면에서의 위치 관계를 판단해야 할 때

2. **방향 판단 필요** (필수)
   - 세 점의 방향을 판단해야 할 때
   - 선분의 교차 여부를 확인해야 할 때

3. **정확한 수학적 계산** (필수)
   - 부동소수점 오차를 피하고 싶을 때
   - 정수 연산으로 정확하게 계산하고 싶을 때

### 📚 대표적인 예시

#### 1. CCW (BOJ 11758)
**문제**: 세 점의 방향 판단
**전략**: 외적을 이용한 방향 판단
**시간 복잡도**: O(1)

#### 2. 선분 교차 판단
**문제**: 두 선분이 교차하는지 확인
**전략**: CCW를 4번 사용하여 교차 판단
**시간 복잡도**: O(1)

#### 3. 볼록 껍질 (Convex Hull)
**문제**: 점들의 볼록 껍질 찾기
**전략**: 그라함 스캔 알고리즘 (CCW 활용)
**시간 복잡도**: O(N log N)

#### 4. 다각형 내부 점 판단
**문제**: 점이 다각형 내부에 있는지 확인
**전략**: 반직선과 다각형 변의 교차 횟수 확인
**시간 복잡도**: O(N)

---

## 5️⃣ 계산 기하학의 핵심 개념

### 📌 외적의 수학적 의미

**2차원 벡터의 외적**:
- 두 벡터 v1 = (a, b), v2 = (c, d)의 외적
- v1 × v2 = a × d - b × c

**기하학적 의미**:
- **외적의 절댓값**: 두 벡터가 이루는 평행사변형의 넓이
- **외적의 부호**: 두 벡터의 상대적 방향

**방향 판단**:
- **외적 > 0**: v1이 v2보다 반시계 방향으로 더 많이 회전 (반시계 방향)
- **외적 < 0**: v1이 v2보다 시계 방향으로 더 많이 회전 (시계 방향)
- **외적 = 0**: 두 벡터가 평행 (일직선)

### 📌 시각적 이해

```
반시계 방향 (cross > 0):
    P3
     |
     |
P1---P2
→ P1 → P2 → P3가 반시계 방향

시계 방향 (cross < 0):
P1---P2
     |
     |
    P3
→ P1 → P2 → P3가 시계 방향

일직선 (cross = 0):
P1---P2---P3
→ 세 점이 한 직선 위에 있음
```

---

## 6️⃣ 계산 기하학의 장단점

### ✅ 장점

#### 1. 정확성
- **정수 연산**: 부동소수점 오차 없음
- **수학적 정확성**: 벡터와 외적을 이용한 정확한 계산

**예시**:
```java
// 부동소수점 (오차 발생 가능)
double angle = Math.atan2(y2 - y1, x2 - x1);
double angle2 = Math.atan2(y3 - y1, x3 - x1);
double diff = angle2 - angle1;  // 부동소수점 오차 가능

// 외적 (정수 연산, 정확)
long cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
// 정수 연산으로 정확하게 판단 ✅
```

#### 2. 효율성
- **시간 복잡도**: 보통 O(1) 또는 O(N log N)
- **예시**: CCW는 O(1), 볼록 껍질은 O(N log N)

#### 3. 구현의 간결성
- **핵심 공식**: 외적 계산만으로 방향 판단
- **복잡한 조건문 불필요**: 외적의 부호만 확인

### ❌ 단점

#### 1. 오버플로우 주의
**좌표 범위가 클 때 오버플로우 발생 가능**

**예시**:
```
좌표 범위: -10,000 ~ 10,000
외적 계산: (x2-x1) × (y3-y1)
최대값: 20,000 × 20,000 = 400,000,000
int 범위: -2,147,483,648 ~ 2,147,483,647
→ int로는 오버플로우 발생 가능!
```

**해결책**:
```java
// long 타입 사용
long cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
```

#### 2. 수학적 배경 필요
- 벡터와 외적에 대한 이해 필요
- 기하학적 직관이 필요할 수 있음

#### 3. 제한적 적용
- 기하학적 문제에만 적용 가능
- 일반적인 알고리즘 문제에는 부적합

---

## 7️⃣ 계산 기하학 vs 다른 알고리즘

### 📊 비교표

| 기법 | 특징 | 시간 복잡도 | 예시 | 적용 조건 |
|------|------|------------|------|----------|
| **계산 기하학** | 벡터와 외적 활용 | O(1) ~ O(N log N) | CCW, 선분 교차 | 기하학적 객체 |
| **완전 탐색** | 모든 경우 탐색 | 지수 시간 | 모든 점 쌍 확인 | 작은 입력 |
| **그래프 알고리즘** | 그래프 탐색 | O(V+E) | 최단 경로 | 그래프 구조 |

### 🔍 구체적인 비교: 세 점의 방향 판단

#### 상황: 세 점 P1, P2, P3의 방향 판단

**1. 계산 기하학 방법 (CCW)**:
- **동작**: 외적 계산으로 방향 판단
- **연산 횟수**: 상수 시간 (덧셈, 뺄셈, 곱셈)
- **시간 복잡도**: O(1)
- **코드**: 간단한 외적 계산
- **장점**: 구현이 간단하고 정확함

**2. 각도 계산 방법**:
- **동작**: 각 점의 각도를 계산하여 비교
- **연산 횟수**: atan2 함수 호출 (비용 큼)
- **시간 복잡도**: O(1) (하지만 느림)
- **코드**: 복잡한 각도 계산
- **단점**: 부동소수점 오차 발생 가능

**3. 기울기 비교 방법**:
- **동작**: 기울기를 비교하여 방향 판단
- **연산 횟수**: 나눗셈 연산
- **시간 복잡도**: O(1)
- **코드**: 복잡한 예외 처리 필요
- **단점**: 0으로 나누기 문제, 부동소수점 오차

| 방법 | 연산 횟수 | 정확도 | 코드 난이도 | 효율성 |
|------|----------|--------|-----------|--------|
| **CCW (외적)** | 약 5번 | ⭐⭐⭐ 정확 (정수) | ⭐ 간단 | ⭐⭐⭐ 효율적 |
| **각도 계산** | 약 10번 | ⭐ 부정확 (부동소수점) | ⭐⭐ 보통 | ⭐ 느림 |
| **기울기 비교** | 약 5번 | ⭐ 부정확 (부동소수점) | ⭐⭐⭐ 복잡 | ⭐⭐ 보통 |

**결론**: **CCW가 구현이 간단하면서도 정확하고 효율적**입니다!

---

## 8️⃣ 계산 기하학 구현 패턴

### 패턴 1: CCW (Counter Clockwise)

**사용 시나리오**: 세 점의 방향 판단

```java
static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) {
    long cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
    
    if (cross > 0) return 1;      // 반시계 방향
    else if (cross < 0) return -1; // 시계 방향
    else return 0;                 // 일직선
}
```

**실제 예시**: BOJ 11758
```java
int result = ccw(x1, y1, x2, y2, x3, y3);
System.out.println(result);
```

### 패턴 2: 선분 교차 판단

**사용 시나리오**: 두 선분이 교차하는지 확인

```java
// 선분 AB와 선분 CD가 교차하는지 확인
static boolean isIntersect(long x1, long y1, long x2, long y2,
                          long x3, long y3, long x4, long y4) {
    int ccw1 = ccw(x1, y1, x2, y2, x3, y3);
    int ccw2 = ccw(x1, y1, x2, y2, x4, y4);
    int ccw3 = ccw(x3, y3, x4, y4, x1, y1);
    int ccw4 = ccw(x3, y3, x4, y4, x2, y2);
    
    // 두 선분이 교차하는 조건
    return (ccw1 * ccw2 < 0) && (ccw3 * ccw4 < 0);
}
```

### 패턴 3: 다각형의 넓이 계산

**사용 시나리오**: 다각형의 넓이 계산

```java
// 외적을 이용한 다각형 넓이 계산
static double polygonArea(long[] x, long[] y, int n) {
    long area = 0;
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += x[i] * y[j] - x[j] * y[i];
    }
    return Math.abs(area) / 2.0;
}
```

---

## 9️⃣ 계산 기하학 사용 시 주의사항

### 1. 오버플로우 주의

**문제**: 좌표 범위가 클 때 외적 계산 시 오버플로우 발생

**해결책**:
```java
// ❌ 잘못된 코드
int cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);

// ✅ 올바른 코드
long cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
```

### 2. 좌표계 주의

**문제**: 좌표계에 따라 결과가 달라질 수 있음

**해결책**:
- 문제에서 명시한 좌표계를 정확히 따름
- 일반적으로 수학 좌표계 (x: 가로, y: 세로) 사용

### 3. 경계 조건 처리

**문제**: 일직선인 경우, 점이 겹치는 경우 등

**해결책**:
```java
// CCW 결과가 0이면 일직선
if (cross == 0) {
    // 일직선 처리
}
```

---

## 🔟 정리

계산 기하학은 **벡터와 외적을 활용하여 기하학적 문제를 수학적으로 해결**하는 방법입니다.

### ✅ 핵심 요약

1. **기본 원리**: 벡터와 외적을 이용한 방향 판단
2. **핵심 도구**: CCW 알고리즘
3. **장점**: 정확성 (정수 연산), 효율성, 구현 간결성
4. **단점**: 오버플로우 주의, 수학적 배경 필요

### 🎯 실전 팁

1. **오버플로우 방지**: long 타입 사용
2. **CCW 함수**: 재사용 가능하도록 함수로 분리
3. **정확성**: 부동소수점 대신 정수 연산 사용
4. **테스트**: 다양한 예시로 검증

### 📚 학습 순서

1. **CCW (BOJ 11758)** - 가장 기본적인 계산 기하학 문제
2. **선분 교차 판단** - CCW를 4번 사용
3. **볼록 껍질** - 그라함 스캔 알고리즘
4. **다각형 내부 점 판단** - 반직선과 교차

적절한 문제에 계산 기하학을 적용하면 **정확하고 효율적인 해결책**을 얻을 수 있습니다!

---

## 참고 자료

* **CCW 알고리즘**: [boj-11758/2.algorithm.md](./boj-11758/2.algorithm.md)
* **외적 (Cross Product)**: 두 벡터의 외적은 2차원에서는 스칼라, 3차원에서는 벡터
* **계산 기하학**: 컴퓨터 과학과 수학의 교차 분야

