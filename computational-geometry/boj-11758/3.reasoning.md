# 알고리즘 선택 및 코드 설계 근거

이 문서는 **BOJ 11758 CCW 문제**에서 왜 이 알고리즘을 선택했는지, 그리고 코드가 어떻게 설계되었는지를 설명합니다.

---

## 1️⃣ 알고리즘 선택 근거: 왜 "외적(Cross Product)"인가?

> 📖 **알고리즘 상세 설명**: [2.algorithm.md](./2.algorithm.md)를 참고하세요.

### 🔑 핵심 사고 과정: 수학적 방법을 통한 방향 판단

**왜 "외적"이라는 접근을 했을까?**

**핵심 사고 과정:**

1. **목표: 세 점의 방향을 판단하기**
   - 문제: "P1, P2, P3를 순서대로 이은 선분이 어떤 방향인가?"
   - 하지만 단순히 좌표만으로는 방향을 판단하기 어려움

2. **전략: 벡터와 외적 활용**
   - 세 점을 벡터로 변환: P1을 기준으로 P1P2, P1P3 벡터 생성
   - 외적 계산: 두 벡터의 외적을 계산하면 방향을 알 수 있음
   - 외적의 부호로 방향 판단: 양수면 반시계, 음수면 시계, 0이면 일직선

3. **효율성**
   - 시간 복잡도: O(1) (상수 시간)
   - 공간 복잡도: O(1) (상수 공간)
   - 매우 간단하고 효율적인 방법

---

### 🔍 다른 접근 방식과의 비교

> 📖 **다른 접근 방식 상세 비교**: [../computational-geometry.md](../computational-geometry.md)의 "7️⃣ 계산 기하학 vs 다른 알고리즘" 섹션에서 각도 계산, 기울기 비교, 외적 활용 방법의 상세한 비교를 확인할 수 있습니다.

**알고리즘을 결정할 때, 여러 방식 중에서 왜 "외적"을 선택했을까?**

#### 주요 접근 방식 요약

1. **각도 계산**: `atan2` 함수 사용 → 부동소수점 오차, 경계 조건 처리 복잡
2. **기울기 비교**: 나눗셈 연산 → 0으로 나누기 문제, 부동소수점 오차
3. **외적 활용 (현재 방식) ✅**: 정수 연산 → 정확, 간단, 표준 방법

**왜 외적을 선택했는가?**

**핵심 이유:**
- ✅ **정수 연산만 사용**: 부동소수점 오차 없음
- ✅ **O(1) 시간 복잡도**: 매우 빠름
- ✅ **경계 조건 없음**: 모든 경우를 동일하게 처리
- ✅ **일직선 판단 간단**: cross == 0이면 일직선
- ✅ **계산 기하학 표준 방법**: 널리 사용되는 방법

**결론:**
- 각 방식의 장단점을 고려한 결과
- **"외적 활용"이 가장 적합함**
- 정수 연산으로 정확하고, 구현이 간단하며, 계산 기하학의 표준 방법

> 💡 **상세 비교**: 각 방식의 구체적인 코드 예시와 성능 비교는 [../computational-geometry.md](../computational-geometry.md)의 "7️⃣ 계산 기하학 vs 다른 알고리즘" 섹션을 참고하세요.

---

## 2️⃣ 코드 설계 근거: 코드와 알고리즘의 1:1 대응

### ① 입력 처리

```java
long x1 = Long.parseLong(st.nextToken());
long y1 = Long.parseLong(st.nextToken());
// ... P2, P3도 동일
```

* **목적**: 세 점의 좌표를 입력받음
* **long 타입 사용**: 오버플로우 방지 (외적 계산 시 필요)

### ② CCW 함수 구현

```java
static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) {
    long cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
    
    if (cross > 0) return 1;      // 반시계 방향
    else if (cross < 0) return -1; // 시계 방향
    else return 0;                 // 일직선
}
```

**왜 이렇게 구현했는가?**

**핵심 이유: 외적의 수학적 정의를 그대로 구현**

1. **벡터 생성**: P1을 기준으로 P1P2, P1P3 벡터 생성
   - P1P2: (x2-x1, y2-y1)
   - P1P3: (x3-x1, y3-y1)

2. **외적 계산**: 2차원 벡터의 외적 공식
   - v1 × v2 = (a, b) × (c, d) = a × d - b × c
   - 여기서: (x2-x1) × (y3-y1) - (y2-y1) × (x3-x1)

3. **방향 판단**: 외적의 부호에 따라
   - 양수: 반시계 방향 (1)
   - 음수: 시계 방향 (-1)
   - 0: 일직선 (0)

**경계 조건:**
* 모든 경우를 동일하게 처리 (특별한 예외 처리 불필요)
* long 타입 사용으로 오버플로우 방지

### ③ 결과 출력

```java
int result = ccw(x1, y1, x2, y2, x3, y3);
System.out.println(result);
```

**직관적이고 간단한 출력**
- CCW 함수의 결과를 그대로 출력
- 추가 처리 불필요

---

## 3️⃣ 시간/공간 복잡도와 코드의 대응

> **시간/공간 복잡도 분석**: [2.algorithm.md](./2.algorithm.md)의 시간/공간 복잡도 섹션을 참고하세요.

**코드와의 대응:**
- 시간 복잡도 O(1): 입력 읽기 O(1) + 외적 계산 O(1) + 출력 O(1)
- 공간 복잡도 O(1): 입력 변수 6개 + 계산 변수 1개 = 상수 공간

---

## 4️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(1) 시간 복잡도
* **정확함**: 정수 연산으로 부동소수점 오차 없음
* **표준 방법**: 계산 기하학에서 널리 사용되는 방법

### 추가 최적화 가능성

* 입력 최적화: BufferedReader 사용 (이미 사용 중)
* 함수 분리: CCW 함수를 별도로 분리하여 재사용 가능하게 함 (이미 구현)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 5️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 계산 기하학의 **기본 도구인 외적을 활용**하여
* 알고리즘 문서에서 설명한 **CCW 알고리즘을 그대로 구현**하며
* 정수 연산으로 **정확하고 효율적으로 동작**하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 6️⃣ 핵심 설계 원칙

1. **정확성**: 정수 연산으로 부동소수점 오차 없음
2. **효율성**: O(1) 시간 복잡도로 최적화
3. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **표준성**: 계산 기하학에서 널리 사용되는 표준 방법

---

## 참고

* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 상세 설명: [2.algorithm.md](./2.algorithm.md)
* 계산 기하학 개요: [../computational-geometry.md](../computational-geometry.md)

