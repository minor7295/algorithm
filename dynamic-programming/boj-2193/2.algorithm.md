# 알고리즘: 동적 계획법

> 📖 **전체 알고리즘 설명**: [동적 계획법(Dynamic Programming) 정리](../dynamic-programming.md)

이 문제는 **동적 계획법(DP)**을 사용하여 해결합니다.  
상위 폴더의 [동적 계획법 정리 문서](../dynamic-programming.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## DP 알고리즘 개요

마지막 자리 숫자(0 또는 1)로 분류하여 각각의 개수를 계산합니다.

### 핵심 아이디어

**🔑 핵심 노하우: 마지막 자리 숫자로 분류하기**

이 문제를 풀기 위한 가장 중요한 포인트는 **"마지막 자리 숫자가 0인지 1인지로 분류"**하는 것입니다.

**작은 예시로 규칙 찾기:**

```
1자리: 1
  → 0으로 끝남: 0개 (a_1 = 0)
  → 1로 끝남: 1개 (b_1 = 1)

2자리: 10
  → 0으로 끝남: 1개 (a_2 = 1)
  → 1로 끝남: 0개 (b_2 = 0)

3자리: 100, 101
  → 0으로 끝남: 1개 (a_3 = 1)
  → 1로 끝남: 1개 (b_3 = 1)

4자리: 1000, 1001, 1010
  → 0으로 끝남: 2개 (a_4 = 2)
  → 1로 끝남: 1개 (b_4 = 1)
```

**규칙 발견:**

* **N자리 이친수 중 0으로 끝나는 것**: (N-1)자리 이친수 모두에 0을 붙일 수 있음
  - `a_n = a_{n-1} + b_{n-1}`

* **N자리 이친수 중 1로 끝나는 것**: (N-1)자리 이친수 중 0으로 끝나는 것에만 1을 붙일 수 있음 (11 방지)
  - `b_n = a_{n-1}`

1. **상태 정의**: 
   - `a[i]` = i자리 이친수 중 0으로 끝나는 것의 개수
   - `b[i]` = i자리 이친수 중 1로 끝나는 것의 개수
   - 총 개수 = `a[i] + b[i]`

2. **점화식 도출**:
   
   **점화식:**
   ```
   a[i] = a[i-1] + b[i-1]  // (i-1)자리 이친수 모두에 0을 붙일 수 있음
   b[i] = a[i-1]            // (i-1)자리 이친수 중 0으로 끝나는 것에만 1을 붙일 수 있음
   ```
   
   **점화식의 의미:**
   - **a[i]**: i자리 이친수 중 0으로 끝나는 것
     - (i-1)자리 이친수에 0을 붙이면 됨
     - 0으로 끝나는 것과 1로 끝나는 것 모두 가능 (0을 붙여도 11이 되지 않음)
   - **b[i]**: i자리 이친수 중 1로 끝나는 것
     - (i-1)자리 이친수 중 0으로 끝나는 것에만 1을 붙일 수 있음
     - 1로 끝나는 것에 1을 붙이면 11이 되어 조건 위배

3. **초기값**: 
   ```
   a[1] = 0  (1자리 중 0으로 끝나는 것: 없음)
   b[1] = 1  (1자리 중 1로 끝나는 것: 1)
   ```

---

## 구현 패턴

**구체적인 예시로 이해하기:**

```java
long[] a = new long[91];  // 0으로 끝나는 것의 개수
long[] b = new long[91];  // 1로 끝나는 것의 개수

// 초기값
a[1] = 0;
b[1] = 1;

// 점화식 적용
for (int i = 2; i <= n; i++) {
    a[i] = a[i-1] + b[i-1];  // 0으로 끝남
    b[i] = a[i-1];            // 1로 끝남
}

// 답: n자리 이친수의 총 개수
long answer = a[n] + b[n];
```

---

**실제 계산 과정 (N=5 예시):**

```
초기값:
a[1] = 0, b[1] = 1

i=2:
  a[2] = a[1] + b[1] = 0 + 1 = 1  (10)
  b[2] = a[1] = 0                 (없음)
  총: 1개

i=3:
  a[3] = a[2] + b[2] = 1 + 0 = 1  (100)
  b[3] = a[2] = 1                 (101)
  총: 2개

i=4:
  a[4] = a[3] + b[3] = 1 + 1 = 2  (1000, 1010)
  b[4] = a[3] = 1                 (1001)
  총: 3개

i=5:
  a[5] = a[4] + b[4] = 2 + 1 = 3  (10000, 10010, 10100)
  b[5] = a[4] = 2                 (10001, 10101)
  총: 5개

답: a[5] + b[5] = 3 + 2 = 5
```

---

> **최적 부분 구조와 중복 부분 문제**: [3.reasoning.md](./3.reasoning.md)의 "4️⃣ DP의 최적 부분 구조" 섹션을 참고하세요.

---

## 시간 복잡도

**전체 시간 복잡도: `O(N)`**

**근거:**
- **리스트의 항목 한 번씩 탐색**: N개의 자릿수(1자리부터 N자리까지)를 각각 한 번씩만 처리
- **각 자릿수 처리 시간**: O(1) (덧셈 연산은 상수 시간)
- **전체 시간**: N개 항목 × O(1) = O(N)

**구체적인 계산:**
```
for (int i = 2; i <= n; i++) {  // (n-1)번 반복
    a[i] = a[i-1] + b[i-1];     // O(1)
    b[i] = a[i-1];               // O(1)
}
// 총 시간: (n-1) × O(1) = O(n)
```

**상태 개수:**
* 2N개 (a[1..n], b[1..n])

**각 상태 처리 시간:**
* O(1) (상수 시간)

---

## 공간 복잡도

* **DP 배열**: O(N) (a 배열과 b 배열 각각 N개)
* **전체 공간 복잡도**: **O(N)**

---

## 이 문제의 특이사항

### 1️⃣ 자료형 선택: long 타입 필수

**왜 long을 사용해야 하는가?**

이 문제는 피보나치 수열과 같은 점화식을 따르므로, N이 커질수록 값이 매우 커집니다.

**실제 값:**
- F(30) = 832,040
- F(40) = 102,334,155
- F(50) = 12,586,269,025 (약 125억)
- F(60) = 1,548,008,755,920 (약 1.5조)
- **F(90) = 2,880,067,194,370,816,120 (약 288경)**

**Java 정수 타입 범위:**
- `int`: -2,147,483,648 ~ 2,147,483,647 (약 -21억 ~ 21억)
- `long`: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 -9경 ~ 9경)

**결론:**
- N ≤ 46: `int`로 가능
- N = 90: `long` 필수 (int로 계산하면 오버플로우 발생)

### 2️⃣ 피보나치 수열과의 관계

**관찰:**
- `a[n] + b[n]`의 값이 피보나치 수열을 따름
- F(1) = 1, F(2) = 1, F(3) = 2, F(4) = 3, F(5) = 5, ...

**증명:**
```
a[n] + b[n] = (a[n-1] + b[n-1]) + a[n-1]
            = (a[n-1] + b[n-1]) + (a[n-2] + b[n-2])
            = F(n-1) + F(n-2)
            = F(n)
```

따라서 이 문제는 피보나치 수열의 n번째 항을 구하는 문제와 동일합니다.
