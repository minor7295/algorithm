# Main.java 설계 근거 정리

## 1️⃣ 알고리즘 선택 근거: 동적 계획법 (DP)

### 🔑 DP 사고 과정: 규칙 발견을 통한 점화식 도출

**왜 "마지막 자리 숫자로 분류"라는 상태 정의를 했을까?**

**핵심 사고 과정:**

1. **목표: N자리 이친수의 개수 구하기**
   - 문제: "N자리 이친수의 개수"
   - 하지만 이것을 직접 세기는 어려움 (N이 최대 90)

2. **전략: 규칙 발견을 통한 점화식 도출**
   - 작은 예시를 나열하여 규칙을 발견
   - "마지막 자리 숫자로 분류"하면 규칙이 보임
   - 규칙을 점화식으로 표현

3. **부분 문제의 해를 조합하여 전체 문제 해결**
   - `a[i]` = i자리 이친수 중 0으로 끝나는 것의 개수
   - `b[i]` = i자리 이친수 중 1로 끝나는 것의 개수
   - `a[i] + b[i]` = i자리 이친수의 총 개수

**왜 이렇게 접근했는가?**

**직접 세는 방법:**
- 모든 가능한 N자리 이진수를 생성하고 조건 확인
- 시간 복잡도: O(2^N) - 비효율적
  - **근거**: 깊이별로 2배로 항목이 늘어나는 트리 구조, 항목 하나씩 확인

**점화식으로 해결:**
- 작은 예시로 규칙 발견
- 규칙을 점화식으로 표현
- 시간 복잡도: O(N) - 효율적
  - **근거**: 리스트의 항목(N개)을 한 번씩만 탐색

**구체적인 예시:**

```
직접 세기:
→ 1자리: 1 (1개)
→ 2자리: 10 (1개)
→ 3자리: 100, 101 (2개)
→ 4자리: 1000, 1001, 1010 (3개)
→ 5자리: 10000, 10001, 10010, 10100, 10101 (5개)

규칙 발견:
→ 마지막 자리가 0: 이전 자리 이친수 모두에 0 붙이기
→ 마지막 자리가 1: 이전 자리 이친수 중 0으로 끝나는 것에만 1 붙이기

점화식:
→ a[i] = a[i-1] + b[i-1]
→ b[i] = a[i-1]
```

**결론:**
- 직접 세기는 비효율적이므로
- **규칙을 발견하여 점화식으로 표현**
- 부분 문제의 해를 조합하여 전체 문제 해결
- 이것이 바로 DP의 핵심 사고 과정!

---

### 🔍 다른 접근 방식과의 비교

**상태 정의를 결정할 때, 여러 방식 중에서 왜 `a[i]`, `b[i]`를 선택했을까?**

다른 접근 방식들을 고려해보고 비교해봅시다:

#### 방식 1: `dp[i] = i자리 이친수의 총 개수` (단순 1차원)

**접근:**
```java
dp[i] = i자리 이친수의 총 개수
```

**장점:**
- 간단하고 직관적

**단점:**
- ❌ **문제: 점화식 도출이 어려움**
- 마지막 자리 정보가 없어서 다음 자리를 추가할 때 규칙을 적용하기 어려움
- 예: i자리 이친수에 0 또는 1을 붙일 때, 마지막 자리가 무엇인지 알아야 함

**예시:**
```
dp[3] = 2 (100, 101)
dp[4] = ? 
→ 100에 0 붙이면 1000 (가능)
→ 100에 1 붙이면 1001 (가능)
→ 101에 0 붙이면 1010 (가능)
→ 101에 1 붙이면 1011 (불가능 - 11 포함)

하지만 dp[3]만으로는 100과 101 중 어느 것이 0으로 끝나고 1로 끝나는지 알 수 없음!
```

---

#### 방식 2: `dp[i][j] = i자리 이친수 중 j로 끝나는 것의 개수` (2차원)

**접근:**
```java
dp[i][0] = i자리 이친수 중 0으로 끝나는 것의 개수
dp[i][1] = i자리 이친수 중 1로 끝나는 것의 개수
```

**장점:**
- ✅ **마지막 자리 정보를 명확히 저장**
- ✅ **점화식 도출이 자연스러움**
- ✅ **공간 복잡도 O(N), 시간 복잡도 O(N)**

**단점:**
- 없음 (이 문제에 가장 적합)

**예시:**
```
dp[3][0] = 1 (100)
dp[3][1] = 1 (101)

dp[4][0] = dp[3][0] + dp[3][1] = 1 + 1 = 2  (1000, 1010)
dp[4][1] = dp[3][0] = 1                      (1001)

→ 자연스럽고 직관적!
```

---

#### 방식 3: `a[i]`, `b[i]` 배열 분리 (현재 방식) ✅

**접근:**
```java
a[i] = i자리 이친수 중 0으로 끝나는 것의 개수
b[i] = i자리 이친수 중 1로 끝나는 것의 개수
```

**장점:**
- ✅ **방식 2와 동일하지만 더 간결함**
- ✅ **점화식이 명확함**
- ✅ **공간 복잡도 O(N), 시간 복잡도 O(N)**

**단점:**
- 없음

**예시:**
```
a[3] = 1, b[3] = 1

a[4] = a[3] + b[3] = 1 + 1 = 2
b[4] = a[3] = 1

→ 간결하고 명확!
```

---

### 📊 종합 비교

| 방식 | 공간 복잡도 | 시간 복잡도 | 점화식 도출 | 적합성 |
|------|------------|------------|------------|--------|
| `dp[i] = 총 개수` | O(N) | O(N) | 어려움 | ❌ |
| `dp[i][j] = j로 끝나는 개수` | O(N) | O(N) | 자연스러움 | ✅ |
| `a[i]`, `b[i]` 분리 | O(N) | O(N) | 명확함 | ✅ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **`a[i]`, `b[i]` 배열 분리가 가장 간결하고 명확함**
- 마지막 자리 정보를 명확히 저장하여 점화식 도출이 자연스러움

---

### 알고리즘 선택 근거

이 문제는 **점화식 문제**로, 동적 계획법이 가장 효율적입니다.

**문제 해석에서 DP로 연결되는 과정:**

> **문제 해석**: [1.analysis.md](./1.analysis.md)에서 이 문제를 "마지막 자리 숫자로 분류"하여 규칙을 발견했습니다.

이 해석을 통해 다음을 발견할 수 있습니다:

1. **최적 부분 구조 발견**: 
   - "i자리 이친수 개수" = (i-1)자리 이친수 개수로 표현 가능
   - 이는 DP의 핵심 조건인 "최적 부분 구조"를 만족!

2. **DP로 자연스럽게 연결**:
   - 작은 문제의 해를 이용하여 큰 문제의 해를 표현
   - 점화식으로 명확히 표현 가능

**핵심 특징:**
* 작은 예시로 규칙 발견 가능
* 규칙이 점화식으로 명확히 표현됨
* 최적 부분 구조: i자리 이친수 개수 = (i-1)자리 이친수 개수로 표현
* 중복 부분 문제: 같은 자릿수의 이친수 개수를 여러 번 계산
* N ≤ 90이므로 O(N) 시간 복잡도로 효율적

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① DP 배열 정의

```java
long[] a = new long[91];  // a[i]: i자리 이친수 중 0으로 끝나는 것의 개수
long[] b = new long[91];  // b[i]: i자리 이친수 중 1로 끝나는 것의 개수
```

* `a[i]`: i자리 이친수 중 0으로 끝나는 것의 개수
* `b[i]`: i자리 이친수 중 1로 끝나는 것의 개수
* 배열 크기를 91로 설정 (N ≤ 90)
* **long 타입 사용**: 피보나치 수열이므로 값이 매우 큼

### ② 초기값 설정

```java
a[1] = 0;  // 1자리 중 0으로 끝나는 것: 없음
b[1] = 1;  // 1자리 중 1로 끝나는 것: 1
```

**초기값의 의미:**
- 1자리 이친수는 "1"만 가능 (0으로 시작 불가)
- 따라서 0으로 끝나는 것은 없고, 1로 끝나는 것은 1개

### ③ 점화식 구현 (규칙 발견에서 도출)

**"마지막 자리 숫자로 분류" 해석이 점화식으로 이어지는 과정:**

```java
for (int i = 2; i <= n; i++) {
    // i자리 이친수 중 0으로 끝나는 것
    a[i] = a[i-1] + b[i-1];  // (i-1)자리 이친수 모두에 0을 붙일 수 있음
    
    // i자리 이친수 중 1로 끝나는 것
    b[i] = a[i-1];            // (i-1)자리 이친수 중 0으로 끝나는 것에만 1을 붙일 수 있음
}
```

**점화식의 의미:**
1. **a[i] = a[i-1] + b[i-1]**: i자리 이친수 중 0으로 끝나는 것
   - (i-1)자리 이친수에 0을 붙이면 됨
   - 0으로 끝나는 것과 1로 끝나는 것 모두 가능 (0을 붙여도 11이 되지 않음)

2. **b[i] = a[i-1]**: i자리 이친수 중 1로 끝나는 것
   - (i-1)자리 이친수 중 0으로 끝나는 것에만 1을 붙일 수 있음
   - 1로 끝나는 것에 1을 붙이면 11이 되어 조건 위배

---

## 3️⃣ 자료형 선택: long 타입 필수

### 왜 long을 사용해야 하는가?

이 문제는 피보나치 수열과 같은 점화식을 따르므로, N이 커질수록 값이 매우 커집니다.

**실제 값:**
- F(30) = 832,040
- F(40) = 102,334,155
- F(50) = 12,586,269,025 (약 125억)
- F(60) = 1,548,008,755,920 (약 1.5조)
- **F(90) = 2,880,067,194,370,816,120 (약 288경)**

**Java 정수 타입 범위:**
- `int`: -2,147,483,648 ~ 2,147,483,647 (약 -21억 ~ 21억)
- `long`: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 -9경 ~ 9경)

**int로 계산하면:**
- F(46) = 1,836,311,903 (int 범위 내)
- F(47) 계산 시 오버플로우 발생 (음수로 변환)

**결론:**
- N ≤ 46: `int`로 가능
- N = 90: `long` 필수

---

## 4️⃣ DP의 최적 부분 구조

### 최적 부분 구조의 의미

i자리 이친수의 개수는 다음으로 표현됩니다:
1. i자리 이친수 중 0으로 끝나는 것: (i-1)자리 이친수 모두에 0 붙이기
2. i자리 이친수 중 1로 끝나는 것: (i-1)자리 이친수 중 0으로 끝나는 것에만 1 붙이기

이 두 경우 모두 더 작은 문제의 해를 사용하므로, 최적 부분 구조를 만족합니다.

> **실제 계산 과정**: [2.algorithm.md](./2.algorithm.md)의 "실제 계산 과정 (N=5 예시)" 섹션을 참고하세요.

---

## 5️⃣ 피보나치 수열과의 관계

### 관찰

이 문제의 답 `a[n] + b[n]`이 피보나치 수열을 따릅니다.

**증명:**
```
a[n] + b[n] = (a[n-1] + b[n-1]) + a[n-1]
            = (a[n-1] + b[n-1]) + (a[n-2] + b[n-2])
            = F(n-1) + F(n-2)
            = F(n)
```

**따라서:**
- 이 문제는 피보나치 수열의 n번째 항을 구하는 문제와 동일
- 단순히 피보나치 수열을 계산해도 답을 구할 수 있음
- 하지만 "마지막 자리로 분류"하는 접근이 문제의 본질을 더 잘 드러냄

---

## 6️⃣ 시간/공간 복잡도와 코드의 대응

> **시간/공간 복잡도 분석**: [2.algorithm.md](./2.algorithm.md)의 시간/공간 복잡도 섹션을 참고하세요.

**코드와의 대응:**
- 시간 복잡도 O(N): `for (int i = 2; i <= n; i++)` 루프가 (n-1)번 실행
- 공간 복잡도 O(N): `long[] a`, `long[] b` 배열 각각 N개 사용

---

## 7️⃣ 다른 접근 방법과의 비교

### 방법 1: 동적 계획법 (현재 방법) ✅

**장점:**
* 시간 복잡도 O(N)으로 매우 효율적
  - **근거**: 리스트의 항목(N개)을 한 번씩만 탐색
* 구현이 간단하고 직관적
* 일반적인 해법

**단점:**
* 없음 (이 문제에 가장 적합)

### 방법 2: 백트래킹

**장점:**
* 구현이 간단
* 모든 경우를 탐색하므로 이해하기 쉬움

**단점:**
* 시간 복잡도 O(2^N)으로 비효율적
  - **근거**: 깊이별로 2배로 항목이 늘어나는 트리 구조, 항목 하나씩 확인
* N이 커지면 시간 초과 가능

### 방법 3: 피보나치 수열 직접 계산

**장점:**
* 더 간단한 코드
* 동일한 시간 복잡도 O(N)

**단점:**
* 문제의 본질(마지막 자리로 분류)을 드러내지 않음
* 교육적 가치가 낮음

➡️ **동적 계획법이 이 문제에 가장 적합한 방법이다.**

---

## 8️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **시간 효율적**: O(N) 시간 복잡도
* **자료형 적절**: long 타입으로 오버플로우 방지

### 추가 최적화 가능성

* 공간 최적화: a[i], b[i]만 필요하므로 이전 값만 저장 가능 (하지만 코드 복잡도 증가)
* 입력 최적화: BufferedReader 사용 (이미 사용 중)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **규칙 발견 과정**을 동적 계획법으로 모델링하고
* 알고리즘 문서에서 설명한 **최적 부분 구조**를 그대로 활용하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **효율성**: O(N) 시간 복잡도로 최적화
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
4. **간결성**: 불필요한 복잡성 없이 핵심만 구현
5. **안전성**: long 타입으로 오버플로우 방지

