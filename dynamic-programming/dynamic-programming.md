# 동적 계획법(Dynamic Programming) 정리

## 1️⃣ 동적 계획법이란?

**동적 계획법(Dynamic Programming, DP)** 이란

> **복잡한 문제를 작은 하위 문제로 나누어 해결**하고,
> **중복 계산을 피하기 위해 계산된 결과를 저장**하여 재사용하는 최적화 기법

**DP는 두 가지 요소로 구성됩니다:**

1. **점화식 (Recurrence Relation)**: 문제의 관계를 나타내는 수학적 표현
   - "무엇을 계산할지"를 정의
   - 예: `F(n) = F(n-1) + F(n-2)`

2. **메모이제이션/타뷸레이션**: 중복 계산을 피하는 구현 기법
   - 계산된 결과를 저장하여 재사용

**DP = 점화식 + 메모이제이션/타뷸레이션**

### 예시: 피보나치 수열

```java
// 점화식: F(n) = F(n-1) + F(n-2)
int[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];  // 점화식 적용 + 결과 저장
}
```

**왜 점화식만으로는 부족한가?**

점화식만 사용하면 같은 값을 여러 번 계산하게 됩니다.  
DP를 사용하면 계산된 값을 저장하여 재사용하므로 중복 계산을 방지할 수 있습니다.

---

## 2️⃣ 언제 사용할까?

DP는 다음 두 가지 조건을 만족할 때 사용합니다:

1. **최적 부분 구조(Optimal Substructure)**: 큰 문제의 최적해가 작은 문제의 최적해로 구성
2. **중복 부분 문제(Overlapping Subproblems)**: 같은 작은 문제가 여러 번 반복

---

## 3️⃣ DP 구현 방법

### 방법 1: 메모이제이션 (Top-Down)

재귀 함수 + 결과 저장

```java
int[] memo = new int[n + 1];

int fibonacci(int n) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];  // 이미 계산된 값 재사용
    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return memo[n];
}
```

**특징:** 재귀 호출, 필요한 값만 계산, 스택 오버플로우 위험

### 방법 2: 타뷸레이션 (Bottom-Up)

반복문 + 순차적 계산

```java
int[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

**특징:** 반복문, 모든 값 계산, 스택 오버플로우 없음 (일반적으로 더 빠름)

---

## 4️⃣ DP 문제 해결 단계

### 1단계: 상태 정의
`dp[i]` 또는 `dp[i][j]`가 무엇을 의미하는지 명확히 정의

**예시:** `dp[i] = i일부터 시작하여 얻을 수 있는 최대 이익`

### 2단계: 점화식 도출
작은 문제의 해를 이용하여 큰 문제의 해를 표현

**예시:** `dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])`

### 3단계: 초기값 설정
가장 작은 문제의 해를 설정

**예시:** `dp[N+1] = 0`

### 4단계: 구현
타뷸레이션 또는 메모이제이션으로 구현

---

## 5️⃣ DP 패턴

### 1차원 DP
```java
int[] dp = new int[n + 1];
dp[0] = 초기값;
for (int i = 1; i <= n; i++) {
    dp[i] = 점화식;
}
```

### 2차원 DP
```java
int[][] dp = new int[n + 1][m + 1];
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = 점화식;
    }
}
```

### 역순 계산
```java
int[] dp = new int[n + 2];
dp[n + 1] = 초기값;
for (int i = n; i >= 1; i--) {
    dp[i] = 점화식;
}
```

---

## 6️⃣ DP vs 다른 알고리즘

| 특징 | DP | 백트래킹/DFS | 분할 정복 | 그리디 |
|------|-----|------------|----------|--------|
| **중복 부분 문제** | 있음 | 있음 (하지만 처리 방식 다름) | 없음 | - |
| **결과 저장** | 필요 (메모이제이션) | 불필요 (상태 되돌리기) | 불필요 | - |
| **중복 계산 처리** | 저장하여 재사용 | 상태를 되돌려서 재탐색 | - | - |
| **탐색 범위** | 모든 경우 | 모든 경우 | - | 현재 최선 |
| **최적해 보장** | 항상 | 항상 | 항상 | 조건부 |
| **시간 복잡도** | O(상태 개수 × 각 상태 처리) | O(경로 개수) | O(N log N) | O(N) |
| **공간 복잡도** | O(상태 개수) - DP 배열 필요 | O(재귀 깊이) - 스택만 사용 | O(N) | O(1) |
| **✅ 적합한 경우** | • 중복 계산이 많은 경우<br/>• 상태 공간이 제한적<br/>• 최적해만 필요<br/>• 점화식 표현 가능 | • 모든 해를 찾아야 함<br/>• 상태 공간이 너무 큼<br/>• 제약 조건이 복잡<br/>• 경로 출력 필요<br/>• 가지치기 효과적 | • 부분 문제가 독립적<br/>• 병렬 처리 가능 | • 탐욕 선택 속성 만족<br/>• 빠른 근사해 필요 |
| **❌ 부적합한 경우** | • 상태 공간이 너무 큼<br/>• 모든 해를 찾아야 함<br/>• 제약 조건이 복잡 | • 중복 계산이 많음<br/>• 상태 공간이 작고 계산 가능 | • 중복 부분 문제 있음 | • 최적해 보장 필요<br/>• 탐욕 선택 속성 불만족 |
| **예시** | 피보나치, 배낭, TSP | N-Queen, 스도쿠, 순열 | 병합 정렬 | 동전 문제 |

### 🔍 DP vs 백트래킹 핵심 차이

**중복 계산 처리 방식:**

**DP (메모이제이션):**
```java
int solve(상태) {
    if (dp[상태] != -1) {
        return dp[상태];  // ✅ 이미 계산된 값 재사용
    }
    dp[상태] = 계산();
    return dp[상태];
}
```

**백트래킹 (상태 되돌리기):**
```java
void backtrack(상태) {
    visited[idx] = true;
    backtrack(다음 상태);
    visited[idx] = false;  // ✅ 상태 되돌려서 재탐색 가능
}
```

**핵심 차이:**
- **DP**: 같은 상태를 **한 번만 계산**하고 결과를 저장하여 재사용
- **백트래킹**: 같은 상태를 **여러 번 계산**할 수 있음 (상태를 되돌려서)

**예시 (TSP 문제):**
- **백트래킹**: O((N-1)!) - 모든 경로를 탐색, 중복 계산 발생
- **DP**: O(N² × 2^N) - 같은 상태를 한 번만 계산, 중복 계산 방지

### 🎯 언제 DP를 선택하고, 언제 백트래킹을 선택할까?

**DP가 더 적합한 경우:**

1. **중복 부분 문제가 많은 경우**
   - 같은 상태가 여러 경로에서 반복 계산됨
   - 예: TSP (외판원 순회), 피보나치, 배낭 문제

2. **상태 공간이 제한적이고 계산 가능한 경우**
   - DP 배열로 저장할 수 있는 범위
   - 예: TSP (N ≤ 16, 상태: N × 2^N)

3. **최적해만 찾으면 되는 경우**
   - 모든 해를 찾을 필요 없음
   - 예: 최소 비용, 최대 이익

4. **점화식으로 표현 가능한 경우**
   - 명확한 상태 전이 관계
   - 예: `dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])`

**백트래킹이 더 적합한 경우:**

1. **모든 해를 찾아야 하는 경우**
   - DP는 최적해만 찾지만, 백트래킹은 모든 해를 찾을 수 있음
   - 예: N-Queen의 모든 해 찾기, 스도쿠의 모든 해 찾기

2. **상태 공간이 너무 커서 DP 배열로 저장하기 어려운 경우**
   - DP 배열 크기가 메모리 제한을 초과
   - 예: 알파벳 문제(1987) - 방문한 알파벳 집합이 2^26이면 너무 큼
   - 백트래킹은 재귀 스택만 사용하므로 공간 효율적

3. **제약 조건이 복잡해서 점화식으로 표현하기 어려운 경우**
   - 복잡한 제약 조건을 가지치기로 쉽게 처리 가능
   - 예: 스도쿠 (각 행/열/박스 체크), N-Queen (대각선 체크)

4. **경로를 출력해야 하는 경우**
   - 백트래킹은 경로를 자연스럽게 추적 가능
   - DP는 최적값만 구하고 경로 복원이 복잡할 수 있음
   - 예: 모든 경로 출력, 특정 조건을 만족하는 경로 찾기

5. **가지치기가 효과적인 경우**
   - 조기 종료 조건이 많아서 실제 탐색 공간이 작음
   - 예: N-Queen (조기 가지치기로 대부분의 경우를 제거)

6. **작은 입력 크기에서 구현이 간단한 경우**
   - 작은 N에서는 백트래킹이 더 직관적이고 구현이 쉬움
   - 예: N ≤ 10인 순열/조합 생성

**구체적인 예시 비교:**

| 문제 유형 | DP | 백트래킹 | 선택 이유 |
|---------|-----|---------|----------|
| **TSP (N ≤ 16)** | ✅ O(N² × 2^N) | ❌ O((N-1)!) | DP: 중복 계산이 많아서 메모이제이션이 효과적 |
| **N-Queen (모든 해 찾기)** | ❌ | ✅ | 백트래킹: 모든 해를 찾아야 하고, 가지치기가 효과적 |
| **알파벳 문제 (1987)** | ❌ (상태 공간 너무 큼) | ✅ | 백트래킹: 상태 공간이 2^26으로 너무 커서 DP 배열 불가 |
| **스도쿠 풀이** | ❌ (점화식 어려움) | ✅ | 백트래킹: 복잡한 제약 조건을 가지치기로 처리 |
| **퇴사 문제 (14501)** | ✅ O(N) | ⚠️ O(2^N) | DP: 중복 계산이 많아서 효율적 |

**결론:**
- **DP**: 중복 계산이 많고 상태 공간이 제한적일 때 → 효율적
- **백트래킹**: 모든 해를 찾거나, 상태 공간이 크거나, 제약 조건이 복잡할 때 → 적합

> **자세한 비교**: [백트래킹 문서](../../graph-traversal/dfs/backtracking/backtracking.md)와 [TSP 문제의 알고리즘 비교](../boj-2098/ALGORITHM_COMPARISON.md)를 참고하세요.

---

## 7️⃣ 실전 팁

1. **상태 정의가 가장 중요**: 명확한 상태 정의가 없으면 점화식을 세울 수 없음
2. **작은 예시로 검증**: N=3, N=4 같은 작은 예시로 점화식이 맞는지 확인
3. **경계 조건 주의**: 배열 인덱스 범위를 항상 확인
4. **타뷸레이션 선호**: 일반적으로 메모이제이션보다 타뷸레이션이 더 빠름

---

## 8️⃣ 정리

동적 계획법은:

1. **최적 부분 구조**와 **중복 부분 문제**를 가진 문제에 적합
2. **점화식 + 메모이제이션/타뷸레이션**으로 구성
3. **상태 정의 → 점화식 → 초기값 → 구현** 순서로 접근
4. 중복 계산을 피하여 효율성을 크게 향상시킴

DP는 처음에는 어려워 보이지만, 패턴을 익히면 다양한 최적화 문제를 효율적으로 해결할 수 있는 강력한 도구입니다.
