# 동적 계획법(Dynamic Programming) 정리

## 1️⃣ 동적 계획법이란?

**동적 계획법(Dynamic Programming, DP)** 이란

> **복잡한 문제를 작은 하위 문제로 나누어 해결**하고,
> **중복 계산을 피하기 위해 계산된 결과를 저장**하여 재사용하는 최적화 기법

**DP는 두 가지 요소로 구성됩니다:**

1. **점화식 (Recurrence Relation)**: 문제의 관계를 나타내는 수학적 표현
   - "무엇을 계산할지"를 정의
   - 예: `F(n) = F(n-1) + F(n-2)`

2. **메모이제이션/타뷸레이션**: 중복 계산을 피하는 구현 기법
   - 계산된 결과를 저장하여 재사용

**DP = 점화식 + 메모이제이션/타뷸레이션**

### 예시: 피보나치 수열

```java
// 점화식: F(n) = F(n-1) + F(n-2)
int[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];  // 점화식 적용 + 결과 저장
}
```

**왜 점화식만으로는 부족한가?**

점화식만 사용하면 같은 값을 여러 번 계산하게 됩니다.  
DP를 사용하면 계산된 값을 저장하여 재사용하므로 중복 계산을 방지할 수 있습니다.

---

## 2️⃣ 언제 사용할까?

DP는 다음 두 가지 조건을 만족할 때 사용합니다:

1. **최적 부분 구조(Optimal Substructure)**: 큰 문제의 최적해가 작은 문제의 최적해로 구성
2. **중복 부분 문제(Overlapping Subproblems)**: 같은 작은 문제가 여러 번 반복

---

## 3️⃣ DP 구현 방법

### 방법 1: 메모이제이션 (Top-Down)

재귀 함수 + 결과 저장

```java
int[] memo = new int[n + 1];

int fibonacci(int n) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];  // 이미 계산된 값 재사용
    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return memo[n];
}
```

**특징:** 재귀 호출, 필요한 값만 계산, 스택 오버플로우 위험

### 방법 2: 타뷸레이션 (Bottom-Up)

반복문 + 순차적 계산

```java
int[] dp = new int[n + 1];
dp[0] = 0;
dp[1] = 1;

for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

**특징:** 반복문, 모든 값 계산, 스택 오버플로우 없음 (일반적으로 더 빠름)

---

## 4️⃣ DP 문제 해결 단계

### 1단계: 상태 정의
`dp[i]` 또는 `dp[i][j]`가 무엇을 의미하는지 명확히 정의

**예시:** `dp[i] = i일부터 시작하여 얻을 수 있는 최대 이익`

### 2단계: 점화식 도출
작은 문제의 해를 이용하여 큰 문제의 해를 표현

**예시:** `dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])`

### 3단계: 초기값 설정
가장 작은 문제의 해를 설정

**예시:** `dp[N+1] = 0`

### 4단계: 구현
타뷸레이션 또는 메모이제이션으로 구현

---

## 5️⃣ DP 패턴

### 1차원 DP
```java
int[] dp = new int[n + 1];
dp[0] = 초기값;
for (int i = 1; i <= n; i++) {
    dp[i] = 점화식;
}
```

### 2차원 DP
```java
int[][] dp = new int[n + 1][m + 1];
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = 점화식;
    }
}
```

### 역순 계산
```java
int[] dp = new int[n + 2];
dp[n + 1] = 초기값;
for (int i = n; i >= 1; i--) {
    dp[i] = 점화식;
}
```

---

## 6️⃣ DP vs 다른 알고리즘

| 특징 | DP | 분할 정복 | 그리디 |
|------|-----|----------|--------|
| 중복 부분 문제 | 있음 | 없음 | - |
| 결과 저장 | 필요 | 불필요 | - |
| 탐색 범위 | 모든 경우 | - | 현재 최선 |
| 최적해 보장 | 항상 | 항상 | 조건부 |
| 예시 | 피보나치, 배낭 | 병합 정렬 | 동전 문제 |

---

## 7️⃣ 실전 팁

1. **상태 정의가 가장 중요**: 명확한 상태 정의가 없으면 점화식을 세울 수 없음
2. **작은 예시로 검증**: N=3, N=4 같은 작은 예시로 점화식이 맞는지 확인
3. **경계 조건 주의**: 배열 인덱스 범위를 항상 확인
4. **타뷸레이션 선호**: 일반적으로 메모이제이션보다 타뷸레이션이 더 빠름

---

## 8️⃣ 정리

동적 계획법은:

1. **최적 부분 구조**와 **중복 부분 문제**를 가진 문제에 적합
2. **점화식 + 메모이제이션/타뷸레이션**으로 구성
3. **상태 정의 → 점화식 → 초기값 → 구현** 순서로 접근
4. 중복 계산을 피하여 효율성을 크게 향상시킴

DP는 처음에는 어려워 보이지만, 패턴을 익히면 다양한 최적화 문제를 효율적으로 해결할 수 있는 강력한 도구입니다.
