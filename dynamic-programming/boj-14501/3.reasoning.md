# Main.java 설계 근거 정리

이 문서는 **BOJ 14501 퇴사 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **동적 계획법 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 동적 계획법 (DP)

### 🔑 DP 사고 과정: 전체 문제를 부분 문제로 나누기

**왜 "i일부터의 최대 이익"이라는 상태 정의를 했을까?**

**핵심 사고 과정:**

1. **목표: 전체 최대 이익 구하기**
   - 문제: "1일부터 N일까지의 최대 이익"
   - 하지만 이것을 한 번에 구하기는 어려움

2. **전략: 부분 문제로 나누기**
   - 전체를 한 번에 구하기 어려우니, **구간/범위/특정 시점으로 제한**
   - "1일부터의 최대 이익" → 너무 크고 복잡
   - "i일부터의 최대 이익" → **특정 시점(i일)부터 시작하는 부분 문제**

3. **부분 문제의 해를 조합하여 전체 문제 해결**
   - `dp[1] = 1일부터의 최대 이익` = 전체 문제의 답
   - `dp[2] = 2일부터의 최대 이익` = 부분 문제
   - `dp[3] = 3일부터의 최대 이익` = 부분 문제
   - ...

**왜 이렇게 접근했는가?**

**전체 최대 이익을 직접 구하려면:**
- 모든 가능한 선택 조합을 고려해야 함
- 1일 선택 → 2일 선택 → 3일 선택 → ... (복잡함)
- 시간 복잡도: O(2^N) - 비효율적
  - **근거**: 깊이별로 2배로 항목이 늘어나는 트리 구조, 항목 하나씩 확인

**부분 문제로 나누면:**
- "i일부터의 최대 이익"이라는 작은 문제로 나눔
- 각 부분 문제는 더 작은 부분 문제의 해를 사용
- 시간 복잡도: O(N) - 효율적
  - **근거**: 리스트의 항목(N개)을 한 번씩만 탐색

**구체적인 예시:**

```
전체 문제: "1일부터 7일까지의 최대 이익"
→ 너무 크고 복잡함

부분 문제로 나누기:
- "7일부터의 최대 이익" → dp[7]
- "6일부터의 최대 이익" → dp[6]
- "5일부터의 최대 이익" → dp[5]
- ...
- "1일부터의 최대 이익" → dp[1] (전체 문제의 답)

각 부분 문제는 더 작은 부분 문제의 해를 사용:
dp[1] = max(dp[2], 10 + dp[4])  // 1일의 선택
dp[2] = max(dp[3], 20 + dp[7])  // 2일의 선택
...
```

**결론:**
- 전체 최대 이익을 직접 구하기 어려우므로
- **특정 시점(i일)부터 시작하는 부분 문제**로 나누어 해결
- 부분 문제의 해를 조합하여 전체 문제 해결
- 이것이 바로 DP의 핵심 사고 과정!

---

### 🔍 다른 접근 방식과의 비교

**상태 정의를 결정할 때, 여러 방식 중에서 왜 `dp[i] = i일부터의 최대 이익`을 선택했을까?**

다른 접근 방식들을 고려해보고 비교해봅시다:

#### 방식 1: `dp[i] = i일까지의 최대 이익` (앞에서부터)

**접근:**
```java
dp[i] = i일까지의 최대 이익
for (int i = 1; i <= N; i++) {
    // i일까지의 최대 이익 계산
}
```

**장점:**
- 직관적: "지금까지의 최대 이익"
- 앞에서부터 계산 (일반적인 DP 패턴)

**단점:**
- ❌ **문제: i일의 선택이 미래에 영향을 주는데, 미래 정보가 없음**
- 예: 1일 상담을 하면 1일~3일 사용, 4일부터 다음 선택 가능
- 하지만 `dp[3] = 3일까지의 최대 이익`을 계산할 때, 1일 상담의 영향(4일부터 가능)을 고려하기 어려움
- 점화식 도출이 복잡함

**예시:**
```
1일 상담 함 → 1일~3일 사용 → 4일부터 다음 선택
하지만 dp[3] = 3일까지의 최대 이익을 계산할 때,
1일 상담이 4일부터에 영향을 준다는 것을 어떻게 표현?
→ 복잡하고 비직관적
```

---

#### 방식 2: `dp[i] = i일 상담을 했을 때의 최대 이익`

**접근:**
```java
dp[i] = i일 상담을 했을 때의 최대 이익
```

**장점:**
- i일 상담을 한 경우만 고려하면 됨

**단점:**
- ❌ **문제: i일 상담을 안 할 수도 있음**
- i일 상담을 안 하는 경우를 별도로 처리해야 함
- 상태 정의가 불완전함 (i일 상담 안 함 경우가 빠짐)
- 두 가지 상태가 필요: `dp[i][0] = 안 함`, `dp[i][1] = 함`
- 복잡도 증가

**예시:**
```
1일 상담 안 함 → 어떻게 표현?
→ 별도 상태 필요: dp[1][0], dp[1][1]
→ 복잡함
```

---

#### 방식 3: `dp[i][j] = i일부터 j일까지의 최대 이익` (2차원)

**접근:**
```java
dp[i][j] = i일부터 j일까지의 최대 이익
```

**장점:**
- 구간을 명확히 정의
- 유연함

**단점:**
- ❌ **문제: 공간 복잡도 O(N²), 시간 복잡도 O(N²)**
- 현재 문제는 O(N)으로 해결 가능한데 비효율적
- 불필요하게 복잡함
- 점화식 도출이 어려움

**예시:**
```
dp[1][7] = 1일부터 7일까지의 최대 이익
→ dp[1][3], dp[4][7] 등 여러 구간을 고려해야 함
→ 복잡하고 비효율적
```

---

#### 방식 4: `dp[i] = i일부터의 최대 이익` (현재 방식) ✅

**접근:**
```java
dp[i] = i일부터 시작하여 얻을 수 있는 최대 이익
for (int i = N; i >= 1; i--) {
    // 역순으로 계산
}
```

**장점:**
- ✅ **i일의 선택이 미래에 영향을 주는 문제에 적합**
- ✅ **점화식이 자연스럽게 도출됨**
  - `dp[i] = max(dp[i+1], P[i] + dp[i+T[i]])`
- ✅ **공간 복잡도 O(N), 시간 복잡도 O(N)**
- ✅ **상태 정의가 간단하고 명확함**
- ✅ **i일 상담 안 함/함 두 경우를 모두 포함**

**단점:**
- 역순 계산이 직관적이지 않을 수 있음 (하지만 문제 특성상 자연스러움)

**예시:**
```
1일의 선택:
- 상담 안 함 → dp[2] (2일부터의 최대 이익)
- 상담 함 → 10 + dp[4] (4일부터의 최대 이익)

dp[1] = max(dp[2], 10 + dp[4])
→ 자연스럽고 직관적!
```

---

### 📊 종합 비교

| 방식 | 공간 복잡도 | 시간 복잡도 | 점화식 도출 | 적합성 |
|------|------------|------------|------------|--------|
| `dp[i] = i일까지의 최대 이익` | O(N) | O(N) | 복잡함 | ❌ |
| `dp[i] = i일 상담을 했을 때` | O(N) | O(N) | 불완전함 | ❌ |
| `dp[i][j] = i일부터 j일까지` | O(N²) | O(N²) | 복잡함 | ❌ |
| `dp[i] = i일부터의 최대 이익` | O(N) | O(N) | 자연스러움 | ✅ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **`dp[i] = i일부터의 최대 이익`이 가장 적합함**
- i일의 선택이 미래에 영향을 주는 문제 특성에 맞음
- 점화식 도출이 자연스럽고 효율적

---

### 알고리즘 선택 근거

이 문제는 **선택의 최적화 문제**로, 동적 계획법이 가장 효율적입니다.

**문제 해석에서 DP로 연결되는 과정:**

> **문제 해석**: [1.analysis.md](./1.analysis.md)에서 이 문제를 "각 날짜마다 상담을 할지 말지 결정하는 문제"로 해석했습니다.

이 해석을 통해 다음을 발견할 수 있습니다:

1. **최적 부분 구조 발견**: 
   - "i일부터의 최대 이익" = max(i일 상담 안 함, i일 상담 함)
   - 이는 DP의 핵심 조건인 "최적 부분 구조"를 만족!

2. **DP로 자연스럽게 연결**:
   - 각 날짜마다 2가지 선택 → 상태 공간 정의 가능
   - 선택의 결과가 다음 상태에 영향 → 점화식 도출 가능

**핵심 특징:**
* 각 날짜마다 상담을 할지 말지 결정 (2가지 선택지)
* 선택의 결과가 다음 날짜들의 선택에 영향
* 최적 부분 구조: i일부터의 최대 이익 = max(i일 상담 안 함, i일 상담 함)
* 중복 부분 문제: 여러 경로에서 같은 날짜의 최적값을 계산
* N ≤ 15이므로 백트래킹도 가능하지만, DP가 더 효율적

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① DP 배열 정의

```java
int[] dp = new int[N + 2];  // dp[i]: i일부터 시작하여 얻을 수 있는 최대 이익
```

* `dp[i]`: i일부터 시작하여 얻을 수 있는 최대 이익
* `dp[N+1] = 0`: 퇴사일 이후에는 이익이 없음
* 배열 크기를 N+2로 설정하여 경계 조건 처리 용이

### ② 역순 계산

**왜 역순으로 계산해야 하는가?**

**점화식 분석:**
```java
dp[i] = max(
    dp[i+1],              // (i+1)일부터의 최대 이익 필요
    P[i] + dp[i+T[i]]     // (i+T[i])일부터의 최대 이익 필요
)
```

**핵심 관찰:**
- dp[i]를 계산하려면 **미래의 값(dp[i+1], dp[i+T[i]])이 필요**
- 앞에서부터 계산하면 필요한 값이 아직 계산되지 않음
- 뒤에서부터 계산하면 필요한 값들이 이미 계산되어 있음

**구체적인 예시:**

**앞에서부터 계산 (문제 발생):**
```
i=1: dp[1] = max(dp[2], 10 + dp[4])
     → dp[2], dp[4]가 아직 계산되지 않음! ❌

i=2: dp[2] = max(dp[3], 20 + dp[7])
     → dp[3], dp[7]가 아직 계산되지 않음! ❌
```

**뒤에서부터 계산 (정상 동작):**
```
i=7: dp[7] = max(dp[8], ...)
     → dp[8] = 0 (초기값) ✓

i=6: dp[6] = max(dp[7], ...)
     → dp[7]는 이미 계산됨 ✓

i=5: dp[5] = max(dp[6], 15 + dp[7])
     → dp[6], dp[7]는 이미 계산됨 ✓

...

i=1: dp[1] = max(dp[2], 10 + dp[4])
     → dp[2], dp[4]는 이미 계산됨 ✓
```


### ③ 점화식 구현 (선택 문제 해석에서 도출)

**"각 날짜마다 선택" 해석이 점화식으로 이어지는 과정:**

```java
// i일의 선택: 상담 안 함 vs 상담 함

// 선택 1: i일 상담 안 함
dp[i] = dp[i + 1];  // (i+1)일부터의 최대 이익

// 선택 2: i일 상담 함 (조건: N일 이내에 끝나는지 확인)
if (i + T[i] - 1 <= N) {
    dp[i] = Math.max(dp[i], P[i] + dp[i + T[i]]);
    // P[i]원 획득 + (i+T[i])일부터의 최대 이익
}
```

**점화식의 의미:**
1. **dp[i] = dp[i+1]**: i일의 상담을 하지 않으면, (i+1)일부터의 최대 이익과 같음
   - "i일 상담 안 함" 선택의 결과

2. **dp[i] = max(dp[i], P[i] + dp[i+T[i]])**: i일의 상담을 하면, P[i]의 이익 + (i+T[i])일부터의 최대 이익
   - "i일 상담 함" 선택의 결과
   - 상담을 하면 Ti일 동안 다른 상담 불가 → (i+T[i])일부터 다음 선택 가능

**경계 조건:**
* `i + T[i] - 1 <= N`: i일의 상담이 N일 이내에 끝나는지 확인
* N일 이후에 끝나는 상담은 할 수 없음 (퇴사일 제약)

---

## 3️⃣ 날짜 인덱스 처리

### 상담 기간 계산

```java
if (i + T[i] - 1 <= N) {
    // 상담 가능
}
```

**핵심 이해:**
* i일의 상담은 i일부터 시작하여 T[i]일 동안 진행
* 상담이 끝나는 날짜: i + T[i] - 1일
* 다음 상담 가능 날짜: i + T[i]일

**예시:**
* 1일 상담 (T[1] = 3): 1일, 2일, 3일 사용 → 4일부터 다음 상담 가능
* `i + T[i] = 1 + 3 = 4` ✓

---

## 4️⃣ DP의 최적 부분 구조

### 최적 부분 구조의 의미

i일부터의 최대 이익은 다음 두 경우 중 큰 값:
1. i일 상담 안 함 → (i+1)일부터의 최대 이익
2. i일 상담 함 → P[i] + (i+T[i])일부터의 최대 이익

이 두 경우 모두 더 작은 문제의 최적값을 사용하므로, 최적 부분 구조를 만족합니다.

> **실제 계산 과정**: [2.algorithm.md](./2.algorithm.md)의 "실제 계산 과정 (N=7 예시)" 섹션을 참고하세요.

---

## 5️⃣ 백트래킹과의 비교

### 백트래킹 접근

```java
static void backtrack(int day, int profit) {
    if (day > N) {
        maxProfit = Math.max(maxProfit, profit);
        return;
    }
    
    // 상담 안 함
    backtrack(day + 1, profit);
    
    // 상담 함
    if (day + T[day] - 1 <= N) {
        backtrack(day + T[day], profit + P[day]);
    }
}
```

**시간 복잡도: `O(2^N)`**

**근거:**
- **깊이별로 2배로 항목이 늘어나는 트리**: 각 날짜마다 2가지 선택지(상담 안 함/함)
- **항목 하나씩 확인**: 모든 가능한 선택 조합을 탐색
- **트리 구조**:
  ```
  깊이 0 (루트): 1개 노드
  깊이 1 (1일 선택): 2개 노드 (안 함/함)
  깊이 2 (2일 선택): 4개 노드 (2×2)
  깊이 3 (3일 선택): 8개 노드 (2×2×2)
  ...
  깊이 N: 2^N개 노드
  ```
- **전체 시간**: 모든 노드를 탐색하므로 O(2^N)

**특징:**
* 모든 경우를 탐색
* 구현이 간단하지만 비효율적

### DP 접근

```java
for (int i = N; i >= 1; i--) {
    dp[i] = dp[i + 1];
    if (i + T[i] - 1 <= N) {
        dp[i] = Math.max(dp[i], P[i] + dp[i + T[i]]);
    }
}
```

**시간 복잡도: `O(N)`**

**근거:**
- **리스트의 항목 한 번씩 탐색**: N개의 날짜(1일부터 N일까지)를 각각 한 번씩만 처리
- **각 날짜 처리 시간**: O(1) (조건 체크, max 계산 모두 상수 시간)
- **전체 시간**: N개 항목 × O(1) = O(N)

**특징:**
* 중복 계산을 피함
* 더 효율적이고 일반적인 해법

**비교:**
- **백트래킹**: 모든 가능한 선택 조합을 탐색 → O(2^N)
- **DP**: 각 날짜를 한 번씩만 처리하고 결과를 재사용 → O(N)
- **효율성 차이**: N=15일 때, 백트래킹은 약 32,768번 계산, DP는 15번 계산

---

## 6️⃣ 시간/공간 복잡도와 코드의 대응

> **시간/공간 복잡도 분석**: [2.algorithm.md](./2.algorithm.md)의 시간/공간 복잡도 섹션을 참고하세요.

**코드와의 대응:**
- 시간 복잡도 O(N): `for (int i = N; i >= 1; i--)` 루프가 N번 실행
- 공간 복잡도 O(N): `int[] dp = new int[N + 2]` 배열 사용

---

## 7️⃣ 다른 접근 방법과의 비교

### 방법 1: 동적 계획법 (현재 방법) ✅

**장점:**
* 시간 복잡도 O(N)으로 매우 효율적
  - **근거**: 리스트의 항목(N개)을 한 번씩만 탐색
* 구현이 간단하고 직관적
* 일반적인 해법

**단점:**
* 없음 (이 문제에 가장 적합)

### 방법 2: 백트래킹

**장점:**
* 구현이 간단
* 모든 경우를 탐색하므로 이해하기 쉬움

**단점:**
* 시간 복잡도 O(2^N)으로 비효율적
  - **근거**: 깊이별로 2배로 항목이 늘어나는 트리 구조, 항목 하나씩 확인
* N이 커지면 시간 초과 가능

### 방법 3: 그리디 알고리즘

**단점:**
* 이 문제는 그리디로 해결할 수 없음
* 각 상담의 기간과 이익이 독립적이므로, 단순히 이익/기간 비율로 선택할 수 없음

➡️ **동적 계획법이 이 문제에 가장 적합한 방법이다.**

---

## 8️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **시간 효율적**: O(N) 시간 복잡도

### 추가 최적화 가능성

* 공간 최적화: dp 배열을 1차원으로 유지 (이미 최적)
* 입력 최적화: BufferedReader 사용 (이미 사용 중)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **선택 최적화 구조**를 동적 계획법으로 모델링하고
* 알고리즘 문서에서 설명한 **최적 부분 구조**를 그대로 활용하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **효율성**: O(N) 시간 복잡도로 최적화
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
4. **간결성**: 불필요한 복잡성 없이 핵심만 구현
