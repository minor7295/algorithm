# Main.java 설계 근거 정리

## 1️⃣ 알고리즘 선택 근거: 동적 계획법 (DP)

### 🔑 DP 사고 과정: 규칙 발견을 통한 점화식 도출

**왜 "마지막에 더한 수로 분류"라는 상태 정의를 했을까?**

**핵심 사고 과정:**

1. **목표: n을 1, 2, 3의 합으로 나타내는 방법의 수 구하기**
   - 문제: "n을 1, 2, 3의 합으로 나타내는 방법의 수"
   - 하지만 이것을 직접 세기는 어려움 (n이 커질수록 경우의 수가 많아짐)

2. **전략: 규칙 발견을 통한 점화식 도출**
   - 작은 예시를 나열하여 규칙을 발견
   - "마지막에 더한 수로 분류"하면 규칙이 보임
   - 규칙을 점화식으로 표현

3. **부분 문제의 해를 조합하여 전체 문제 해결**
   - `dp[i]` = i를 1, 2, 3의 합으로 나타내는 방법의 수
   - `dp[i] = dp[i-3] + dp[i-2] + dp[i-1]`

**왜 이렇게 접근했는가?**

**브루트 포스 방법:**
- 모든 가능한 조합을 생성하고 확인
- 시간 복잡도: O(3^n) - 비효율적
  - **근거**: 깊이별로 3배로 항목이 늘어나는 트리 구조, 항목 하나씩 확인

**점화식으로 해결:**
- 작은 예시로 규칙 발견
- 규칙을 점화식으로 표현
- 시간 복잡도: O(N) - 효율적
  - **근거**: 리스트의 항목(n개)을 한 번씩만 탐색

**구체적인 예시:**

```
브루트 포스:
→ n=4인 경우 모든 조합 생성: 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1
→ 시간 복잡도: O(3^n) - n이 커지면 매우 느림

규칙 발견:
→ 마지막에 1을 더함: (n-1)을 만드는 방법에 1을 더함
→ 마지막에 2를 더함: (n-2)를 만드는 방법에 2를 더함
→ 마지막에 3을 더함: (n-3)을 만드는 방법에 3을 더함

점화식:
→ dp[n] = dp[n-3] + dp[n-2] + dp[n-1]
```

**결론:**
- 브루트 포스는 비효율적이므로
- **규칙을 발견하여 점화식으로 표현**
- 부분 문제의 해를 조합하여 전체 문제 해결
- 이것이 바로 DP의 핵심 사고 과정!

---

### 🔍 다른 접근 방식과의 비교

**상태 정의를 결정할 때, 여러 방식 중에서 왜 `dp[i]`를 선택했을까?**

다른 접근 방식들을 고려해보고 비교해봅시다:

#### 방식 1: `dp[i] = i를 만드는 방법의 수` (현재 방식) ✅

**접근:**
```java
dp[i] = i를 1, 2, 3의 합으로 나타내는 방법의 수
```

**장점:**
- ✅ **간단하고 직관적**
- ✅ **점화식 도출이 자연스러움**
- ✅ **공간 복잡도 O(N), 시간 복잡도 O(N)**

**단점:**
- 없음 (이 문제에 가장 적합)

**예시:**
```
dp[1] = 1
dp[2] = 2
dp[3] = 4
dp[4] = dp[1] + dp[2] + dp[3] = 1 + 2 + 4 = 7

→ 자연스럽고 직관적!
```

---

#### 방식 2: `dp[i][j] = i를 만드는 방법 중 마지막에 j를 더한 경우의 수` (2차원)

**접근:**
```java
dp[i][1] = i를 만드는 방법 중 마지막에 1을 더한 경우의 수
dp[i][2] = i를 만드는 방법 중 마지막에 2를 더한 경우의 수
dp[i][3] = i를 만드는 방법 중 마지막에 3을 더한 경우의 수
```

**장점:**
- 마지막에 더한 수 정보를 명확히 저장

**단점:**
- ❌ **불필요하게 복잡함**
- ❌ **공간 복잡도 O(3N)으로 증가**
- ❌ **이 문제에서는 마지막에 더한 수를 구분할 필요가 없음**

**예시:**
```
dp[4][1] = dp[3][1] + dp[3][2] + dp[3][3] = 2 + 1 + 1 = 4
dp[4][2] = dp[2][1] + dp[2][2] = 1 + 1 = 2
dp[4][3] = dp[1][1] + dp[1][2] + dp[1][3] = 1 + 0 + 0 = 1
총: 4 + 2 + 1 = 7

→ 복잡하고 불필요함!
```

---

### 📊 종합 비교

| 방식 | 공간 복잡도 | 시간 복잡도 | 점화식 도출 | 적합성 |
|------|------------|------------|------------|--------|
| `dp[i] = 방법의 수` | O(N) | O(N) | 자연스러움 | ✅ |
| `dp[i][j] = 마지막에 j를 더한 경우` | O(3N) | O(N) | 복잡함 | ❌ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **`dp[i]` 1차원 배열이 가장 간결하고 명확함**
- 마지막에 더한 수를 구분할 필요가 없으므로 1차원으로 충분

---

### 알고리즘 선택 근거

이 문제는 **점화식 문제**로, 동적 계획법이 가장 효율적입니다.

**문제 해석에서 DP로 연결되는 과정:**

> **문제 해석**: [1.analysis.md](./1.analysis.md)에서 이 문제를 "마지막에 더한 수로 분류"하여 규칙을 발견했습니다.

이 해석을 통해 다음을 발견할 수 있습니다:

1. **최적 부분 구조 발견**: 
   - "i를 만드는 방법의 수" = (i-3), (i-2), (i-1)을 만드는 방법의 수로 표현 가능
   - 이는 DP의 핵심 조건인 "최적 부분 구조"를 만족!

2. **DP로 자연스럽게 연결**:
   - 작은 문제의 해를 이용하여 큰 문제의 해를 표현
   - 점화식으로 명확히 표현 가능

**핵심 특징:**
* 작은 예시로 규칙 발견 가능
* 규칙이 점화식으로 명확히 표현됨
* 최적 부분 구조: i를 만드는 방법의 수 = (i-3), (i-2), (i-1)을 만드는 방법의 수로 표현
* 중복 부분 문제: 같은 값을 만드는 방법의 수를 여러 번 계산
* n < 11이므로 O(N) 시간 복잡도로 효율적

---

## 3️⃣ 자료형 선택: int 타입

### 왜 int를 사용하는가?

이 문제는 n < 11이므로 값이 작습니다.

**실제 값:**
- dp[1] = 1
- dp[2] = 2
- dp[3] = 4
- dp[4] = 7
- dp[5] = 13
- dp[6] = 24
- dp[7] = 44
- dp[8] = 81
- dp[9] = 149
- dp[10] = 274

**Java 정수 타입 범위:**
- `int`: -2,147,483,648 ~ 2,147,483,647 (약 -21억 ~ 21억)
- `long`: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 -9경 ~ 9경)

**결론:**
- n < 11이므로 최대값이 274로 매우 작음
- `int` 타입으로 충분

---

## 4️⃣ DP의 최적 부분 구조

### 최적 부분 구조의 의미

i를 1, 2, 3의 합으로 나타내는 방법의 수는 다음으로 표현됩니다:
1. 마지막에 1을 더한 경우: (i-1)을 만드는 방법의 수
2. 마지막에 2를 더한 경우: (i-2)를 만드는 방법의 수
3. 마지막에 3을 더한 경우: (i-3)을 만드는 방법의 수

이 세 가지 경우 모두 더 작은 문제의 해를 사용하므로, 최적 부분 구조를 만족합니다.
하세요.

---

## 5️⃣ 점화식의 직관적 이해

### 왜 이 점화식이 성립하는가?

n을 만드는 방법은 반드시 마지막에 1, 2, 또는 3 중 하나를 더한 것입니다.

**핵심 관찰:**
- 마지막에 1을 더한 경우: (n-1)을 만드는 모든 방법에 1을 더하면 됨 → `dp[n-1]`가지
- 마지막에 2를 더한 경우: (n-2)를 만드는 모든 방법에 2를 더하면 됨 → `dp[n-2]`가지
- 마지막에 3을 더한 경우: (n-3)을 만드는 모든 방법에 3을 더하면 됨 → `dp[n-3]`가지

이 세 가지 경우는 서로 겹치지 않고, 모든 경우를 포함하므로:
```
dp[n] = dp[n-3] + dp[n-2] + dp[n-1]
```

**구체적인 예시 (n=4):**

```
n=4를 만드는 방법:
  - 마지막에 1을 더함: (3을 만드는 방법에 1을 더함)
    1+1+1+1 (1+1+1에 1을 더함)
    1+2+1 (1+2에 1을 더함)
    2+1+1 (2+1에 1을 더함)
    3+1 (3에 1을 더함)
    → dp[3] = 4가지

  - 마지막에 2를 더함: (2를 만드는 방법에 2를 더함)
    1+1+2 (1+1에 2를 더함)
    2+2 (2에 2를 더함)
    → dp[2] = 2가지

  - 마지막에 3을 더함: (1을 만드는 방법에 3을 더함)
    1+3 (1에 3을 더함)
    → dp[1] = 1가지

  총: dp[1] + dp[2] + dp[3] = 1 + 2 + 4 = 7가지 ✅
```

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 동적 계획법 (현재 방법) ✅

**장점:**
* 시간 복잡도 O(N)으로 매우 효율적
  - **근거**: 리스트의 항목(n개)을 한 번씩만 탐색
* 구현이 간단하고 직관적
* 일반적인 해법

**단점:**
* 없음 (이 문제에 가장 적합)

### 방법 2: 브루트 포스 (재귀)

**장점:**
* 구현이 간단
* 모든 경우를 탐색하므로 이해하기 쉬움

**단점:**
* 시간 복잡도 O(3^N)으로 비효율적
  - **근거**: 깊이별로 3배로 항목이 늘어나는 트리 구조, 항목 하나씩 확인
* n이 커지면 시간 초과 가능

### 방법 3: 메모이제이션 (재귀 + DP)

**장점:**
* 재귀적 사고가 자연스러움
* 시간 복잡도 O(N)으로 효율적

**단점:**
* 반복문보다 약간 느림 (함수 호출 오버헤드)
* 스택 오버플로우 가능성 (하지만 n < 11이므로 문제 없음)

➡️ **동적 계획법이 이 문제에 가장 적합한 방법이다.**
