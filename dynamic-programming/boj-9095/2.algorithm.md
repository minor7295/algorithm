# 알고리즘: 동적 계획법

> 📖 **전체 알고리즘 설명**: [동적 계획법(Dynamic Programming) 정리](../dynamic-programming.md)

이 문제는 **동적 계획법(DP)**을 사용하여 해결합니다.  
상위 폴더의 [동적 계획법 정리 문서](../dynamic-programming.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## DP 알고리즘 개요

마지막에 더한 수(1, 2, 또는 3)로 분류하여 각각의 개수를 계산합니다.

### 핵심 아이디어

**🔑 핵심 노하우: 마지막에 더한 수로 분류하기**

이 문제를 풀기 위한 가장 중요한 포인트는 **"n을 만드는 방법을 마지막에 더한 수(1, 2, 또는 3)로 분류"**하는 것입니다.

**작은 예시로 규칙 찾기:**

```
n = 1: 1
  → 마지막에 1을 더함: 1개

n = 2: 1+1, 2
  → 마지막에 1을 더함: 1개 (1+1)
  → 마지막에 2를 더함: 1개 (2)
  → 총 2개

n = 3: 1+1+1, 1+2, 2+1, 3
  → 마지막에 1을 더함: 2개 (1+1+1, 2+1)
  → 마지막에 2를 더함: 1개 (1+2)
  → 마지막에 3을 더함: 1개 (3)
  → 총 4개

n = 4: 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1
  → 마지막에 1을 더함: 4개 (1+1+1+1, 1+2+1, 2+1+1, 3+1)
  → 마지막에 2를 더함: 2개 (1+1+2, 2+2)
  → 마지막에 3을 더함: 1개 (1+3)
  → 총 7개
```

**규칙 발견:**

* **n을 만드는 방법 중 마지막에 1을 더한 경우**: (n-1)을 만드는 방법에 1을 더함
  - `dp[n] += dp[n-1]`

* **n을 만드는 방법 중 마지막에 2를 더한 경우**: (n-2)를 만드는 방법에 2를 더함
  - `dp[n] += dp[n-2]`

* **n을 만드는 방법 중 마지막에 3을 더한 경우**: (n-3)을 만드는 방법에 3을 더함
  - `dp[n] += dp[n-3]`

1. **상태 정의**: 
   - `dp[i]` = i를 1, 2, 3의 합으로 나타내는 방법의 수

2. **점화식 도출**:
   
   **점화식:**
   ```
   dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
   ```
   
   **점화식의 의미:**
   - **dp[i-3]**: (i-3)을 만드는 방법에 3을 더하면 i가 됨
   - **dp[i-2]**: (i-2)를 만드는 방법에 2를 더하면 i가 됨
   - **dp[i-1]**: (i-1)을 만드는 방법에 1을 더하면 i가 됨
   - 이 세 가지 경우를 모두 합하면 i를 만드는 모든 방법의 수가 됨

3. **초기값**: 
   ```
   dp[1] = 1  (1 = 1)
   dp[2] = 2  (2 = 1+1, 2)
   dp[3] = 4  (3 = 1+1+1, 1+2, 2+1, 3)
   ```

---

## 구현 패턴

**구체적인 예시로 이해하기:**

```java
int[] dp = new int[11];  // n < 11이므로 크기 11로 충분

// 초기값
dp[1] = 1;
dp[2] = 2;
dp[3] = 4;

// 점화식 적용
for (int i = 4; i <= 10; i++) {
    dp[i] = dp[i-3] + dp[i-2] + dp[i-1];
}
```

---

**실제 계산 과정 (n=4 예시):**

```
초기값:
dp[1] = 1
dp[2] = 2
dp[3] = 4

i=4:
  dp[4] = dp[1] + dp[2] + dp[3]
        = 1 + 2 + 4
        = 7

검증:
n=4를 만드는 방법:
  - 마지막에 1을 더함: (3을 만드는 방법에 1을 더함) = 4가지
    1+1+1+1, 1+2+1, 2+1+1, 3+1
  - 마지막에 2를 더함: (2를 만드는 방법에 2를 더함) = 2가지
    1+1+2, 2+2
  - 마지막에 3을 더함: (1을 만드는 방법에 3을 더함) = 1가지
    1+3
  총: 4 + 2 + 1 = 7가지 ✅
```

---

**실제 계산 과정 (n=7 예시):**

```
초기값:
dp[1] = 1
dp[2] = 2
dp[3] = 4

i=4:
  dp[4] = dp[1] + dp[2] + dp[3] = 1 + 2 + 4 = 7

i=5:
  dp[5] = dp[2] + dp[3] + dp[4] = 2 + 4 + 7 = 13

i=6:
  dp[6] = dp[3] + dp[4] + dp[5] = 4 + 7 + 13 = 24

i=7:
  dp[7] = dp[4] + dp[5] + dp[6] = 7 + 13 + 24 = 44

답: dp[7] = 44 ✅
```

---

## 시간 복잡도

**전체 시간 복잡도: `O(N)`**

**근거:**
- **리스트의 항목 한 번씩 탐색**: n개의 값(1부터 n까지)을 각각 한 번씩만 처리
- **각 값 처리 시간**: O(1) (덧셈 연산은 상수 시간)
- **전체 시간**: n개 항목 × O(1) = O(N)

**구체적인 계산:**
```
for (int i = 4; i <= n; i++) {  // 최대 (n-3)번 반복
    dp[i] = dp[i-3] + dp[i-2] + dp[i-1];  // O(1)
}
// 총 시간: (n-3) × O(1) = O(n)
```

**상태 개수:**
* n개 (dp[1..n])

**각 상태 처리 시간:**
* O(1) (상수 시간)

---

## 공간 복잡도

* **DP 배열**: O(N) (dp 배열 n개)
* **전체 공간 복잡도**: **O(N)**

**참고:** n < 11이므로 실제로는 O(1)로 볼 수도 있지만, 일반적인 경우를 고려하면 O(N)입니다.

---

## 이 문제의 특이사항

### 1️⃣ 점화식의 직관적 이해

**왜 이 점화식이 성립하는가?**

n을 만드는 방법은 반드시 마지막에 1, 2, 또는 3 중 하나를 더한 것입니다.

- 마지막에 1을 더한 경우: (n-1)을 만드는 모든 방법에 1을 더하면 됨 → `dp[n-1]`가지
- 마지막에 2를 더한 경우: (n-2)를 만드는 모든 방법에 2를 더하면 됨 → `dp[n-2]`가지
- 마지막에 3을 더한 경우: (n-3)을 만드는 모든 방법에 3을 더하면 됨 → `dp[n-3]`가지

이 세 가지 경우는 서로 겹치지 않고, 모든 경우를 포함하므로:
```
dp[n] = dp[n-3] + dp[n-2] + dp[n-1]
```

### 2️⃣ 초기값의 중요성

초기값 `dp[1]`, `dp[2]`, `dp[3]`은 직접 계산해야 합니다. 이 값들이 없으면 점화식을 적용할 수 없습니다.

**초기값 계산:**
- `dp[1] = 1`: 1 = 1 (1가지)
- `dp[2] = 2`: 2 = 1+1, 2 (2가지)
- `dp[3] = 4`: 3 = 1+1+1, 1+2, 2+1, 3 (4가지)

