# 알고리즘: 동적 계획법

> 📖 **전체 알고리즘 설명**: [동적 계획법(Dynamic Programming) 정리](../dynamic-programming.md)

이 문제는 **동적 계획법(DP)**을 사용하여 해결합니다.  
상위 폴더의 [동적 계획법 정리 문서](../dynamic-programming.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## DP 알고리즘 개요

마지막에 추가한 타일의 종류로 분류하여 각각의 개수를 계산합니다.

### 핵심 아이디어

**🔑 핵심 노하우: 마지막에 추가한 타일로 분류하기**

이 문제를 풀기 위한 가장 중요한 포인트는 **"2×n을 채우는 방법을 마지막에 추가한 타일(세로 1개 또는 가로 2개)로 분류"**하는 것입니다.

**작은 예시로 규칙 찾기:**

```
n = 1: 
  → 세로 타일 1개 추가: 1개
  → 총 1개

n = 2:
  → 세로 타일 1개 추가: 1개 (n=1에서 세로 타일 1개 추가)
  → 가로 타일 2개 추가: 1개 (n=0에서 가로 타일 2개 추가)
  → 총 2개

n = 3:
  → 세로 타일 1개 추가: 2개 (n=2에서 세로 타일 1개 추가)
  → 가로 타일 2개 추가: 1개 (n=1에서 가로 타일 2개 추가)
  → 총 3개

n = 4:
  → 세로 타일 1개 추가: 3개 (n=3에서 세로 타일 1개 추가)
  → 가로 타일 2개 추가: 2개 (n=2에서 가로 타일 2개 추가)
  → 총 5개
```

**규칙 발견:**

* **2×n을 채우는 방법 중 마지막에 세로 타일 1개를 추가한 경우**: 2×(n-1)을 채우는 방법에 세로 타일 1개를 추가
  - `dp[n] += dp[n-1]`

* **2×n을 채우는 방법 중 마지막에 가로 타일 2개를 추가한 경우**: 2×(n-2)를 채우는 방법에 가로 타일 2개를 추가
  - `dp[n] += dp[n-2]`

1. **상태 정의**: 
   - `dp[i]` = 2×i 크기의 직사각형을 채우는 방법의 수

2. **점화식 도출**:
   
   **점화식:**
   ```
   dp[i] = dp[i-1] + dp[i-2]
   ```
   
   **점화식의 의미:**
   - **dp[i-1]**: 2×(i-1)을 채우는 방법에 세로 타일(2×1) 1개를 추가하면 2×i가 됨
   - **dp[i-2]**: 2×(i-2)를 채우는 방법에 가로 타일(1×2) 2개를 추가하면 2×i가 됨
   - 이 두 가지 경우를 모두 합하면 2×i를 채우는 모든 방법의 수가 됨

3. **초기값**: 
   ```
   dp[1] = 1  (2×1: 세로 타일 1개)
   dp[2] = 2  (2×2: 세로 타일 2개 또는 가로 타일 2개)
   ```

---

## 구현 패턴

**구체적인 예시로 이해하기:**

```java
int[] dp = new int[n + 1];

// 초기값
dp[1] = 1;
if (n >= 2) {
    dp[2] = 2;
}

// 점화식 적용
for (int i = 3; i <= n; i++) {
    dp[i] = (dp[i-1] + dp[i-2]) % 10007;
}
```

---

**실제 계산 과정 (n=4 예시):**

```
초기값:
dp[1] = 1
dp[2] = 2

i=3:
  dp[3] = dp[2] + dp[1]
        = 2 + 1
        = 3

i=4:
  dp[4] = dp[3] + dp[2]
        = 3 + 2
        = 5

검증:
2×4를 채우는 방법:
  - 마지막에 세로 타일 1개 추가: (2×3을 채우는 방법에 세로 타일 1개 추가) = 3가지
  - 마지막에 가로 타일 2개 추가: (2×2를 채우는 방법에 가로 타일 2개 추가) = 2가지
  총: 3 + 2 = 5가지 ✅
```

---

**실제 계산 과정 (n=9 예시):**

```
초기값:
dp[1] = 1
dp[2] = 2

i=3: dp[3] = dp[2] + dp[1] = 2 + 1 = 3
i=4: dp[4] = dp[3] + dp[2] = 3 + 2 = 5
i=5: dp[5] = dp[4] + dp[3] = 5 + 3 = 8
i=6: dp[6] = dp[5] + dp[4] = 8 + 5 = 13
i=7: dp[7] = dp[6] + dp[5] = 13 + 8 = 21
i=8: dp[8] = dp[7] + dp[6] = 21 + 13 = 34
i=9: dp[9] = dp[8] + dp[7] = 34 + 21 = 55

답: dp[9] = 55 ✅
```

---

## 시간 복잡도

**전체 시간 복잡도: `O(N)`**

**근거:**
- **리스트의 항목 한 번씩 탐색**: n개의 값(3부터 n까지)을 각각 한 번씩만 처리
- **각 값 처리 시간**: O(1) (덧셈 연산은 상수 시간)
- **전체 시간**: n개 항목 × O(1) = O(N)

**구체적인 계산:**
```
for (int i = 3; i <= n; i++) {  // 최대 (n-2)번 반복
    dp[i] = (dp[i-1] + dp[i-2]) % 10007;  // O(1)
}
// 총 시간: (n-2) × O(1) = O(n)
```

**상태 개수:**
* n개 (dp[1..n])

**각 상태 처리 시간:**
* O(1) (상수 시간)

---

## 공간 복잡도

* **DP 배열**: O(N) (dp 배열 n개)
* **전체 공간 복잡도**: **O(N)**

---

## 이 문제의 특이사항

### 1️⃣ 점화식의 직관적 이해

**왜 이 점화식이 성립하는가?**

2×n을 채우는 방법은 반드시 마지막에 세로 타일 1개 또는 가로 타일 2개 중 하나를 추가한 것입니다.

- 마지막에 세로 타일 1개를 추가한 경우: 2×(n-1)을 채우는 모든 방법에 세로 타일 1개를 추가하면 됨 → `dp[n-1]`가지
- 마지막에 가로 타일 2개를 추가한 경우: 2×(n-2)를 채우는 모든 방법에 가로 타일 2개를 추가하면 됨 → `dp[n-2]`가지

이 두 가지 경우는 서로 겹치지 않고, 모든 경우를 포함하므로:
```
dp[n] = dp[n-1] + dp[n-2]
```

### 2️⃣ 피보나치 수열과의 관계

이 문제의 점화식은 피보나치 수열과 동일합니다:
- F(1) = 1
- F(2) = 2
- F(n) = F(n-1) + F(n-2) (n ≥ 3)

다만 초기값이 다릅니다:
- 피보나치: F(1) = 1, F(2) = 1
- 이 문제: dp[1] = 1, dp[2] = 2

### 3️⃣ 모듈로 연산의 중요성

n이 최대 1,000이므로 값이 매우 커질 수 있습니다. 따라서 매번 10,007로 나눈 나머지를 저장해야 오버플로우를 방지할 수 있습니다.

