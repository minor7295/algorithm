# Main.java 설계 근거 정리

## 1️⃣ 알고리즘 선택 근거: 동적 계획법 (DP)

### 🔑 DP 사고 과정: 규칙 발견을 통한 점화식 도출

**왜 "마지막에 추가한 타일로 분류"라는 상태 정의를 했을까?**

**핵심 사고 과정:**

1. **목표: 2×n을 채우는 방법의 수 구하기**
   - 문제: "2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수"
   - 하지만 이것을 직접 세기는 어려움 (n이 커질수록 경우의 수가 많아짐)

2. **전략: 규칙 발견을 통한 점화식 도출**
   - 작은 예시를 나열하여 규칙을 발견
   - "마지막에 추가한 타일로 분류"하면 규칙이 보임
   - 규칙을 점화식으로 표현

3. **부분 문제의 해를 조합하여 전체 문제 해결**
   - `dp[i]` = 2×i를 채우는 방법의 수
   - `dp[i] = dp[i-1] + dp[i-2]`

**왜 이렇게 접근했는가?**

**브루트 포스 방법:**
- 모든 가능한 타일 배치를 생성하고 확인
- 시간 복잡도: O(2^n) - 비효율적
  - **근거**: 각 위치마다 2가지 선택(세로 타일 또는 가로 타일), n개 위치를 확인

**점화식으로 해결:**
- 작은 예시로 규칙 발견
- 규칙을 점화식으로 표현
- 시간 복잡도: O(N) - 효율적
  - **근거**: 리스트의 항목(n개)을 한 번씩만 탐색

**구체적인 예시:**

```
브루트 포스:
→ n=4인 경우 모든 타일 배치 생성
→ 시간 복잡도: O(2^n) - n이 커지면 매우 느림

규칙 발견:
→ 마지막에 세로 타일 1개 추가: (n-1)을 채우는 방법에 세로 타일 1개 추가
→ 마지막에 가로 타일 2개 추가: (n-2)를 채우는 방법에 가로 타일 2개 추가

점화식:
→ dp[n] = dp[n-1] + dp[n-2]
```

**결론:**
- 브루트 포스는 비효율적이므로
- **규칙을 발견하여 점화식으로 표현**
- 부분 문제의 해를 조합하여 전체 문제 해결
- 이것이 바로 DP의 핵심 사고 과정!

---

### 🔍 다른 접근 방식과의 비교

**상태 정의를 결정할 때, 여러 방식 중에서 왜 `dp[i]`를 선택했을까?**

다른 접근 방식들을 고려해보고 비교해봅시다:

#### 방식 1: `dp[i] = 2×i를 채우는 방법의 수` (현재 방식) ✅

**접근:**
```java
dp[i] = 2×i 크기의 직사각형을 채우는 방법의 수
```

**장점:**
- ✅ **간단하고 직관적**
- ✅ **점화식 도출이 자연스러움**
- ✅ **공간 복잡도 O(N), 시간 복잡도 O(N)**

**단점:**
- 없음 (이 문제에 가장 적합)

**예시:**
```
dp[1] = 1
dp[2] = 2
dp[3] = dp[2] + dp[1] = 2 + 1 = 3
dp[4] = dp[3] + dp[2] = 3 + 2 = 5

→ 자연스럽고 직관적!
```

---

#### 방식 2: `dp[i][j] = 2×i를 채우는 방법 중 마지막에 j 타일을 추가한 경우의 수` (2차원)

**접근:**
```java
dp[i][0] = 2×i를 채우는 방법 중 마지막에 세로 타일 1개를 추가한 경우의 수
dp[i][1] = 2×i를 채우는 방법 중 마지막에 가로 타일 2개를 추가한 경우의 수
```

**장점:**
- 마지막에 추가한 타일 정보를 명확히 저장

**단점:**
- ❌ **불필요하게 복잡함**
- ❌ **공간 복잡도 O(2N)으로 증가**
- ❌ **이 문제에서는 마지막에 추가한 타일을 구분할 필요가 없음**

**예시:**
```
dp[4][0] = dp[3][0] + dp[3][1] = 2 + 1 = 3
dp[4][1] = dp[2][0] + dp[2][1] = 1 + 1 = 2
총: 3 + 2 = 5

→ 복잡하고 불필요함!
```

---

### 📊 종합 비교

| 방식 | 공간 복잡도 | 시간 복잡도 | 점화식 도출 | 적합성 |
|------|------------|------------|------------|--------|
| `dp[i] = 방법의 수` | O(N) | O(N) | 자연스러움 | ✅ |
| `dp[i][j] = 마지막에 j 타일을 추가한 경우` | O(2N) | O(N) | 복잡함 | ❌ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **`dp[i]` 1차원 배열이 가장 간결하고 명확함**
- 마지막에 추가한 타일을 구분할 필요가 없으므로 1차원으로 충분

---

### 알고리즘 선택 근거

이 문제는 **점화식 문제**로, 동적 계획법이 가장 효율적입니다.

**문제 해석에서 DP로 연결되는 과정:**

> **문제 해석**: [1.analysis.md](./1.analysis.md)에서 이 문제를 "마지막에 추가한 타일로 분류"하여 규칙을 발견했습니다.

이 해석을 통해 다음을 발견할 수 있습니다:

1. **최적 부분 구조 발견**: 
   - "2×i를 채우는 방법의 수" = 2×(i-1), 2×(i-2)를 채우는 방법의 수로 표현 가능
   - 이는 DP의 핵심 조건인 "최적 부분 구조"를 만족!

2. **DP로 자연스럽게 연결**:
   - 작은 문제의 해를 이용하여 큰 문제의 해를 표현
   - 점화식으로 명확히 표현 가능

**핵심 특징:**
* 작은 예시로 규칙 발견 가능
* 규칙이 점화식으로 명확히 표현됨
* 최적 부분 구조: 2×i를 채우는 방법의 수 = 2×(i-1), 2×(i-2)를 채우는 방법의 수로 표현
* 중복 부분 문제: 같은 크기를 채우는 방법의 수를 여러 번 계산
* n ≤ 1,000이므로 O(N) 시간 복잡도로 효율적

---

## 2️⃣ 자료형 선택: int 타입

### 왜 int를 사용하는가?

이 문제는 결과를 10,007로 나눈 나머지를 출력하므로, 값이 항상 10,007 미만입니다.

**Java 정수 타입 범위:**
- `int`: -2,147,483,648 ~ 2,147,483,647 (약 -21억 ~ 21억)
- `long`: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 -9경 ~ 9경)

**결론:**
- 모듈로 연산을 하므로 값이 항상 10,007 미만
- `int` 타입으로 충분

---

## 3️⃣ 모듈로 연산의 위치

### 왜 매번 모듈로 연산을 하는가?

점화식 계산 시 `dp[i-1] + dp[i-2]`의 값이 int 범위를 초과할 수 있습니다. 따라서 매번 모듈로 연산을 수행하여 오버플로우를 방지합니다.

**구현:**
```java
dp[i] = (dp[i-1] + dp[i-2]) % 10007;
```

**이유:**
- `dp[i-1]`과 `dp[i-2]`는 각각 10,007 미만이지만, 합이 10,007 이상이 될 수 있음
- 하지만 모듈로 연산의 성질에 의해 `(a + b) % m = ((a % m) + (b % m)) % m`이므로
- 매번 모듈로 연산을 해도 결과는 동일하며, 오버플로우를 방지할 수 있음

---

## 4️⃣ DP의 최적 부분 구조

### 최적 부분 구조의 의미

2×i를 채우는 방법의 수는 다음으로 표현됩니다:
1. 마지막에 세로 타일 1개를 추가한 경우: 2×(i-1)을 채우는 방법의 수
2. 마지막에 가로 타일 2개를 추가한 경우: 2×(i-2)를 채우는 방법의 수

이 두 가지 경우 모두 더 작은 문제의 해를 사용하므로, 최적 부분 구조를 만족합니다.

---

## 5️⃣ 점화식의 직관적 이해

### 왜 이 점화식이 성립하는가?

2×n을 채우는 방법은 반드시 마지막에 세로 타일 1개 또는 가로 타일 2개 중 하나를 추가한 것입니다.

**핵심 관찰:**
- 마지막에 세로 타일 1개를 추가한 경우: 2×(n-1)을 채우는 모든 방법에 세로 타일 1개를 추가하면 됨 → `dp[n-1]`가지
- 마지막에 가로 타일 2개를 추가한 경우: 2×(n-2)를 채우는 모든 방법에 가로 타일 2개를 추가하면 됨 → `dp[n-2]`가지

이 두 가지 경우는 서로 겹치지 않고, 모든 경우를 포함하므로:
```
dp[n] = dp[n-1] + dp[n-2]
```

**구체적인 예시 (n=4):**

```
2×4를 채우는 방법:
  - 마지막에 세로 타일 1개 추가: (2×3을 채우는 방법에 세로 타일 1개 추가)
    → dp[3] = 3가지
    
  - 마지막에 가로 타일 2개 추가: (2×2를 채우는 방법에 가로 타일 2개 추가)
    → dp[2] = 2가지
    
  총: dp[2] + dp[3] = 2 + 3 = 5가지 ✅
```

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 동적 계획법 (현재 방법) ✅

**장점:**
* 시간 복잡도 O(N)으로 매우 효율적
  - **근거**: 리스트의 항목(n개)을 한 번씩만 탐색
* 구현이 간단하고 직관적
* 일반적인 해법

**단점:**
* 없음 (이 문제에 가장 적합)

### 방법 2: 브루트 포스 (재귀)

**장점:**
* 구현이 간단
* 모든 경우를 탐색하므로 이해하기 쉬움

**단점:**
* 시간 복잡도 O(2^N)으로 비효율적
  - **근거**: 각 위치마다 2가지 선택, n개 위치를 확인
* n이 커지면 시간 초과 가능

### 방법 3: 메모이제이션 (재귀 + DP)

**장점:**
* 재귀적 사고가 자연스러움
* 시간 복잡도 O(N)으로 효율적

**단점:**
* 반복문보다 약간 느림 (함수 호출 오버헤드)
* 스택 오버플로우 가능성 (하지만 n ≤ 1,000이므로 문제 없음)

➡️ **동적 계획법이 이 문제에 가장 적합한 방법이다.**

