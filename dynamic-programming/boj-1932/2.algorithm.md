# 알고리즘: 동적 계획법

> 📖 **전체 알고리즘 설명**: [동적 계획법(Dynamic Programming) 정리](../dynamic-programming.md)

이 문제는 **동적 계획법(DP)**을 사용하여 해결합니다.  
상위 폴더의 [동적 계획법 정리 문서](../dynamic-programming.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## DP 알고리즘 개요

각 위치에서의 최적 누적합을 저장하여 중복 계산을 제거합니다.

### 핵심 아이디어

1. **상태 정의**: `dp[i][j] = 위치 (i, j)에 도달할 때까지의 최대 합`
   - `i`: 층 번호 (0부터 시작)
   - `j`: 해당 층에서의 위치 번호 (0부터 시작)
   - 각 위치마다 서로 다른 최적값이 필요

2. **점화식 도출**:
   ```
   dp[i][j] = triangle[i][j] + max(
       dp[i-1][j-1],  // 왼쪽 위에서 온 경로 (j > 0일 때만)
       dp[i-1][j]     // 오른쪽 위에서 온 경로 (j < i일 때만)
   )
   ```
   
   **점화식의 의미:**
   - 위치 (i, j)에 도달하는 방법은 두 가지
   - 방법 1: 왼쪽 위 (i-1, j-1)에서 내려옴
   - 방법 2: 오른쪽 위 (i-1, j)에서 내려옴
   - 두 경로 중 최대값을 선택하여 현재 위치 값과 더함
   
   > **구체적인 예시**: [1.analysis.md](./1.analysis.md)의 "4단계: 실제 예시로 단계별 이해하기" 섹션을 참고하세요.

3. **초기값**: `dp[0][0] = triangle[0][0]` (맨 위층)

---

## 구현 패턴

### 방법 1: 위에서 아래로 (Top-Down)

```java
int[][] dp = new int[n][n];

// 초기값
dp[0][0] = triangle[0][0];

// 위에서 아래로 계산
for (int i = 1; i < n; i++) {
    for (int j = 0; j <= i; j++) {
        if (j == 0) {
            // 왼쪽 끝: 오른쪽 위에서만 올 수 있음
            dp[i][j] = triangle[i][j] + dp[i-1][j];
        } else if (j == i) {
            // 오른쪽 끝: 왼쪽 위에서만 올 수 있음
            dp[i][j] = triangle[i][j] + dp[i-1][j-1];
        } else {
            // 중간: 양쪽에서 올 수 있음
            dp[i][j] = triangle[i][j] + Math.max(dp[i-1][j-1], dp[i-1][j]);
        }
    }
}

// 마지막 층의 최대값이 답
int answer = 0;
for (int j = 0; j < n; j++) {
    answer = Math.max(answer, dp[n-1][j]);
}
```

### 방법 2: 아래에서 위로 (Bottom-Up)

```java
int[][] dp = new int[n][n];

// 입력을 그대로 dp 배열에 저장
for (int i = 0; i < n; i++) {
    for (int j = 0; j <= i; j++) {
        dp[i][j] = triangle[i][j];
    }
}

// 아래에서 위로 계산
for (int i = n-2; i >= 0; i--) {
    for (int j = 0; j <= i; j++) {
        dp[i][j] += Math.max(dp[i+1][j], dp[i+1][j+1]);
    }
}

// 맨 위층의 값이 답
int answer = dp[0][0];
```

---

## 실제 계산 과정 (예시)

**입력:**
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**위에서 아래로 계산:**

```
i=0:
  dp[0][0] = 7

i=1:
  dp[1][0] = 3 + dp[0][0] = 3 + 7 = 10
  dp[1][1] = 8 + dp[0][0] = 8 + 7 = 15

i=2:
  dp[2][0] = 8 + dp[1][0] = 8 + 10 = 18
  dp[2][1] = 1 + max(dp[1][0], dp[1][1]) = 1 + max(10, 15) = 16
  dp[2][2] = 0 + dp[1][1] = 0 + 15 = 15

i=3:
  dp[3][0] = 2 + dp[2][0] = 2 + 18 = 20
  dp[3][1] = 7 + max(dp[2][0], dp[2][1]) = 7 + max(18, 16) = 25
  dp[3][2] = 4 + max(dp[2][1], dp[2][2]) = 4 + max(16, 15) = 20
  dp[3][3] = 4 + dp[2][2] = 4 + 15 = 19

i=4:
  dp[4][0] = 4 + dp[3][0] = 4 + 20 = 24
  dp[4][1] = 5 + max(dp[3][0], dp[3][1]) = 5 + max(20, 25) = 30
  dp[4][2] = 2 + max(dp[3][1], dp[3][2]) = 2 + max(25, 20) = 27
  dp[4][3] = 6 + max(dp[3][2], dp[3][3]) = 6 + max(20, 19) = 26
  dp[4][4] = 5 + dp[3][3] = 5 + 19 = 24

답: max(24, 30, 27, 26, 24) = 30
```

---

## 시간 복잡도

**전체 시간 복잡도: `O(n²)`**

**근거:**
- **위치 개수**: 1 + 2 + ... + n = n(n+1)/2 ≈ n²/2
- **각 위치 처리 시간**: O(1) (max 계산, 덧셈 모두 상수 시간)
- **전체 시간**: n²개 위치 × O(1) = O(n²)

**구체적인 계산:**
```
for (int i = 0; i < n; i++) {        // n번 반복
    for (int j = 0; j <= i; j++) {   // i+1번 반복
        dp[i][j] = 계산();            // O(1)
    }
}
// 총 시간: 1 + 2 + ... + n = n(n+1)/2 = O(n²)
```

**상태 개수:**
* n(n+1)/2개 (각 위치마다 하나의 상태)

**각 상태 처리 시간:**
* O(1) (상수 시간)

---

## 공간 복잡도

* **DP 배열**: O(n²)
* **입력 배열**: O(n²)
* **전체 공간 복잡도**: **O(n²)**

**최적화 가능:**
* 공간 복잡도를 O(n)으로 줄일 수 있음 (이전 층만 저장)
* 하지만 코드 가독성을 위해 O(n²) 사용

---

## 이 문제의 특이사항

### 1️⃣ 2차원 배열이 필요한 이유

**왜 1차원 배열로는 안 되는가?**

만약 `dp[i] = i번째 층까지의 최적 누적합`만 저장한다면:
- 같은 층의 여러 위치에서 서로 다른 최적값이 필요
- 왼쪽/오른쪽 제약 때문에 각 위치마다 도달 가능한 경로가 다름
- 따라서 각 위치 (i, j)별로 최적값을 저장해야 함

**예시:**
```
        7
      3   8
```
- `dp[1][0] = 10` (왼쪽 경로)
- `dp[1][1] = 15` (오른쪽 경로)
- 1차원 배열로는 두 값을 동시에 저장할 수 없음

### 2️⃣ 경계 조건 처리

각 층의 양 끝 위치는 특별 처리 필요:

```java
if (j == 0) {
    // 왼쪽 끝: 오른쪽 위에서만 올 수 있음
    dp[i][j] = triangle[i][j] + dp[i-1][j];
} else if (j == i) {
    // 오른쪽 끝: 왼쪽 위에서만 올 수 있음
    dp[i][j] = triangle[i][j] + dp[i-1][j-1];
} else {
    // 중간: 양쪽에서 올 수 있음
    dp[i][j] = triangle[i][j] + Math.max(dp[i-1][j-1], dp[i-1][j]);
}
```

### 3️⃣ 계산 방향 선택

**위에서 아래로 (Top-Down):**
- 직관적: 문제 설명과 동일한 방향
- 마지막 층의 최대값을 찾아야 함

**아래에서 위로 (Bottom-Up):**
- 더 간단한 구현 가능
- 맨 위층의 값이 바로 답

---

## 일반적인 DP와의 차이점

### 일반적인 1차원 DP
```java
int[] dp = new int[n];
dp[0] = 초기값;
for (int i = 1; i < n; i++) {
    dp[i] = 점화식;
}
```

**특징:**
- 상태가 1차원 (인덱스 하나)
- 시간 복잡도: O(n)

### 이 문제의 2차원 DP
```java
int[][] dp = new int[n][n];
dp[0][0] = 초기값;
for (int i = 1; i < n; i++) {
    for (int j = 0; j <= i; j++) {
        dp[i][j] = 점화식;
    }
}
```

**특징:**
- 상태가 2차원 (층 번호, 위치 번호)
- 왼쪽/오른쪽 제약 때문에 각 위치별로 최적값 필요
- 시간 복잡도: O(n²)

**차이점 요약:**

| 구분 | 일반적인 DP | 이 문제 |
|------|------------|--------|
| 상태 차원 | 1차원 | 2차원 |
| 상태 개수 | n개 | n(n+1)/2개 |
| 시간 복잡도 | O(n) | O(n²) |
| 필요 이유 | 단순한 순차 관계 | 위치별로 도달 경로가 다름 |
