# Main.java 설계 근거 정리

이 문서는 **BOJ 1932 정수 삼각형 문제**에 대한 알고리즘 선택과 설계 근거를 설명함.

---

## 1️⃣ 문제 해석

### 🔑 핵심 노하우: 경로 최적화 문제

이 문제는 **맨 위에서 맨 아래까지 내려오는 경로 중 합이 최대인 경로**를 찾는 문제였음.

#### 문제 구조 파악

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

**특징:**
- 각 층에서 대각선 왼쪽 또는 오른쪽으로만 이동 가능
- 같은 위치에 여러 경로로 도달할 수 있음
- 각 위치마다 도달 가능한 경로가 다름

#### 핵심 관찰

**문제를 읽고 나서 다음과 같이 생각했음:**

> "각 위치 (i, j)에 도달할 때까지의 최대 합은 무엇인가?"  
> "이 위치에서 아래로 내려갈 때 어떤 경로가 최적인가?"

**이렇게 각 위치별로 최적값을 저장하기로 했음.**

#### 왜 이 해석이 중요한가?

이 해석을 통해 문제의 본질을 파악할 수 있었음:

1. **위치별 최적값**: 각 위치 (i, j)마다 도달할 때까지의 최대 합이 다름
   - 예: (1, 0) 위치는 왼쪽 경로(7→3)에서만 올 수 있음
   - 예: (1, 1) 위치는 오른쪽 경로(7→8)에서만 올 수 있음
   - 예: (2, 1) 위치는 양쪽 경로(7→3→1 또는 7→8→1)에서 올 수 있음

2. **점화식 도출 가능**: 
   - 각 위치의 최적값은 위쪽 두 위치의 최적값으로 표현 가능
   - `dp[i][j] = triangle[i][j] + max(dp[i-1][j-1], dp[i-1][j])`
   - 이렇게 점화식을 자연스럽게 도출할 수 있었음

#### 실제 예시로 단계별 이해하기

**실제 입력 예시:**
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**각 위치별 최적값 계산:**

```
0층: dp[0][0] = 7

1층:
  dp[1][0] = 3 + 7 = 10   (왼쪽에서만 올 수 있음)
  dp[1][1] = 8 + 7 = 15   (오른쪽에서만 올 수 있음)

2층:
  dp[2][0] = 8 + 10 = 18   (왼쪽에서만)
  dp[2][1] = 1 + max(10, 15) = 16   (양쪽에서 올 수 있음)
  dp[2][2] = 0 + 15 = 15   (오른쪽에서만)

3층:
  dp[3][0] = 2 + 18 = 20
  dp[3][1] = 7 + max(18, 16) = 25
  dp[3][2] = 4 + max(16, 15) = 20
  dp[3][3] = 4 + 15 = 19

4층:
  dp[4][0] = 4 + 20 = 24
  dp[4][1] = 5 + max(20, 25) = 30
  dp[4][2] = 2 + max(25, 20) = 27
  dp[4][3] = 6 + max(20, 19) = 26
  dp[4][4] = 5 + 19 = 24

답: max(24, 30, 27, 26, 24) = 30
```

---

## 2️⃣ 해결 전략

### 동적 계획법 (DP) 접근

**전략 개요:**
* `dp[i][j]` = 위치 (i, j)에 도달할 때까지의 최대 합
* 각 위치를 한 번만 계산하고 결과를 저장하여 재사용
* 최적 부분 구조를 활용하여 효율적으로 해결

**핵심 아이디어:**
- 각 위치에서의 최적 누적합을 저장
- 위에서 아래로 계산하여 필요한 값이 이미 계산되어 있음
- 중복 계산을 제거하여 효율성 확보

---

## 3️⃣ 알고리즘 선택 근거

### 완전탐색 분석

**시간 복잡도: O(2^n)**
- 각 층에서 2가지 선택 (왼쪽 또는 오른쪽)
- n층이면 총 2^n개의 경로
- n=500일 때: 2^500 ≈ 10^150

**제한시간 분석:**
- 제한시간: 2초
- 일반적으로 2초에 약 10^8 정도의 연산 가능
- 2^500은 제한시간 내에 불가능

**결론: 완전탐색은 사용할 수 없다고 판단했음.**

---

### 그리디 알고리즘 검토

**그리디 접근:**
- 각 층에서 가장 큰 수를 선택

**반례:**
```
        7
      3   8
    8   1   0
```

- 그리디: 7 → 8 → 0 = 15
- 최적: 7 → 3 → 8 = 18

**문제점:**
- 당장 큰 수를 선택해도 이후 단계에서 작은 값만 나오면 최적이 아님
- 최적 부분 구조가 성립하지 않음

**결론: 그리디 알고리즘은 사용할 수 없다고 판단했음.**

---

### 동적 계획법 선택

**왜 DP를 사용했는가?**

1. **최적 부분 구조 성립**
   - 위치 (i, j)에 도달하는 최적 경로는
   - 위쪽 두 위치 (i-1, j-1), (i-1, j)의 최적 경로로 구성됨

2. **중복 부분 문제 존재**
   - 같은 위치에 여러 경로로 도달 가능
   - 각 위치의 최적값은 한 번만 계산하면 됨

3. **효율적인 해결 가능**
   - 각 위치를 한 번만 계산하고 재사용
   - 시간 복잡도: O(n²) = O(250,000) → 충분히 빠름

**결론: 동적 계획법을 사용하기로 했음.**

---

## 4️⃣ 상태 정의 근거

### 왜 2차원 배열이 필요했는가?

**1차원 배열 시도 (실패):**

```java
int[] dp = new int[n];
dp[i] = i번째 층까지의 최적 누적합
```

**문제점:**
- 같은 층의 여러 위치에서 서로 다른 최적값이 필요했음
- 예: 1층에서 `dp[1][0] = 10`, `dp[1][1] = 15`
- 1차원 배열로는 두 값을 동시에 저장할 수 없었음

**2차원 배열 (성공):**

```java
int[][] dp = new int[n][n];
dp[i][j] = 위치 (i, j)에 도달할 때까지의 최대 합
```

**이유:**
- 왼쪽/오른쪽 제약 때문에 각 위치마다 도달 가능한 경로가 달랐음
- 각 위치별로 최적값을 저장해야 했음

**결론: 2차원 배열로 각 위치별 누적합을 관리하기로 했음.**

---

## 5️⃣ 시간 복잡도 분석

### 완전탐색 vs DP

**완전탐색:**
- 경로 수: 2^n개
- 각 경로마다 처음부터 끝까지 계산
- 같은 위치를 여러 경로에서 반복 계산
- 시간 복잡도: O(2^n)

**DP:**
- 위치 개수: n(n+1)/2 ≈ n²개
- 각 위치를 한 번만 계산하고 재사용
- 시간 복잡도: O(n²)

**비교 (n=500):**
- 완전탐색: 2^500 ≈ 10^150 (불가능)
- DP: 500×501/2 ≈ 125,000 (충분히 빠름)

**결론: DP는 각 위치를 한 번만 계산하므로 n²만큼의 연산만 필요하다고 판단했음.**

---

## 6️⃣ 핵심 아이디어 정리

### DP의 효율성 원리

1. **중복 계산 제거**
   - 완전탐색: 같은 위치를 여러 경로에서 반복 계산
   - DP: 각 위치의 최적값을 한 번만 계산하고 저장

2. **결과 재사용**
   - 저장된 최적값을 여러 경로에서 재사용
   - 예: `dp[1][0] = 10`을 계산한 후, 이를 사용하는 모든 경로에서 재사용

3. **계산 순서**
   - 위에서 아래로 계산하여 필요한 값이 이미 계산되어 있음
   - 의존성 문제 해결

**결론: DP는 위치별 최적 누적합을 저장하여 중복 계산을 제거하고, n²번의 연산만으로 해결 가능하다고 판단했음.**

---

## 7️⃣ 최종 판단 요약

| 판단 항목 | 결과 | 근거 |
|----------|------|------|
| 완전탐색 가능 여부 | ❌ 불가능 | 2^500은 제한시간 내 불가능 |
| 그리디 가능 여부 | ❌ 불가능 | 최적 부분 구조 성립하지 않음 |
| DP 사용 여부 | ✅ 필요 | 최적 부분 구조 + 중복 부분 문제 |
| 배열 차원 | 2차원 | 위치별로 최적값이 필요했음 |
| 시간 복잡도 | O(n²) | 위치 개수만큼만 계산 |

**최종 결론: 2차원 DP를 사용하여 각 위치별 최적 누적합을 저장하고, n²번의 연산으로 해결하기로 했음.**

