# 무한 수열 2 (BOJ 1354) 알고리즘

## 1) 상태를 `memo[i] = A_i`로 매핑
배열 `dp` 대신 `HashMap<Long, Long> memo`를 사용합니다.

- 의미: `memo.get(i)`는 `A_i` 값
- 예: `A_0`, `A_1`, `A_2`를 계산했다면 각각 `memo[0]`, `memo[1]`, `memo[2]`에 저장됨

같은 `i`가 여러 번 호출돼도 최초 1회만 계산하고, 이후에는 `memo`에서 바로 가져옵니다.
즉 "재귀 분해"는 유지하면서 "중복 계산"만 제거합니다.

```java
static HashMap<Long, Long> memo = new HashMap<>();
```

## 2) 점화식을 `solve(i)`라는 재귀 함수로 구현
`solve(i)`는 "`A_i`를 반환하는 함수"입니다.

점화식:
- `i <= 0`이면 `A_i = 1`
- `i >= 1`이면 `A_i = A_(floor(i / P) - X) + A_(floor(i / Q) - Y)`

코드에서는 Java 정수 나눗셈 `i / p`, `i / q`가 `floor(i / P)`, `floor(i / Q)`와 같습니다.

1. `i <= 0`이면 고정값 `1` 반환
2. `memo`에 이미 `i`가 있으면 저장된 값 즉시 반환
3. 없으면 왼쪽/오른쪽 상태를 재귀로 계산
- `left = solve(floor(i / P) - X)`
- `right = solve(floor(i / Q) - Y)`
4. `value = left + right`를 `memo.put(i, value)`로 저장 후 반환

```java
static long solve(long i) {
    if (i <= 0) {
        return 1L;
    }

    Long cached = memo.get(i);
    if (cached != null) {
        return cached;
    }

    long left = solve(i / p - x);   // i / p == floor(i / P)
    long right = solve(i / q - y);  // i / q == floor(i / Q)
    long value = left + right;

    memo.put(i, value);
    return value;
}
```

## 3) 시작 상태는 `solve(N)`
입력 받은 `N`에 대해 `solve(N)`을 호출하면 정답 `A_N`이 계산됩니다.

```java
System.out.println(solve(N));
```
