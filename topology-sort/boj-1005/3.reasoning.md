# 알고리즘 선택 근거: 위상 정렬 + DP

## 1. 위상 정렬이 필요한 이유

### 문제의 핵심: 건물 간 선후 관계

이 문제는 건물 간의 선후 관계가 존재하는 문제입니다.

```
건물 관계:
1 → 2
1 → 3
2 → 4
3 → 4
```

위상 정렬이 필요한 이유는 다음과 같습니다.

1. **건물을 올바른 순서로 처리해야 합니다**
   - 건물 4를 처리하기 전에 건물 2와 3이 완료되어야 합니다
   - 건물 2를 처리하기 전에 건물 1이 완료되어야 합니다
   - 위상 정렬은 이러한 선후 관계를 만족하는 순서를 보장합니다

2. **각 건물을 처리할 때 모든 선행 건물이 이미 처리되었음을 보장합니다**
   - 위상 정렬 순서대로 처리하면, 각 건물의 선행 건물들이 이미 완료되어 있습니다
   - 이를 통해 시간 계산을 올바르게 수행할 수 있습니다

위상 정렬을 사용하지 않을 경우 다음과 같은 문제가 발생합니다.

```
잘못된 순서: 4 → 2 → 1 → 3
- 건물 4를 먼저 처리하려고 시도
- 하지만 건물 2와 3이 아직 완료되지 않음
- 처리 불가능
```

위상 정렬을 사용할 경우 올바른 순서를 보장할 수 있습니다.

```
올바른 순서: 1 → (2, 3 동시) → 4
- 건물 1을 먼저 처리 (선행 조건 없음)
- 건물 2, 3을 처리 (선행 조건 1 완료)
- 건물 4를 처리 (선행 조건 2, 3 완료)
- 처리 가능
```

### 위상 정렬 방법 선택: Kahn vs DFS

위상 정렬을 구현하는 방법은 크게 두 가지가 있습니다. Kahn 알고리즘과 DFS 기반 알고리즘입니다.

이 문제에서는 Kahn 알고리즘을 선택하였습니다.

Kahn 알고리즘을 선택한 이유는 다음과 같습니다.

1. **DP와의 자연스러운 결합**
   - 위상 정렬 순서대로 처리하면서 DP 값을 갱신하는 것이 직관적입니다
   - 각 건물을 처리할 때 모든 선행 건물의 DP 값이 이미 계산되어 있어 즉시 갱신할 수 있습니다

2. **구현의 단순성**
   - Queue를 사용한 반복문 기반 구현이 간단하고 이해하기 쉽습니다
   - 재귀 호출 없이 선형적인 흐름으로 구현할 수 있습니다

3. **재귀 깊이 문제 없음**
   - DFS는 재귀 호출로 인한 스택 오버플로우 가능성이 있습니다
   - Kahn 알고리즘은 반복문 기반이므로 이러한 문제가 없습니다

DFS 기반 알고리즘을 사용하지 않은 이유는 다음과 같습니다.

- 위상 정렬과 DP를 분리해서 처리해야 하거나, 메모이제이션을 추가해야 합니다
- 구현 복잡도가 증가합니다
- 위상 정렬 순서를 얻은 후 별도로 DP를 수행해야 하므로 두 단계가 필요합니다

---

## 2. 최대 비용을 구하기 위한 알고리즘 선택

위상 정렬로 건물을 올바른 순서로 처리할 수 있지만, 시간을 계산하는 방법이 필요합니다.

### 문제의 핵심: 최장 경로 찾기

건물 W를 짓기까지 걸리는 시간은 모든 경로 중 가장 오래 걸리는 경로에 의해 결정됩니다.

```
건물 관계:
1 → 2 → 4
1 → 3 → 4

건설 시간:
건물 1: 10초
건물 2: 1초
건물 3: 100초
건물 4: 10초

경로 분석:
- 경로 1: 1 → 2 → 4 = 10 + 1 + 10 = 21초
- 경로 2: 1 → 3 → 4 = 10 + 100 + 10 = 120초

건물 4를 시작하려면:
- 건물 2 완료: 11초
- 건물 3 완료: 110초
- 둘 중 최댓값: 110초
- 건물 4 완료: 110 + 10 = 120초
```

---

## 3. 그리디 vs DP vs 완전 탐색 비교

### 3.1 그리디 알고리즘

그리디 알고리즘은 매 순간 최선의 선택을 하며 하나의 경로만 선택합니다.

이 문제에서 그리디 알고리즘이 실패하는 이유는 다음과 같습니다.

1. **여러 경로를 모두 고려해야 합니다**
   ```
   그리디 접근: 경로 1 (21초) 선택
   - 건물 2를 먼저 완료 (11초)
   - 건물 4 시작 불가능
   - 건물 3도 완료되어야 함 (110초)
   - 실제로는 120초 필요
   
   결과: 그리디 알고리즘은 최적해를 찾지 못함
   ```

2. **탐욕 선택 속성을 만족하지 않습니다**
   - 현재 시점에서 가장 유리해 보이는 경로를 선택하는 것이 전체 최적해를 보장하지 않습니다
   - 건물 4를 짓기 위해서는 경로 1과 경로 2 모두가 완료되어야 합니다
   - 따라서 모든 경로를 고려해야 합니다

3. **순서 선택이 의미가 없습니다**
   - 문제 조건에 따르면 여러 건물이 동시에 진행 가능합니다
   - 선행 조건만 만족되면 동시에 건설할 수 있습니다
   - 순서를 선택할 필요가 없습니다

결론적으로 그리디 알고리즘은 이 문제에 적합하지 않습니다.

### 3.2 완전 탐색

완전 탐색은 모든 가능한 경로를 탐색하고 각 경로의 비용을 계산한 후 최댓값을 선택합니다.

이 문제에서 완전 탐색이 부적합한 이유는 다음과 같습니다.

1. **시간 복잡도 문제**
   ```
   가능한 경로의 수: 지수적
   - 각 건물마다 여러 선행 건물이 있을 수 있음
   - 경로의 수가 매우 많아질 수 있음
   - 시간 복잡도: O(2^N) 이상
   ```

2. **불필요한 중복 계산**
   ```
   경로 1: 1 → 2 → 4
   경로 2: 1 → 3 → 4
   
   완전 탐색:
   - 경로 1 탐색: 건물 1, 2, 4 계산
   - 경로 2 탐색: 건물 1, 3, 4 계산
   - 건물 1과 4를 중복 계산
   
   DP:
   - 건물 1 계산: 1번만
   - 건물 2, 3 계산: 각각 1번씩
   - 건물 4 계산: 1번만
   - 중복 계산 없음
   ```

3. **입력 크기 제약**
   - N ≤ 1000, K ≤ 100,000
   - 완전 탐색은 시간 초과가 발생합니다

결론적으로 완전 탐색은 비효율적입니다.

### 3.3 동적 계획법 (DP)

동적 계획법은 각 건물의 완료 시간을 순차적으로 계산하며, 모든 선행 건물의 완료 시간을 고려한 후 최댓값을 선택합니다.

이 문제에서 동적 계획법이 적합한 이유는 다음과 같습니다.

1. **모든 경로를 효율적으로 고려합니다**
   ```
   DP[1] = 10
   DP[2] = DP[1] + 1 = 11
   DP[3] = DP[1] + 100 = 110
   DP[4] = max(DP[2], DP[3]) + 10 = max(11, 110) + 10 = 120
   
   모든 경로를 고려한 후 최댓값을 선택하며 중복 계산이 없습니다
   ```

2. **최적 부분 구조를 만족합니다**
   ```
   건물 W의 완료 시간 = max(모든 선행 건물의 완료 시간) + W의 건설 시간
   
   각 건물의 완료 시간을 순차적으로 계산할 수 있습니다
   ```

3. **위상 정렬과 자연스럽게 결합 가능합니다**
   ```
   위상 정렬 순서대로 처리:
   1 → (2, 3) → 4
   
   DP 계산:
   - 건물 1 처리: DP[1] 계산 (선행 조건 없음)
   - 건물 2, 3 처리: DP[2], DP[3] 계산 (선행 조건 1 완료)
   - 건물 4 처리: DP[4] 계산 (선행 조건 2, 3 완료)
   
   위상 정렬 순서대로 처리하면 모든 선행 건물의 DP 값이 이미 계산되어 있습니다
   ```

4. **시간 복잡도가 효율적입니다**
   ```
   O(N + K)
   - 각 정점과 간선을 한 번씩만 처리
   - 대규모 입력에서도 안정적으로 동작
   ```

결론적으로 동적 계획법이 가장 적합합니다.

알고리즘 선택 요약

| 알고리즘 | 적합성 | 이유 |
|---------|--------|------|
| 그리디 | 부적합 | 하나의 경로만 선택하므로 여러 경로를 고려하지 못함 |
| 완전 탐색 | 부적합 | 시간 복잡도가 지수적이며 중복 계산 발생 |
| 동적 계획법 | 적합 | 모든 경로를 효율적으로 고려하며 최댓값 선택 가능 |

---
