# 알고리즘: 위상 정렬 + DP

> 📖 **전체 알고리즘 설명**: [위상 정렬(Topological Sort) 정리](../topological-sort.md)

## 이 문제에서의 위상 정렬 + DP 적용

이 문제는 위상 정렬과 동적 계획법을 함께 사용하여 해결합니다.

* **위상 정렬**: 건물 간의 선후 관계를 만족하는 순서로 건물을 처리합니다
* **동적 계획법**: 각 건물의 완료 시간을 계산하며, 모든 선행 건물의 완료 시간 중 최댓값을 선택합니다

위상 정렬 순서대로 건물을 처리하면서 동시에 DP 값을 갱신하는 방식으로 구현합니다.

---

## 알고리즘 구조

### 1️⃣ 위상 정렬의 역할

위상 정렬은 **건물을 올바른 순서로 처리**하기 위해 필요합니다.

**핵심:**
- 각 건물을 처리할 때, 모든 선행 건물이 이미 처리되었음을 보장
- 이를 통해 DP 값을 올바르게 계산할 수 있음

### 2️⃣ DP의 역할

DP는 **각 건물의 완료 시간을 계산**하기 위해 필요합니다.

**핵심:**
- 각 건물의 완료 시간 = `max(모든 선행 건물의 완료 시간) + 현재 건물의 건설 시간`
- 여러 경로가 있을 때, 가장 오래 걸리는 경로가 전체 시간을 결정

### 3️⃣ 두 알고리즘의 결합

위상 정렬 순서대로 건물을 처리하면서, 동시에 DP 값을 갱신합니다.

```
위상 정렬 순서: 1 → (2, 3) → 4

DP 계산:
- DP[1] = 10 (선행 조건 없음)
- DP[2] = DP[1] + 1 = 11
- DP[3] = DP[1] + 100 = 110
- DP[4] = max(DP[2], DP[3]) + 10 = max(11, 110) + 10 = 120
```

---

## 핵심 구현 패턴

### Kahn 알고리즘 + DP

```java
// 위상 정렬 + DP
int[] dp = new int[N + 1];  // dp[i] = 건물 i의 완료 시간
Queue<Integer> queue = new ArrayDeque<>();

// 1. 선행 조건이 없는 건물부터 시작
for (int i = 1; i <= N; i++) {
    if (indegree[i] == 0) {
        dp[i] = time[i];  // 선행 조건 없으면 자신의 건설 시간만
        queue.offer(i);
    }
}

// 2. 위상 정렬 순서대로 처리하면서 DP 갱신
while (!queue.isEmpty()) {
    int current = queue.poll();
    
    for (int next : graph[current]) {
        // next의 완료 시간 = max(모든 선행 건물의 완료 시간) + next의 건설 시간
        dp[next] = Math.max(dp[next], dp[current] + time[next]);
        
        indegree[next]--;
        if (indegree[next] == 0) {
            queue.offer(next);
        }
    }
}

return dp[W];
```

---

## 시간 복잡도

### 그래프 구성
* 정점 초기화: `O(N)`
* 간선 입력 처리: `O(K)`

➡️ 전체 그래프 구성 비용은 `O(N + K)`

### 위상 정렬 + DP 수행
* 각 정점은 최대 한 번 Queue에 들어가고 한 번 처리됨 → `O(N)`
* 각 간선은 정확히 한 번만 처리됨 → `O(K)`
* DP 갱신은 각 간선 처리 시 한 번씩 수행됨 → `O(K)`

➡️ 위상 정렬 + DP 수행 비용은 `O(N + K)`

### 전체 시간 복잡도
```
O(N + K)
```

대규모 입력(N ≤ 1000, K ≤ 100,000)에서도 안정적으로 동작합니다.

---

## 공간 복잡도

* **그래프 저장**: 인접 리스트 `O(N + K)`
  * 정점 배열: `O(N)`
  * 간선 정보: `O(K)`
* **진입 차수 배열**: `O(N)`
* **DP 배열**: `O(N)`
* **Queue**: 최악의 경우 `O(N)`

➡️ 전체 공간 복잡도는 `O(N + K)`
