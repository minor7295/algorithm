# 알고리즘: 위상정렬 + DP

> 전체 위상정렬 개념은 [../topological-sort.md](../topological-sort.md)를 참고합니다.

## 1. 상태 정의

부품 `i`를 만들 때 필요한 기본 부품 개수를 다음으로 둡니다.

- `need[i][b]`: 부품 `i` 1개를 만들 때 기본 부품 `b`가 필요한 개수

기본 부품 `b`는 자기 자신 1개로 시작합니다.

- `need[b][b] = 1`

## 2. 그래프 구성

입력 `X Y K`는 "`X`를 만들 때 `Y`가 `K`개 필요"입니다.

위상정렬 전파를 위해 간선을 `Y -> X`로 저장합니다.

- `graph[Y].add(X, K)`
- `indegree[X]++`

이렇게 하면 `indegree == 0`인 정점이 기본 부품이 됩니다.

## 3. 위상정렬 + 누적 전이

큐에서 `cur`를 꺼내 `cur`를 사용하는 상위 부품 `next`로 정보를 전달합니다.

점화식 (`cur -> next`, 필요 개수 `k`):

- `need[next][b] += need[cur][b] * k`

그리고 `indegree[next]`를 1 감소시키고,
`indegree[next] == 0`이 되면 큐에 넣습니다.


```java
while (!q.isEmpty()) {
    int cur = q.poll();
    for (Edge e : graph[cur]) { // cur -> next, need = k
        int next = e.to, k = e.k;

        // cur는 이미 indegree==0 상태에서 꺼낸 부품:
        // 선행 정보가 모두 반영된 확정값이므로 next로 안전하게 전파 가능
        for (int b = 1; b <= n; b++) {
            need[next][b] += need[cur][b] * k;
        }

        // 아직 처리 안 된 선행 부품 개수를 1 감소
        indegree[next]--;

        // indegree==0 이 되는 순간에만 큐에 넣는다:
        // => next의 모든 선행 부품이 끝났다는 뜻(선후 관계 보장)
        if (indegree[next] == 0) q.offer(next);
    }
}
```


## 4. 출력

완제품은 `N`번 부품이므로 `need[N][i] > 0`인 `i`만 출력하면 됩니다.

- 출력 형식: `i need[N][i]`
- `i`를 1부터 순회하면 번호 오름차순 조건을 만족합니다.

## 5. 복잡도

- 정점 수 `N <= 100`, 간선 수 `M <= 100`
- 간선 처리 시 기본 부품 축 `1..N`을 순회

따라서

- 시간 복잡도: `O(MN + N^2)`
- 공간 복잡도: `O(N^2 + M)`

제한에서 충분히 안전합니다.
