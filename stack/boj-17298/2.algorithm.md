# 오큰수 (BOJ 17298) 알고리즘

## 1) 자료구조를 다음과 같이 둡니다.
문제에서 필요한 정보는 "아직 오큰수를 못 찾은 위치"입니다.
따라서 값 자체가 아니라 인덱스를 저장하는 스택을 사용합니다.

- `arr`: 입력 수열
- `answer`: 정답 배열 (초기값 `-1`)
- `stack`: 오큰수 미해결 인덱스 저장

```java
int[] arr = new int[N];
int[] answer = new int[N];
Arrays.fill(answer, -1);
ArrayDeque<Integer> stack = new ArrayDeque<>();
```

## 2) 왼쪽에서 오른쪽으로 한 번 순회하며 처리합니다.
현재 인덱스를 `i`라고 할 때, `arr[stack.peek()] < arr[i]`인 동안 pop하며 오큰수를 확정합니다.

```java
for (int i = 0; i < N; i++) {
    // 오큰수인 경우
    while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {
        answer[stack.peek()] = arr[i];
        stack.pop();
    }
    // 오큰수가 아닌 경우 
    stack.push(i);
}
```

## 3) 순회가 끝난 뒤 스택에 남은 인덱스는 `-1`입니다.
스택에 남아 있다는 것은 오른쪽에서 더 큰 수를 끝까지 못 찾았다는 뜻입니다.
`answer`를 처음부터 `-1`로 채웠으므로 추가 처리가 필요 없습니다.

## 4) 복잡도
- 시간 복잡도: `O(N)`
- 공간 복잡도: `O(N)`

각 인덱스는 최대 1번 push, 1번 pop되므로 전체가 선형으로 제한됩니다.
