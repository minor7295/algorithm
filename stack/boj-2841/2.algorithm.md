# 외계인의 기타 연주 (BOJ 2841) 알고리즘

## 1) 줄별 독립 상태를 분리해서 관리한다
문제의 핵심은 줄 간 상호작용이 없다는 점입니다.
그래서 전체를 한 구조로 섞지 않고, 줄마다 상태를 분리해 최소 동작만 계산합니다.

```java
ArrayDeque<Integer>[] stacks = new ArrayDeque[7];
for (int line = 1; line <= 6; line++) {
    stacks[line] = new ArrayDeque<>();
}
```

## 2) "지금 음을 내는 데 필요한 동작만" 수행한다
한 음 `(line, fret)`를 처리할 때 필요한 동작은 3가지뿐입니다.
- 높은 프렛은 반드시 떼야 함(pop)
- 같은 프렛이면 아무 것도 안 함
- 낮거나 비어 있으면 반드시 눌러야 함(push)

```java
ArrayDeque<Integer> s = stacks[line];

while (!s.isEmpty() && s.peekLast() > fret) {
    s.pollLast();
    moves++; // 떼기 1회
}

if (s.isEmpty() || s.peekLast() < fret) {
    s.addLast(fret);
    moves++; // 누르기 1회
}
// s.peekLast() == fret 이면 동작 없음
```

## 3) 위 규칙을 입력 순서대로 반복해 전체 최소값을 만든다
멜로디는 순서를 바꿀 수 없으므로, 각 음에서의 최소 동작을 누적하면 전체 최소가 됩니다.

```java
long moves = 0;

for (int i = 0; i < n; i++) {
    int line = nextInt();
    int fret = nextInt();

    // 2번 스니펫 적용
}

System.out.println(moves);
```

## 4) 복잡도 근거
의도는 "불필요한 재탐색 없이, 각 프렛을 최대 한 번 push/한 번 pop" 하는 것입니다.
그래서 전체 연산은 선형으로 제한됩니다.

- 시간 복잡도: `O(N)`
- 공간 복잡도: `O(N)` (최악)
