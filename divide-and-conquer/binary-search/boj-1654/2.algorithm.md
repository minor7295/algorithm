# 알고리즘: 이분 탐색 (Binary Search)

> 📖 **전체 알고리즘 설명**: [이분 탐색 정리](../binary-search.md)

이 문제는 **이분 탐색(Binary Search)**을 사용하여 해결합니다.  
상위 폴더의 [이분 탐색 정리 문서](../binary-search.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 이분 탐색 적용

### 문제 특성

* **파라메트릭 서치**: 랜선의 길이를 이분 탐색으로 찾는 문제
* **조건 함수**: 특정 길이로 자를 때 N개 이상 만들 수 있는가?
* **목표**: N개 이상 만들 수 있는 최대 길이

---

## 이 문제의 특이사항

### 1️⃣ 이분 탐색 적용 가능 조건

이 문제에서 이분 탐색이 가능한 이유:

* **단조성**: 랜선 길이가 작을수록 더 많은 개수를 만들 수 있음
  * 길이가 작으면 → 만들 수 있는 개수 증가
  * 길이가 크면 → 만들 수 있는 개수 감소
* **탐색 가능**: 길이의 범위가 명확함 [1, 최대 랜선 길이]
* **조건 판단**: 각 길이에 대해 O(K) 시간에 판단 가능

➡️ 이는 [이분 탐색 정리](../binary-search.md)에서 설명하는 **파라메트릭 서치**의 전형적인 예시입니다.

### 2️⃣ 핵심 아이디어

**랜선 길이를 이분 탐색**으로 찾는다:

* **하한선**: 1 (가장 작은 길이)
* **상한선**: 가장 긴 랜선의 길이
* **조건 함수**: `canMake(length) >= N`
  * True → 길이를 늘림 (더 큰 값 시도)
  * False → 길이를 줄임 (더 작은 값 시도)

### 3️⃣ 시간 복잡도

* **탐색 횟수**: log₂(최대 랜선 길이) ≈ log₂(2³¹) ≈ 31번
* **각 반복마다**: K번의 나눗셈 (K ≤ 10,000)
* **전체 시간 복잡도**: **O(K × log(최대 랜선 길이))**

최악의 경우: 31 × 10,000 = 310,000번의 연산 << 10⁸ (1초 기준)

자세한 시간 복잡도 분석은 [3.reasoning.md](./3.reasoning.md)를 참고하세요.

### 4️⃣ 공간 복잡도

* **랜선 길이 배열**: O(K)
* **추가 메모리**: O(1) (변수 몇 개만 사용)
* **전체 공간 복잡도**: **O(K)**

---

## 핵심 구현 패턴

이 문제에 특화된 이분 탐색 구현:

### 방법 1: 기본 이분 탐색 (권장) ✅

```java
long left = 1;
long right = maxLength;  // 가장 긴 랜선의 길이
long answer = 0;

while (left <= right) {
    long mid = (left + right) / 2;
    
    // mid 길이로 만들 수 있는 랜선의 개수 계산
    long count = 0;
    for (int i = 0; i < K; i++) {
        count += lengths[i] / mid;
    }
    
    if (count >= N) {
        // N개 이상 만들 수 있음 → 길이를 늘림
        answer = mid;  // 현재 mid가 가능한 값이므로 저장
        left = mid + 1;
    } else {
        // N개 미만 → 길이를 줄임
        right = mid - 1;
    }
}

System.out.println(answer);
```

이 구현은 [이분 탐색 정리](../binary-search.md)의 **파라메트릭 서치 패턴 4**를 따릅니다.

### 방법 2: 조건 함수 분리

```java
// 조건 함수: 특정 길이로 N개 이상 만들 수 있는가?
boolean canMake(long length, long[] lengths, long N) {
    long count = 0;
    for (long len : lengths) {
        count += len / length;
    }
    return count >= N;
}

// 이분 탐색
long left = 1;
long right = maxLength;
long answer = 0;

while (left <= right) {
    long mid = (left + right) / 2;
    
    if (canMake(mid, lengths, N)) {
        answer = mid;
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}

System.out.println(answer);
```

### 주의사항

* **long 타입 사용**: 랜선 길이가 최대 2³¹-1이므로 long 타입 사용
* **오버플로우 방지**: `(left + right) / 2` 대신 `left + (right - left) / 2` 사용 가능
* **정답 저장**: `count >= N`일 때 `answer = mid`로 저장해야 함

자세한 주의사항은 [이분 탐색 정리](../binary-search.md)의 **주의사항** 섹션을 참고하세요.

---

## 다른 이분 탐색 문제와의 차이점

| 특징 | 일반 이분 탐색 | 이 문제 (1654) |
|------|--------------|---------------|
| 탐색 대상 | 정렬된 배열의 값 | 랜선의 길이 (파라메트릭 서치) |
| 조건 함수 | `arr[mid] == target` | `canMake(mid) >= N` |
| 목표 | 특정 값 찾기 | 조건을 만족하는 최대값 찾기 |
| 구현 복잡도 | 낮음 | 중간 (조건 함수 필요) |

이 문제는 [이분 탐색 정리](../binary-search.md)에서 설명하는 **파라메트릭 서치**의 전형적인 예시입니다.

---

## 참고

* 전체 이분 탐색 알고리즘 설명: [../binary-search.md](../binary-search.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

