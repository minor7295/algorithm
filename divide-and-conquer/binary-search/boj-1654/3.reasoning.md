# Main.java 설계 근거 정리

이 문서는 **BOJ 1654 랜선 자르기 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **이분 탐색 개념과 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 과정

### 고려한 알고리즘들과 평가

#### 1. 완전 탐색 (Brute Force)

**초기 접근**: 가능한 모든 길이를 시도하는 방법을 고려

**사고 과정**:
* 랜선 길이를 1부터 최대 길이까지 모두 시도
* 각 길이에 대해 K개의 랜선을 자를 수 있는 개수 계산
* N개 이상 만들 수 있는 최대 길이 찾기

**평가**:
* 시간 복잡도: O(K × 최대 랜선 길이)
* 최대 랜선 길이가 2³¹-1이면 약 21억 번의 연산 필요
* 시간 제한(2초) 초과 예상

**소거 이유**: 시간 복잡도가 선형적으로 증가하여 비현실적 ❌

---

#### 2. 이분 탐색 (현재 방식) ✅

**평가**:
* 시간 복잡도: O(K × log(최대 랜선 길이))
* 탐색 횟수: log₂(2³¹) ≈ 31번
* 각 반복마다: K번의 나눗셈 (K ≤ 10,000)
* 전체 연산: 31 × 10,000 = 310,000 << 10⁸

**선택 이유**:
* ✅ **시간 복잡도**: O(K × log(최대 랜선 길이))로 매우 효율적
* ✅ **단조성**: 랜선 길이와 만들 수 있는 개수 사이에 단조 관계 존재
* ✅ **파라메트릭 서치**: 조건을 만족하는 최대값을 찾는 전형적인 문제
* ✅ **구현 간단**: 이분 탐색 패턴을 그대로 적용 가능

**결론**: 이분 탐색을 선택 ✅

---

## 2️⃣ 시간 복잡도 분석 과정

### 초기 사고 과정

**사용자의 사고 과정**:
1. 가장 긴 랜선 길이로 만들면 1개만 만들 수 있음
2. 가장 짧은 랜선 길이로 만들면 n개 만큼 만들 수 있음
3. 가장 긴 것과 짧은 것 사이를 이분 탐색으로 탐색
4. 탐색 비용은 log₂(1,000,000)이고, 2¹⁰ = 1,024임을 감안하면 대략 20번만으로 탐색 가능
5. 각 반복마다 n번만큼 나눗셈만 하면 되므로 시간 제한을 생각하지 않아도 될만큼 효율적

**평가**:
* ✅ **이분 탐색 접근**: 올바른 방향
* ✅ **시간 복잡도 분석**: log₂ 관계를 이해하고 있음
* ✅ **지수 관계 활용**: 2¹⁰ ≈ 10³ 관계를 이용한 추정 방법

**보완 사항**:
* 하한선은 1이어야 함 (가장 짧은 랜선 길이가 아님)
* 상한선은 가장 긴 랜선 길이
* 탐색 범위는 최대 랜선 길이 (최대 2³¹-1)이므로 log₂(2³¹) ≈ 31번

---

### 시간 복잡도 분석 방법

#### 방법 1: 지수 관계를 이용한 추정 (사용자 방식)

**기본 관계**:
```
2¹⁰ = 1,024 ≈ 10³
2²⁰ ≈ (10³)² = 10⁶
2³⁰ ≈ (10³)³ = 10⁹
```

**문제 적용**:
```
탐색 범위: 최대 2³¹-1
log₂(2³¹) = 31
따라서 약 31번의 탐색 필요
```

**장점**:
* 빠른 추정: 계산기 없이도 대략적인 값 파악 가능
* 직관적: 2의 거듭제곱과 10의 거듭제곱 관계를 활용
* 실용적: 대부분의 경우 충분히 정확한 추정

---

#### 방법 2: 직접 계산

```
log₂(2³¹) = 31
log₂(10⁶) = log₂(10) × 6 ≈ 3.32 × 6 ≈ 20
log₂(10⁹) = log₂(10) × 9 ≈ 3.32 × 9 ≈ 30
```

---

#### 방법 3: 실제 연산 횟수로 검증

**최악의 경우**:
```
탐색 횟수: 31번
각 반복마다: K = 10,000번의 나눗셈
총 연산: 31 × 10,000 = 310,000번
```

**시간 평가**:
```
310,000 / 10⁸ = 0.0031초 << 2초 (시간 제한)
매우 여유롭게 통과 가능 ✅
```

---

### 정리된 시간 복잡도 분석

**백준 1654번 랜선 자르기**:

1. **알고리즘**: 이분 탐색
2. **탐색 범위**: [1, 최대 랜선 길이]
   * 최대 랜선 길이 ≤ 2³¹-1
3. **탐색 횟수**: log₂(최대 랜선 길이) ≈ 31번
4. **각 반복 연산**: K번의 나눗셈 (K ≤ 10,000)
5. **전체 시간 복잡도**: **O(K × log(최대 랜선 길이))**
6. **실제 연산 횟수**: 31 × 10,000 = 310,000 << 10⁸
7. **시간 평가**: 0.003초 << 2초 (시간 제한)

---

## 3️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 탐색 범위 설정

```java
long left = 1;
long right = maxLength;
```

* **left = 1**: 하한선 (가장 작은 길이)
* **right = maxLength**: 상한선 (가장 긴 랜선의 길이)
* **탐색 범위**: [1, maxLength]

➡️ **탐색 범위는 문제 조건에 맞게 설정**되어 있다.

---

### ② 이분 탐색 루프

```java
while (left <= right) {
    long mid = (left + right) / 2;
    // ...
}
```

* **조건**: `left <= right` (표준 이분 탐색 패턴)
* **중간값**: `(left + right) / 2`
* **반복**: 탐색 범위를 절반씩 줄여나감

➡️ **이분 탐색의 기본 구조**가 코드에 반영되어 있다.

---

### ③ 조건 함수: 만들 수 있는 개수 계산

```java
long count = 0;
for (int i = 0; i < K; i++) {
    count += lengths[i] / mid;
}
```

* **각 랜선을 mid 길이로 자를 수 있는 개수**: `lengths[i] / mid`
* **전체 개수**: 모든 랜선에서 만들 수 있는 개수의 합
* **시간 복잡도**: O(K) (각 반복마다)

➡️ **조건 함수는 O(K) 시간에 계산**되며, 이분 탐색의 각 반복에서 호출된다.

---

### ④ 이분 탐색 조건 분기

```java
if (count >= N) {
    answer = mid;
    left = mid + 1;
} else {
    right = mid - 1;
}
```

* **count >= N**: N개 이상 만들 수 있음
  * 현재 mid가 가능한 값이므로 `answer = mid` 저장
  * 길이를 늘려서 더 큰 값 시도 (`left = mid + 1`)
* **count < N**: N개 미만
  * 길이를 줄여서 더 작은 값 시도 (`right = mid - 1`)

➡️ **이분 탐색의 조건 분기가 정확히 구현**되어 있다.

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 이분 탐색 횟수

* 각 반복마다 탐색 범위가 절반으로 줄어듦
* 최대 랜선 길이가 2³¹-1이면 약 31번의 반복
* 각 반복에서 O(1) 시간 소요 (중간값 계산, 조건 분기)

**예시**:
```
탐색 범위: [1, 2³¹-1]
1번째 반복: 범위를 절반으로 → [1, 2³⁰] 또는 [2³⁰+1, 2³¹-1]
2번째 반복: 범위를 절반으로 → ...
...
31번째 반복: 범위가 1이 됨
```

➡️ **코드의 이분 탐색 구조는 시간 복잡도 O(log(최대 랜선 길이))를 보장**한다.

---

### 각 반복의 연산

* **중간값 계산**: `(left + right) / 2` → O(1)
* **조건 함수**: K번의 나눗셈 → O(K)
* **조건 분기**: O(1)

**전체 시간 복잡도**: O(K × log(최대 랜선 길이))

➡️ **각 반복은 O(K) 시간에 수행**되므로, 전체 시간 복잡도는 탐색 횟수 × K이다.

---

## 5️⃣ 공간 복잡도와 코드의 대응

### 랜선 길이 배열

* K개의 랜선 길이를 저장: O(K)
* K ≤ 10,000이므로 충분히 작음

### 추가 메모리

* `left`, `right`, `mid`, `count`, `answer` 등: O(1)
* 이분 탐색에 필요한 변수들만 사용

**전체 공간 복잡도**: **O(K)**

➡️ **공간 복잡도는 입력 크기에 비례**하며, 추가 메모리는 상수 공간이다.

---

## 6️⃣ 일반적인 방법과의 비교

### 완전 탐색 방법 (O(K × 최대 랜선 길이))

```java
long answer = 0;
for (long length = 1; length <= maxLength; length++) {
    long count = 0;
    for (int i = 0; i < K; i++) {
        count += lengths[i] / length;
    }
    if (count >= N) {
        answer = length;
    }
}
```

**문제점**:
* 최대 랜선 길이가 2³¹-1이면 약 21억 번의 반복 필요
* 시간 제한 2초 내에 불가능
* 시간 초과 발생

### 이분 탐색 방법 (O(K × log(최대 랜선 길이))) ✅

```java
long left = 1;
long right = maxLength;
long answer = 0;

while (left <= right) {
    long mid = (left + right) / 2;
    long count = 0;
    for (int i = 0; i < K; i++) {
        count += lengths[i] / mid;
    }
    if (count >= N) {
        answer = mid;
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
```

**장점**:
* 약 31번의 탐색으로 해결
* 시간 제한 내에 충분히 해결 가능
* 효율적인 알고리즘

➡️ **이분 탐색 방법이 이 문제에 필수적**이다.

---

## 7️⃣ 지수 관계를 이용한 추정 방법의 활용

### 유용한 근사값

```
일반적인 관계:
- log₂(10) ≈ 3.32
- log₁₀(2) ≈ 0.301

유용한 근사값:
- 2¹⁰ ≈ 10³ (1,024 ≈ 1,000)
- 2²⁰ ≈ 10⁶ (1,048,576 ≈ 1,000,000)
- 2³⁰ ≈ 10⁹ (1,073,741,824 ≈ 1,000,000,000)

로그 추정:
- log₂(10ⁿ) ≈ 3.32n
- log₂(2ⁿ) = n
```

### 실전 활용 예시

**문제**: log₂(1,000,000)을 추정하라.

**방법 1: 지수 관계 활용**
```
2¹⁰ ≈ 10³
2²⁰ ≈ (10³)² = 10⁶
따라서 log₂(10⁶) ≈ 20
```

**방법 2: 직접 계산**
```
log₂(10⁶) = log₂(10) × 6 ≈ 3.32 × 6 ≈ 20
```

**결과**: 두 방법 모두 약 20으로 추정 가능 ✅

**참고**: 이분 탐색의 시간 복잡도 분석에 유용한 방법입니다. 일반적인 이분 탐색의 시간 복잡도는 [이분 탐색 정리](../binary-search.md)를 참고하세요.

---

## 8️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **랜선 길이를 효율적으로 탐색**하고
* 알고리즘 논의에서 설명한 **이분 탐색 구조**를 그대로 구현하며
* **시간 복잡도 분석 과정**을 코드로 구현한

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

**특히 시간 복잡도 분석 과정**에서:
* 지수 관계를 이용한 추정 방법 (2¹⁰ ≈ 10³)
* 실제 연산 횟수로 검증 (31 × 10,000 = 310,000)
* 시간 제한과 비교 (0.003초 << 2초)

이러한 사고 과정이 코드의 효율성을 보장하고 있음을 확인할 수 있다.

