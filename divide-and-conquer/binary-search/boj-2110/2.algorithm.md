# 알고리즘: 이분 탐색 (Binary Search)

> 📖 **전체 알고리즘 설명**: [이분 탐색 정리](../binary-search.md)

이 문제는 **파라메트릭 서치(Parametric Search)**를 사용하여 해결합니다. 일반적인 이분 탐색이 정렬된 배열에서 특정 값을 찾는 것과 달리, 이 문제는 **공유기 사이의 거리**라는 값을 탐색 대상으로 하며, 조건 함수를 통해 해당 거리로 C개 이상의 공유기를 설치할 수 있는지 판단합니다.

알고리즘은 두 단계로 구성됩니다:

1. **조건 함수**: 특정 거리로 C개 이상의 공유기를 설치할 수 있는지 확인
2. **이분 탐색**: 조건을 만족하는 최대 거리를 찾기

상위 폴더의 [이분 탐색 정리 문서](../binary-search.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 구현 패턴

### 1단계: 조건 함수 구현

**목적**: 주어진 거리 `distance`로 C개 이상의 공유기를 설치할 수 있는지 판단

**동작 방식**:
* 첫 집에 공유기를 설치하고 시작
* 정렬된 집 배열을 순회하며, 이전 공유기 위치 + `distance` 이상인 최소 위치에 다음 공유기 설치
* 설치된 공유기 개수가 C개 이상이면 `true`, 미만이면 `false` 반환

```java
// 조건 함수: 특정 거리로 C개 이상 설치할 수 있는가?
boolean canInstall(long distance, long[] houses, int c) {
    int count = 1;  // 첫 집에 공유기 설치
    long lastPos = houses[0];
    
    for (int i = 1; i < houses.length; i++) {
        if (houses[i] - lastPos >= distance) {
            count++;
            lastPos = houses[i];
        }
    }
    
    return count >= c;
}
```

### 2단계: 이분 탐색으로 최대 거리 찾기

**목적**: 조건을 만족하는 최대 거리를 효율적으로 탐색

**동작 방식**:
* 집 좌표를 정렬하여 조건 함수 사용 가능하게 함
* 탐색 범위를 [1, max_coordinate - min_coordinate]로 설정
* 중간값에 대해 조건 함수를 호출하여 가능 여부 확인
* 가능하면 거리를 늘리고, 불가능하면 거리를 줄여서 탐색 범위를 좁힘

```java
// 이분 탐색
Arrays.sort(houses);
long left = 1;
long right = houses[houses.length - 1] - houses[0];
long answer = 0;

while (left <= right) {
    long mid = (left + right) / 2;
    
    if (canInstall(mid, houses, c)) {
        answer = mid;  // 현재 거리가 가능하므로 저장
        left = mid + 1;  // 더 큰 거리 시도
    } else {
        right = mid - 1;  // 더 작은 거리 시도
    }
}

System.out.println(answer);
```

이 구현은 [이분 탐색 정리](../binary-search.md)의 **파라메트릭 서치 패턴 4**를 따릅니다.

### 구현 시 주의사항

* **long 타입 사용**: 좌표가 최대 10⁹이므로 long 타입 사용
* **정렬 필수**: 집 좌표를 먼저 정렬해야 조건 함수가 올바르게 동작함
* **오버플로우 방지**: `(left + right) / 2` 대신 `left + (right - left) / 2` 사용 가능
* **정답 저장**: `canInstall(mid)`가 true일 때 `answer = mid`로 저장해야 최대 거리를 찾을 수 있음

---

## 시간 복잡도 및 공간 복잡도

### 시간 복잡도

* **정렬**: O(N log N)
* **이분 탐색**: O(N log(범위))
  * 탐색 횟수: log₂(최대 거리) ≈ log₂(10⁹) ≈ 30번
  * 각 반복마다: O(N) (공유기 설치 가능 여부 확인)
* **전체 시간 복잡도**: **O(N log N)**

### 공간 복잡도

* **집 좌표 배열**: O(N)
* **추가 메모리**: O(1) (변수 몇 개만 사용)
* **전체 공간 복잡도**: **O(N)**
