# Main.java 설계 근거 정리

## 1️⃣ 알고리즘 선택 근거

이 문제를 이분 탐색으로 해결할 수 있는 핵심은 **"가장 인접한 두 공유기 사이의 거리"를 변수로 보는 것**입니다.

### 이분 탐색 적용 가능 조건

**1. 단조성 존재**
* 가장 인접한 거리를 `y`라고 할 때, 거리 `y = 1`인 경우 항상 만족 (모든 집에 공유기 설치 가능)
* 거리 `y`를 늘려갈수록 공유기 설치가 어려워지며, 특정 임계점을 넘으면 C개를 배치할 수 없게 됨
* 즉, **거리가 작을수록 설치 가능, 거리가 클수록 설치 불가능**한 단조성을 가짐
* 이 단조성을 활용하여 조건을 만족하는 최대 거리를 효율적으로 찾을 수 있음

**2. 탐색 범위 명확**
* 거리의 범위: [1, max_coordinate - min_coordinate] (최대 10⁹)
* 가능한 거리의 범위가 매우 크므로 완전 탐색은 O(N × 범위)로 시간 초과
* 단조성을 활용하면 이분 탐색으로 임계점을 효율적으로 찾을 수 있음

**3. 조건 판단 가능**
* 각 거리에 대해 O(N) 시간에 판단 가능 (조건 함수에서 그리디 알고리즘 사용)
* 조건 함수 `canInstall(distance) >= C`를 통해 가능 여부 확인
  * True → 거리를 늘림 (더 큰 값 시도)
  * False → 거리를 줄임 (더 작은 값 시도)

➡️ 이는 [이분 탐색 정리](../binary-search.md)에서 설명하는 **파라메트릭 서치**의 전형적인 예시입니다.

### 선택 이유

**효율성**: 
* 시간 복잡도 O(N log N)로 매우 효율적
  * 정렬: O(N log N)
  * 이분 탐색: O(N log(범위)) - 탐색 횟수 log₂(10⁹) ≈ 30번, 각 반복마다 O(N)
* 실제 연산: 약 9,600,000 << 10⁸ (시간 제한 2초 내 충분)

**적용 가능성**:
* 조건을 만족하는 최대값을 찾는 전형적인 파라메트릭 서치 문제
* 이분 탐색 패턴을 그대로 적용 가능

**결론**: 이분 탐색을 선택 ✅

---

## 2️⃣ 시간 복잡도 분석

**단계별 분석**:
* **정렬**: O(N log N) - N = 200,000일 때 약 3,600,000번의 연산
* **이분 탐색**: O(N log(범위))
  * 탐색 범위: [1, max_coordinate - min_coordinate] (최대 10⁹)
  * 탐색 횟수: log₂(10⁹) ≈ 30번 (2³⁰ ≈ 10⁹ 관계 활용)
  * 각 반복마다: O(N) - 공유기 설치 가능 여부 확인
  * 총 이분탐색 연산: 30 × 200,000 = 6,000,000

**전체 시간 복잡도**: O(N log N) + O(N log(범위)) = **O(N log N)**  
**실제 연산**: 약 9,600,000 << 10⁸ (시간 제한 2초 내 충분)
