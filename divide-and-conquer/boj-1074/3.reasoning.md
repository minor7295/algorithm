# Main.java 설계 근거

## 1) 알고리즘 선택 근거
이 문제의 핵심은 `(r, c)` 한 칸의 방문 순서만 구하는 것입니다.

입력 제한에서 `N <= 15`이므로 최악의 배열 크기는 `2^15 x 2^15`입니다.
여기서 `2^10 ≈ 10^3`이라는 근사를 사용하면,
- `2^15 = 2^10 x 2^5 ≈ 10^3 x 32 = 3.2 x 10^4`
- 전체 칸 수는 `(3.2 x 10^4)^2 ≈ 10^9`
정도로 볼 수 있습니다.

즉 최대 약 10억 칸을 직접 순회하는 방식은 시간 제한(0.5초)에서 비현실적입니다.
따라서 전체 탐색이 아니라, 목표 칸이 속한 부분만 추적하는 방식이 적합합니다.

## 2) 분할 정복 관점의 판단
현재 정사각형을 4등분하면 Z 방문 순서는 항상 고정됩니다.
- UL -> UR -> LL -> LR

현재 단계에서 한 사분면의 크기를 `quarter`라고 할 때, 누적 오프셋은 아래와 같습니다.
- UL: `0 * quarter`
- UR: `1 * quarter`
- LL: `2 * quarter`
- LR: `3 * quarter`

따라서 먼저 `(r, c)`가 4분면 중 어디에 속하는지 판단하고, 해당 사분면 이전에 방문되는 칸 수를 정답에 누적합니다.
그 다음에는 "선택된 사분면 내부"를 다시 같은 방식으로 4분할하여, 같은 판단을 반복합니다.
이 과정을 블록 크기가 `1 x 1`이 될 때까지 이어가면 정답을 얻을 수 있습니다.

## 3) 재귀 구현 예시
예를 들어 `N=3, r=5, c=2`를 보겠습니다.

1. `N=3`, `half=4`, `quarter=16`
- `(r, c)=(5,2)`는 LL에 속합니다.
- 오프셋 `2*16=32`를 누적합니다.
- 다음 좌표는 `(r-half, c)=(1,2)`이고, `N=2`로 재귀 호출합니다.

2. `N=2`, `half=2`, `quarter=4`
- `(r, c)=(1,2)`는 UR에 속합니다.
- 오프셋 `1*4=4`를 누적합니다. (총 36)
- 다음 좌표는 `(r, c-half)=(1,0)`이고, `N=1`로 재귀 호출합니다.

3. `N=1` (베이스 케이스)
- `2 x 2`에서 `(1,0)`의 순서는 `2`입니다.

최종 정답은 `32 + 4 + 2 = 38`입니다.

이처럼 재귀 구현은 "사분면 판별 -> 오프셋 누적 -> 좌표 축소"라는 문제의 정의를 그대로 코드로 옮긴 방식입니다.

## 4) 복잡도 근거
- 시간 복잡도: `O(N)`입니다.
- 공간 복잡도: `O(N)`입니다. (재귀 호출 스택)

`N <= 15`이므로 재귀 깊이는 최대 15이며 충분히 안전합니다.
