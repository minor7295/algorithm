# Main.java 설계 근거 정리

이 문서는 **[카카오 인턴] 보석 쇼핑 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **슬라이딩 윈도우 알고리즘 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 슬라이딩 윈도우 알고리즘

### 문제 특성과의 적합성

* 문제 요구사항
  * 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간 찾기
  * 연속된 구간만 가능 (중간에 빠지는 번호가 있으면 안 됨)
  * 가장 짧은 구간이 여러 개면 시작 번호가 가장 작은 것 선택
* 제약 조건
  * `gems 배열 크기 ≤ 100,000` (큰 입력 크기)
  * 효율성 테스트 존재

이 문제는 **슬라이딩 윈도우 알고리즘**을 사용할 수 있는 전형적인 문제로, 다음과 같은 특성이 있다:

* **연속 구간 탐색**: 연속된 인덱스 범위를 탐색하는 문제
* **조건 만족 여부 확인**: 현재 구간에 모든 보석 종류가 포함되어 있는지 확인
* **효율성**: 완전 탐색 O(N²)보다 훨씬 빠른 O(N) 시간 복잡도
* **단조성**: 
  - 구간을 확장하면 보석 종류가 증가하거나 유지됨
  - 구간을 축소하면 보석 종류가 감소하거나 유지됨

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **슬라이딩 윈도우 알고리즘(Sliding Window Algorithm)**이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 전체 보석 종류 개수 파악

```java
Set<String> gemSet = new HashSet<>();
for (String gem : gems) {
    gemSet.add(gem);
}
int totalTypes = gemSet.size();
```

* 알고리즘 문서에서 설명한 대로, **먼저 전체 보석 종류의 개수를 파악**
* `HashSet`을 사용하여 고유한 보석 종류만 저장
* `totalTypes`: 모든 종류를 포함하는지 확인하기 위한 기준값

➡️ **슬라이딩 윈도우 알고리즘의 전제 조건**이 코드에 직접 반영된 것이다.

---

### ② 슬라이딩 윈도우 초기화

```java
Map<String, Integer> window = new HashMap<>();
int left = 0;
int minLength = Integer.MAX_VALUE;
int[] answer = new int[2];
```

* **윈도우 맵**: 현재 구간에 포함된 보석 종류별 개수를 저장
* `left = 0`: 구간의 시작 인덱스
* `minLength`: 찾은 최소 구간 길이
* `answer`: 최종 답안 (시작 번호, 끝 번호)

➡️ **슬라이딩 윈도우 알고리즘의 기본 구조**가 코드에 직접 반영된 것이다.

---

### ③ 구간 확장 구현

```java
for (int right = 0; right < gems.length; right++) {
    window.put(gems[right], window.getOrDefault(gems[right], 0) + 1);
    ...
}
```

* **구간 확장**: `right` 포인터를 증가시켜 구간을 확장
* `window.put(gems[right], ...)`: 새로운 보석을 윈도우에 추가
* `getOrDefault`: 기존에 있으면 개수 증가, 없으면 1로 초기화

이 과정은 알고리즘 문서에서 설명한 **"구간 확장"** 패턴과 정확히 일치한다:

* `right` 포인터를 한 칸씩 이동
* 새로운 보석을 윈도우에 추가
* 보석 종류가 증가하거나 유지됨

➡️ 알고리즘 문서에서 설명한 **"구간 확장"** 패턴이 코드에 구현되어 있다.

---

### ④ 조건 확인 및 구간 축소 구현

```java
while (window.size() == totalTypes) {
    int currentLength = right - left + 1;
    if (currentLength < minLength) {
        minLength = currentLength;
        answer[0] = left + 1;
        answer[1] = right + 1;
    }
    
    window.put(gems[left], window.get(gems[left]) - 1);
    if (window.get(gems[left]) == 0) {
        window.remove(gems[left]);
    }
    left++;
}
```

* **조건 확인**: `window.size() == totalTypes`로 모든 종류가 포함되었는지 확인
* **최소 길이 업데이트**: 현재 구간이 더 짧으면 답안 업데이트
* **구간 축소**: `left` 포인터를 증가시켜 구간을 축소
* **HashMap 관리**: 보석 개수가 0이 되면 HashMap에서 제거

이 과정은 알고리즘 문서에서 설명한 **"조건 확인 및 구간 축소"** 패턴과 정확히 일치한다:

* 모든 종류가 포함되면 최소 길이 확인
* 가능한 한 구간을 축소하여 더 짧은 구간 찾기
* `while` 루프로 최대한 축소

➡️ 알고리즘 문서에서 설명한 **"조건 확인 및 구간 축소"** 패턴이 코드에 구현되어 있다.

---

## 3️⃣ 입력 처리 방식

### Solution 클래스 사용

```java
class Solution {
    public int[] solution(String[] gems) {
        ...
    }
}
```

* 프로그래머스 플랫폼의 표준 형식
* `String[] gems`: 진열대에 나열된 보석 배열
* 반환 타입: `int[]` (시작 번호, 끝 번호)

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 연산별 시간 복잡도

* **각 원소 방문 횟수**: 최대 2번 (left와 right가 각각 한 번씩)
* **HashMap 연산**: O(1) per operation
* **전체 시간 복잡도**: **O(N)**

### 코드에서의 대응

```java
for (int right = 0; right < gems.length; right++) {  // O(N)
    window.put(gems[right], ...);  // O(1)
    
    while (window.size() == totalTypes) {  // 최대 O(N) 전체
        ...
        left++;  // O(1)
    }
}
```

* 외부 루프: O(N) - 각 원소를 한 번씩 방문
* 내부 while 루프: 각 원소당 최대 한 번 실행되므로 전체 O(N)
* HashMap 연산: 각각 O(1)
* 전체 시간 복잡도: **O(N)**

➡️ 알고리즘 문서에서 설명한 **"시간 복잡도 분석"**이 코드의 실제 동작과 일치한다.

---

## 5️⃣ 공간 복잡도 분석

### HashMap

* `window`: 최대 N개의 보석을 저장할 수 있음
* **공간: O(N)**

### 기타 변수

* `gemSet`: 최대 N개의 보석 종류 저장
* `answer`, `left`, `right` 등: O(1) 공간

### 전체 공간 복잡도

* **O(N)** - HashMap과 HashSet 사용

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 슬라이딩 윈도우 알고리즘 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 시간 복잡도 O(N)으로 매우 효율적
* 코드가 간결함
* 효율성 테스트 통과 가능

**단점:**
* 없음 (이 문제에서는 최적의 방법)

### 방법 2: 완전 탐색

```java
int minLength = Integer.MAX_VALUE;
int[] answer = new int[2];

for (int left = 0; left < gems.length; left++) {
    for (int right = left; right < gems.length; right++) {
        Set<String> set = new HashSet<>();
        for (int i = left; i <= right; i++) {
            set.add(gems[i]);
        }
        if (set.size() == totalTypes) {
            int length = right - left + 1;
            if (length < minLength) {
                minLength = length;
                answer[0] = left + 1;
                answer[1] = right + 1;
            }
        }
    }
}
```

**장점:**
* 구현이 직관적

**단점:**
* 시간 복잡도 O(N³)로 비효율적
* N = 100,000이면 시간 초과
* 효율성 테스트 통과 불가

### 방법 3: 이진 탐색 + 슬라이딩 윈도우

```java
// 구간 길이를 이진 탐색으로 찾기
int leftLen = 1, rightLen = gems.length;
while (leftLen <= rightLen) {
    int midLen = (leftLen + rightLen) / 2;
    if (isValidLength(gems, midLen, totalTypes)) {
        rightLen = midLen - 1;
    } else {
        leftLen = midLen + 1;
    }
}
```

**장점:**
* 시간 복잡도 O(N log N)

**단점:**
* 구현이 복잡함
* 슬라이딩 윈도우만으로도 O(N)에 해결 가능하므로 불필요

➡️ **슬라이딩 윈도우 알고리즘을 사용하는 것이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N) 시간 복잡도로 문제 제약 조건 내에서 충분히 빠름
* **정확함**: 모든 엣지 케이스 처리

### 추가 최적화 가능성

* **조기 종료**: 이미 최소 길이를 찾았을 때 조기 종료 가능하지만, 구현이 복잡해짐
* **변수 최적화**: 현재 구현이 이미 최적화됨

현재 구현이 문제 제약 조건 내에서 충분히 효율적이다.

---

## 8️⃣ 인덱스 변환의 중요성 (0-based → 1-based)

### 문제 요구사항

* **진열대 번호**: 1번부터 시작 (문제에서 요구하는 반환값)
* **배열 인덱스**: 0번부터 시작 (코드 내부에서 사용)

### 인덱스 매핑 관계

```
배열 인덱스    진열대 번호    보석
gems[0]    →    1번      →  "DIA"
gems[1]    →    2번      →  "RUBY"
gems[2]    →    3번      →  "RUBY"
...
gems[6]    →    7번      →  "SAPPHIRE"
```

### 코드에서의 반영

```java
// 예: left=2, right=6 (배열 인덱스)
// → 진열대 3번부터 7번까지
answer[0] = left + 1;   // 2 + 1 = 3 (진열대 시작 번호)
answer[1] = right + 1;  // 6 + 1 = 7 (진열대 끝 번호)
```

**예시:**
- `left=2, right=6` (배열 인덱스)
- 반환값: `[3, 7]` (진열대 번호)
- 의미: 진열대 3번부터 7번까지의 보석을 구매

➡️ **인덱스 변환이 코드에 명확히 구현되어 있으며, 문제의 요구사항을 정확히 반영한다.**

---

## 9️⃣ HashMap을 사용한 보석 종류 추적

### 왜 HashMap인가?

* **빠른 조회**: O(1) 시간에 보석 개수 확인
* **동적 관리**: 보석 추가/제거가 O(1)
* **종류 개수 확인**: `window.size()`로 O(1)에 확인

### 코드에서의 활용

```java
window.put(gems[right], window.getOrDefault(gems[right], 0) + 1);  // 추가
window.put(gems[left], window.get(gems[left]) - 1);  // 제거
if (window.get(gems[left]) == 0) {
    window.remove(gems[left]);  // 0이면 제거
}
window.size() == totalTypes  // 모든 종류 포함 여부 확인
```

➡️ **HashMap의 효율적인 활용이 코드에 구현되어 있다.**

---

## 🔟 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **연속 구간 탐색 구조**를 인식하고
* 알고리즘 문서에서 설명한 **슬라이딩 윈도우 알고리즘**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 1️⃣1️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 수학적 접근 없이 슬라이딩 윈도우 알고리즘 활용
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(N))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **정확성**: 모든 엣지 케이스 처리 (1개 종류, 모든 종류 등)

