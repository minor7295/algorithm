# [카카오 인턴] 보석 쇼핑

## 📌 문제 요약

진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾는 문제입니다.

진열대 번호 순서대로 보석들의 이름이 저장된 배열 `gems`가 주어질 때, 모든 보석을 하나 이상 포함하는 가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 반환해야 합니다.

만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 반환합니다.

---

## 🔍 문제 설명

* **목표**: 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 연속 구간 찾기
* **연속 구간**: 진열대 번호가 연속된 구간 (중간에 빠지는 번호가 있으면 안 됨)
* **인덱스 주의사항**: 
  - **배열 인덱스**: 0부터 시작 (코드 내부에서 사용)
  - **진열대 번호**: 1부터 시작 (문제에서 요구하는 반환값)
  - 예: `gems[0]`은 진열대 1번, `gems[2]`는 진열대 3번
* **우선순위**: 
  - 가장 짧은 구간
  - 같은 길이면 시작 번호가 가장 작은 구간

---

## 📥 입력 조건

* `gems` 배열의 크기: 1 이상 100,000 이하
* `gems` 배열의 각 원소: 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열
* `gems` 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 저장됨

---

## 📤 출력 조건

* 가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 배열에 담아 반환
* 배열 형태: `[시작 번호, 끝 번호]` (1-based index)

---

## 💡 문제 핵심 해석

이 문제는 **슬라이딩 윈도우(Sliding Window) 알고리즘**을 사용하여 해결할 수 있는 전형적인 문제입니다.

### 핵심 조건

* **모든 종류 포함**: 현재 구간에 모든 보석 종류가 적어도 1개씩 있어야 함
* **가장 짧은 구간**: 조건을 만족하는 구간 중 길이가 가장 짧은 것
* **연속 구간**: 진열대 번호가 연속된 구간만 가능

### 슬라이딩 윈도우 접근 가능성

이 문제는 **슬라이딩 윈도우 알고리즘이 적합**합니다:

* **left 포인터**: 구간의 시작 인덱스
* **right 포인터**: 구간의 끝 인덱스
* **조건 확인**: 현재 구간에 모든 보석 종류가 포함되어 있는지 확인
* **구간 확장/축소**:
  - 모든 종류가 포함되지 않으면 `right` 증가 (구간 확장)
  - 모든 종류가 포함되면 `left` 증가 (구간 축소하여 더 짧은 구간 찾기)

예를 들어, `gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]`인 경우:

**진열대 번호와 배열 인덱스 매핑:**
- 진열대 1번 = gems[0] = "DIA"
- 진열대 2번 = gems[1] = "RUBY"
- 진열대 3번 = gems[2] = "RUBY"
- 진열대 4번 = gems[3] = "DIA"
- 진열대 5번 = gems[4] = "DIA"
- 진열대 6번 = gems[5] = "EMERALD"
- 진열대 7번 = gems[6] = "SAPPHIRE"
- 진열대 8번 = gems[7] = "DIA"

**슬라이딩 윈도우 탐색 과정 (배열 인덱스 기준):**
```
전체 보석 종류: {DIA, RUBY, EMERALD, SAPPHIRE} (4종류)

left=0(1번), right=0(1번): {DIA} → 부족
left=0(1번), right=1(2번): {DIA, RUBY} → 부족
left=0(1번), right=2(3번): {DIA, RUBY, RUBY} → 부족
left=0(1번), right=5(6번): {DIA, RUBY, RUBY, DIA, DIA, EMERALD} → 부족
left=0(1번), right=6(7번): {DIA, RUBY, RUBY, DIA, DIA, EMERALD, SAPPHIRE} → 모든 종류 포함! (길이 7)
  → 반환값: [1, 7]
left=1(2번), right=6(7번): {RUBY, RUBY, DIA, DIA, EMERALD, SAPPHIRE} → 모든 종류 포함! (길이 6)
  → 반환값: [2, 7]
left=2(3번), right=6(7번): {RUBY, DIA, DIA, EMERALD, SAPPHIRE} → 모든 종류 포함! (길이 5) ✅
  → 반환값: [3, 7] (최종 답)
left=3(4번), right=6(7번): {DIA, DIA, EMERALD, SAPPHIRE} → 부족 (RUBY 없음)
```

➡️ **슬라이딩 윈도우 알고리즘으로 모든 가능한 구간을 효율적으로 탐색**할 수 있습니다.

---

## 🧠 해결 전략 개요

1. **보석 종류 개수 파악**: `gems` 배열에서 고유한 보석 종류의 개수를 구함
2. **슬라이딩 윈도우 초기화**: `left = 0`, `right = 0`
3. **구간 탐색 반복**:
   - 모든 종류가 포함되지 않으면 `right` 증가하여 구간 확장
   - 모든 종류가 포함되면 현재 구간 길이 확인 및 최소값 업데이트 후 `left` 증가
4. **결과 반환**: 가장 짧은 구간의 시작과 끝 번호 반환
   - 배열 인덱스(0-based)를 진열대 번호(1-based)로 변환: `인덱스 + 1`
   - 예: `left=2, right=6` → 반환값 `[3, 7]`

---

## ✨ 예시

### 예시 1: 문제에서 제공한 예제

**입력**
```
gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]
```

**처리 과정 (배열 인덱스 기준, 괄호 안은 진열대 번호)**
```
전체 보석 종류: 4종류 (DIA, RUBY, EMERALD, SAPPHIRE)

left=0(1번), right=0(1번): [DIA] → 종류 1개, 부족
left=0(1번), right=1(2번): [DIA, RUBY] → 종류 2개, 부족
left=0(1번), right=2(3번): [DIA, RUBY, RUBY] → 종류 2개, 부족
left=0(1번), right=3(4번): [DIA, RUBY, RUBY, DIA] → 종류 2개, 부족
left=0(1번), right=4(5번): [DIA, RUBY, RUBY, DIA, DIA] → 종류 2개, 부족
left=0(1번), right=5(6번): [DIA, RUBY, RUBY, DIA, DIA, EMERALD] → 종류 3개, 부족
left=0(1번), right=6(7번): [DIA, RUBY, RUBY, DIA, DIA, EMERALD, SAPPHIRE] → 종류 4개, 모두 포함! (길이 7)
  → 최소 길이: 7, 구간: [1, 7] (인덱스 0→1, 6→7로 변환)
left=1(2번), right=6(7번): [RUBY, RUBY, DIA, DIA, EMERALD, SAPPHIRE] → 종류 4개, 모두 포함! (길이 6)
  → 최소 길이: 6, 구간: [2, 7] (인덱스 1→2, 6→7로 변환)
left=2(3번), right=6(7번): [RUBY, DIA, DIA, EMERALD, SAPPHIRE] → 종류 4개, 모두 포함! (길이 5)
  → 최소 길이: 5, 구간: [3, 7] (인덱스 2→3, 6→7로 변환) ✅
left=3(4번), right=6(7번): [DIA, DIA, EMERALD, SAPPHIRE] → 종류 3개, 부족 (RUBY 없음)
left=3(4번), right=7(8번): [DIA, DIA, EMERALD, SAPPHIRE, DIA] → 종류 3개, 부족
...
```

**출력**
```
[3, 7]
```

### 예시 2: ["AA", "AB", "AC", "AA", "AC"]

**입력**
```
gems = ["AA", "AB", "AC", "AA", "AC"]
```

**처리 과정**
```
전체 보석 종류: 3종류 (AA, AB, AC)

left=0, right=0: [AA] → 종류 1개, 부족
left=0, right=1: [AA, AB] → 종류 2개, 부족
left=0, right=2: [AA, AB, AC] → 종류 3개, 모두 포함! (길이 3)
  → 최소 길이: 3, 구간: [1, 3] ✅
left=1, right=2: [AB, AC] → 종류 2개, 부족
left=1, right=3: [AB, AC, AA] → 종류 3개, 모두 포함! (길이 3)
  → 최소 길이: 3 (같음), 구간: [2, 4] (시작 번호가 더 크므로 무시)
```

**출력**
```
[1, 3]
```

### 예시 3: ["XYZ", "XYZ", "XYZ"]

**입력**
```
gems = ["XYZ", "XYZ", "XYZ"]
```

**처리 과정**
```
전체 보석 종류: 1종류 (XYZ)

left=0, right=0: [XYZ] → 종류 1개, 모두 포함! (길이 1)
  → 최소 길이: 1, 구간: [1, 1] ✅
```

**출력**
```
[1, 1]
```

### 예시 4: ["ZZZ", "YYY", "NNNN", "YYY", "BBB"]

**입력**
```
gems = ["ZZZ", "YYY", "NNNN", "YYY", "BBB"]
```

**처리 과정**
```
전체 보석 종류: 4종류 (ZZZ, YYY, NNNN, BBB)

left=0, right=0: [ZZZ] → 종류 1개, 부족
left=0, right=1: [ZZZ, YYY] → 종류 2개, 부족
left=0, right=2: [ZZZ, YYY, NNNN] → 종류 3개, 부족
left=0, right=3: [ZZZ, YYY, NNNN, YYY] → 종류 3개, 부족
left=0, right=4: [ZZZ, YYY, NNNN, YYY, BBB] → 종류 4개, 모두 포함! (길이 5)
  → 최소 길이: 5, 구간: [1, 5] ✅
```

**출력**
```
[1, 5]
```

---

## 📝 정리

이 문제는 **슬라이딩 윈도우 알고리즘**을 사용하여 해결할 수 있는 전형적인 문제입니다.

* **핵심 조건**: 모든 종류의 보석을 포함하는 가장 짧은 연속 구간 찾기
* **전략**: left와 right 포인터로 구간을 탐색하며 모든 종류가 포함되는 최소 구간 찾기
* **인덱스 변환**: 배열 인덱스(0-based)를 진열대 번호(1-based)로 변환하여 반환
* **시간 복잡도**: O(N) - 각 원소를 최대 2번 방문
* **공간 복잡도**: O(N) - 보석 종류를 저장하기 위한 HashMap 사용

