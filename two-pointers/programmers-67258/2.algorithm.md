# 알고리즘: 슬라이딩 윈도우 알고리즘 (Sliding Window Algorithm)

> 📖 **전체 알고리즘 설명**: [투 포인터 알고리즘 정리](../two-pointers.md)

이 문제는 **슬라이딩 윈도우 알고리즘(Sliding Window Algorithm)**을 사용하여 해결합니다.  
상위 폴더의 [투 포인터 알고리즘 정리 문서](../two-pointers.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 슬라이딩 윈도우 적용

### 문제 특성

* **모든 종류 포함**: 현재 구간에 모든 보석 종류가 적어도 1개씩 있어야 함
* **가장 짧은 구간**: 조건을 만족하는 구간 중 길이가 가장 짧은 것
* **연속 구간**: 진열대 번호가 연속된 구간만 가능
* **입력 크기**: gems 배열 크기 ≤ 100,000 (큰 입력 크기)

---

## 이 문제의 특이사항

### 1️⃣ 슬라이딩 윈도우 알고리즘 적용 가능 조건

이 문제에서 슬라이딩 윈도우 알고리즘이 적합한 이유:

* **연속 구간 탐색**: 연속된 인덱스 범위를 탐색하는 문제
* **조건 만족 여부 확인**: 현재 구간에 모든 보석 종류가 포함되어 있는지 확인
* **효율성**: 완전 탐색 O(N²)보다 훨씬 빠른 O(N) 시간 복잡도
* **단조성**: 
  - 구간을 확장하면 보석 종류가 증가하거나 유지됨
  - 구간을 축소하면 보석 종류가 감소하거나 유지됨

### 2️⃣ 왜 슬라이딩 윈도우가 효율적인가?

**완전 탐색 방법**:
- 모든 시작점과 끝점을 확인: O(N²)
- 각 구간마다 보석 종류 확인: O(N)
- 총 시간 복잡도: O(N³)
- N = 100,000이면 약 10¹⁵번의 연산 필요 ❌

**슬라이딩 윈도우 방법**:
- 각 원소를 최대 2번 방문: O(N)
- HashMap으로 보석 종류 추적: O(1) per operation
- 총 시간 복잡도: O(N)
- N = 100,000이면 약 10⁵번의 연산 필요 ✅

**예시:**
```
gems = ["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]

완전 탐색: 모든 (left, right) 쌍 확인
- (0,0), (0,1), ..., (0,7)
- (1,1), (1,2), ..., (1,7)
- ...
- 총 O(N²) = O(64) 구간 확인
- 각 구간마다 보석 종류 확인: O(N)
- 총 O(N³) = O(512) 연산

슬라이딩 윈도우: left와 right를 조건에 따라 이동
- left=0, right=0 → right 증가
- left=0, right=6 → 모든 종류 포함 발견
- left=1, right=6 → 모든 종류 포함
- left=2, right=6 → 모든 종류 포함 (최소 길이)
- ...
- 총 O(N) = O(8) 연산
```

### 3️⃣ 시간 복잡도

* **각 원소 방문 횟수**: 최대 2번 (left와 right가 각각 한 번씩)
* **HashMap 연산**: O(1) per operation
* **전체 시간 복잡도**: **O(N)**

제약 조건 `gems 배열 크기 ≤ 100,000`으로 인해 O(N) 시간 복잡도가 필요합니다.

### 4️⃣ 공간 복잡도

* **HashMap**: 보석 종류별 개수를 저장 (최대 N개)
* **전체 공간 복잡도**: **O(N)**

---

## 다른 슬라이딩 윈도우 문제와의 차이점

| 특징 | 일반 부분 수열 합 | 이 문제 (67258) |
|------|-----------------|----------------|
| 조건 | 합이 특정 값 | 모든 종류 포함 |
| 확장 조건 | 합 < 목표값 | 종류 수 < 전체 종류 수 |
| 축소 조건 | 합 >= 목표값 | 종류 수 == 전체 종류 수 |
| 최적화 목표 | 합이 목표값인 구간 | 가장 짧은 구간 |
| 시간 복잡도 | O(N) | O(N) |

---

## 주의사항

### 1️⃣ 인덱스 변환 (0-based → 1-based)

* **배열 인덱스**: 코드 내부에서 사용하는 인덱스 (0부터 시작)
  - `gems[0]` = 첫 번째 보석
  - `gems[2]` = 세 번째 보석
* **진열대 번호**: 문제에서 요구하는 반환값 (1부터 시작)
  - 진열대 1번 = `gems[0]`
  - 진열대 3번 = `gems[2]`
* **변환 공식**: `진열대 번호 = 배열 인덱스 + 1`
* 반환 시 `left + 1`, `right + 1`로 변환 필요

### 2️⃣ HashMap 사용

* 보석 종류별 개수를 추적하기 위해 HashMap 사용
* `window.size() == totalTypes`로 모든 종류 포함 여부 확인
* 개수가 0이 되면 HashMap에서 제거해야 함

### 3️⃣ 최소 길이 업데이트

* 모든 종류가 포함된 상태에서만 최소 길이 확인
* 같은 길이면 시작 번호가 작은 것을 선택 (자동으로 처리됨)

### 4️⃣ 구간 축소 시점

* 모든 종류가 포함된 상태에서 left를 증가시켜 더 짧은 구간 찾기
* `while` 루프로 가능한 한 구간을 축소

---

## 참고

* 전체 투 포인터 알고리즘 설명: [../two-pointers.md](../two-pointers.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

