# Main.java 설계 근거 정리

이 문서는 **BOJ 2018 수들의 합 5 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **투 포인터 알고리즘 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 투 포인터 알고리즘

### 문제 특성과의 적합성

* 문제 요구사항
  * 자연수 N을 연속된 자연수의 합으로 나타내는 방법의 개수
  * 사용하는 자연수는 N 이하여야 함
  * 모든 방법의 개수를 구해야 함
* 제약 조건
  * `1 ≤ N ≤ 10,000,000` (큰 입력 크기)
  * 시간 제한: 2초

이 문제는 **투 포인터 알고리즘**을 사용할 수 있는 전형적인 연속 구간 탐색 문제로, 다음과 같은 특성이 있다:

* **연속된 구간 탐색**: 연속된 자연수의 합을 구하는 문제
* **단조성(Monotonicity)**: 
  - `sum < N`이면 `end` 증가 → sum이 증가 (단조 증가)
  - `sum > N`이면 `start` 증가 → sum이 감소 (단조 감소)
* **효율성**: 완전 탐색 O(N²)보다 훨씬 빠른 O(N) 시간 복잡도

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **투 포인터 알고리즘(Two Pointers Algorithm)**이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 투 포인터 초기화

```java
int start = 1;
int end = 1;
int sum = 0;
int count = 0;
```

* 알고리즘 문서에서 설명한 대로, **두 개의 포인터(start, end)로 구간을 탐색**
* `start = 1`: 연속된 구간의 시작 자연수
* `end = 1`: 연속된 구간의 끝 자연수
* `sum = 0`: 현재 구간의 합 (초기값 0)
* `count = 0`: 방법의 개수

➡️ **투 포인터 알고리즘의 기본 구조**가 코드에 직접 반영된 것이다.

---

### ② 구간 확장 구현

```java
if (sum < N) {
    sum += end;
    end++;
}
```

* **구간 확장**: `sum < N`이면 `end` 포인터를 증가시켜 구간을 확장
* `sum += end`: 새로운 자연수를 구간에 추가
* `end++`: end 포인터를 다음 자연수로 이동

이 과정은 알고리즘 문서에서 설명한 **"구간 확장"** 패턴과 정확히 일치한다:

* 현재 구간의 합이 목표값보다 작으면
* 구간을 확장하여 합을 증가시킴
* 단조 증가 성질을 활용

➡️ 알고리즘 문서에서 설명한 **"구간 확장"** 패턴이 코드에 구현되어 있다.

---

### ③ 구간 축소 구현

```java
else if (sum > N) {
    sum -= start;
    start++;
}
```

* **구간 축소**: `sum > N`이면 `start` 포인터를 증가시켜 구간을 축소
* `sum -= start`: 시작 자연수를 구간에서 제거
* `start++`: start 포인터를 다음 자연수로 이동

이 과정은 알고리즘 문서에서 설명한 **"구간 축소"** 패턴과 정확히 일치한다:

* 현재 구간의 합이 목표값보다 크면
* 구간을 축소하여 합을 감소시킴
* 단조 감소 성질을 활용

➡️ 알고리즘 문서에서 설명한 **"구간 축소"** 패턴이 코드에 구현되어 있다.

---

### ④ 조건 만족 처리

```java
else {
    count++;
    sum -= start;
    start++;
}
```

* **조건 만족**: `sum == N`이면 방법을 하나 찾음
* `count++`: 방법의 개수 증가
* `sum -= start; start++`: 구간을 축소하여 다음 경우 탐색

이 과정은 알고리즘 문서에서 설명한 **"조건 만족"** 패턴과 정확히 일치한다:

* 현재 구간의 합이 목표값과 같으면
* 해를 찾았으므로 개수 증가
* 다음 경우를 탐색하기 위해 구간 축소

➡️ 알고리즘 문서에서 설명한 **"조건 만족"** 패턴이 코드에 구현되어 있다.

---

## 3️⃣ 입력 처리 방식

### BufferedReader 사용

```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
```

* 대량의 입력을 효율적으로 처리하기 위해 `BufferedReader` 사용
* `N ≤ 10,000,000`이므로 입력 최적화가 중요

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 연산별 시간 복잡도

* **각 자연수 방문 횟수**: 최대 2번 (start와 end가 각각 한 번씩)
* **전체 시간 복잡도**: **O(N)**

### 코드에서의 대응

```java
while (start <= N) {  // 최대 N번 반복
    if (sum < N) {
        sum += end;    // O(1)
        end++;         // O(1)
    } else if (sum > N) {
        sum -= start;  // O(1)
        start++;       // O(1)
    } else {
        count++;       // O(1)
        sum -= start;  // O(1)
        start++;       // O(1)
    }
}
```

* 외부 루프: 최대 N번 반복 (start가 1부터 N까지)
* 각 반복마다 O(1) 연산 수행
* 각 자연수는 최대 2번 방문 (start와 end가 각각 한 번씩)
* 전체 시간 복잡도: **O(N)**

➡️ 알고리즘 문서에서 설명한 **"시간 복잡도 분석"**이 코드의 실제 동작과 일치한다.

---

## 5️⃣ 공간 복잡도 분석

### 포인터 변수

* `start`, `end`, `sum`, `count`: 각각 O(1) 공간
* **공간: O(1)**

### 전체 공간 복잡도

* **O(1)** - 추가 메모리 사용 없음

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 투 포인터 알고리즘 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 시간 복잡도 O(N)으로 매우 효율적
* 코드가 간결함
* 메모리 효율적 (O(1))

**단점:**
* 없음 (이 문제에서는 최적의 방법)

### 방법 2: 완전 탐색

```java
int count = 0;
for (int start = 1; start <= N; start++) {
    for (int end = start; end <= N; end++) {
        int sum = 0;
        for (int i = start; i <= end; i++) {
            sum += i;
        }
        if (sum == N) count++;
    }
}
```

**장점:**
* 구현이 직관적

**단점:**
* 시간 복잡도 O(N³)로 비효율적
* N = 10,000,000이면 시간 초과
* 비효율적

### 방법 3: 수학적 접근

```java
int count = 0;
for (int k = 1; k * k <= 2 * N; k++) {
    if (2 * N % k == 0) {
        int m = 2 * N / k;
        if ((m - k + 1) % 2 == 0 && (m - k + 1) / 2 >= 1) {
            count++;
        }
    }
}
```

**장점:**
* 시간 복잡도 O(√N)으로 가장 빠름

**단점:**
* 구현이 복잡함
* 이해하기 어려움
* 수학적 지식 필요

➡️ **투 포인터 알고리즘을 사용하는 것이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N) 시간 복잡도로 문제 제약 조건 내에서 충분히 빠름
* **메모리 효율**: O(1) 공간 복잡도

### 추가 최적화 가능성

* **조기 종료**: `end > N`이 되면 더 이상 구간을 확장할 수 없지만, 현재 구현도 충분히 효율적
* **변수 최적화**: 현재 구현이 이미 최적화됨

현재 구현이 문제 제약 조건 내에서 충분히 효율적이다.

---

## 8️⃣ 단조성(Monotonicity)의 중요성

### 단조성의 의미

**포인터를 한 방향으로만 이동해도 해를 찾을 수 있는 성질**

* `sum < N`이면 `end` 증가 → sum이 증가 (단조 증가)
* `sum > N`이면 `start` 증가 → sum이 감소 (단조 감소)

### 코드에서의 반영

```java
if (sum < N) {
    sum += end;  // sum이 증가
    end++;       // end가 증가
} else if (sum > N) {
    sum -= start;  // sum이 감소
    start++;       // start가 증가
}
```

➡️ 알고리즘 문서에서 설명한 **"단조성"**이 코드에 명확히 구현되어 있다.

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **연속 구간 탐색 구조**를 인식하고
* 알고리즘 문서에서 설명한 **투 포인터 알고리즘**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **단순성**: 복잡한 수학적 접근 없이 투 포인터 알고리즘 활용
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(N))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **메모리 효율**: 추가 메모리 사용 없음 (O(1))

