# Main.java 설계 근거 정리

이 문서는 **BOJ 1158 요세푸스 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **시뮬레이션 개념과 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 과정

### 사고 과정

**고려사항:**

1. **점화식 접근**
   * 요세푸스 문제는 반복 계산으로 해결 가능
   * 단, 제거된 사람을 고려하고 매 단계마다 리스트 크기가 줄어드는 것을 반영해야 함
   * 올바른 점화식: `removeIndex = (currentIndex + K - 1) % currentListSize`

2. **자료구조 선택**
   * 링크드 리스트까지 동원할 필요 없음
   * 배열/리스트로 충분함

3. **메모이제이션 불필요**
   * 이전 결과를 저장할 필요 없음
   * 순차적으로 계산하면 됨

4. **전체 제거 순서 출력**
   * 마지막 생존자만 구하는 것이 아니라 전체 제거 순서가 필요
   * 리스트를 사용하여 제거 과정을 직접 시뮬레이션해야 함

---

### 알고리즘 선택: 리스트 시뮬레이션

**선택: 리스트를 이용한 시뮬레이션**

**이유:**
1. ✅ **전체 제거 순서 출력**: 각 단계에서 제거되는 사람을 자연스럽게 기록 가능
2. ✅ **구현 간단**: 리스트 조작만으로 해결 가능
3. ✅ **직관적**: 문제의 과정을 그대로 구현
4. ✅ **효율적**: N ≤ 5,000이므로 O(N²) 시간 복잡도로 충분

---

### 다른 방법들과의 비교

**1. 수학적 점화식 (생존자만 구할 때)**

요세푸스 생존자 점화식 `J(n, K) = (J(n-1, K) + K - 1) mod n + 1`을 사용하면 마지막 생존자만 구할 때는 매우 효율적(O(N))입니다. 하지만 BOJ 1158번은 전체 제거 순서를 출력해야 하므로, 점화식만으로는 각 단계에서 제거되는 사람을 알 수 없어 부적합합니다.

**2. 큐를 이용한 시뮬레이션**

큐를 사용하여 K-1명을 뒤로 보내고(큐의 앞에서 빼서 뒤에 넣기) K번째 사람을 제거하는 방식입니다. 시간 복잡도는 O(N × K)로, K가 작을 때는 효율적이지만 K가 클 때는 비효율적입니다. 덱(Deque, Double-Ended Queue)을 사용하면 양쪽 끝에서 연산이 가능하여 큐의 회전 연산을 더 편리하게 구현할 수 있지만, 본질적으로는 큐와 동일한 접근 방식입니다.

**3. 링크드 리스트**

이론적으로 제거 연산이 O(1)이지만, K번째 사람을 찾기 위해 순차 탐색이 필요하여 O(K) 시간이 소요됩니다. 전체 시간 복잡도는 O(N × K)로 큐 시뮬레이션과 동일합니다. 링크드 리스트가 유리한 경우는 삭제할 위치를 이미 알고 있을 때인데, 요세푸스 문제에서는 매번 K번째를 찾아야 하므로 이 이점을 활용할 수 없습니다. 또한 구현이 복잡하고 현대 하드웨어에서는 캐시 미스로 인해 실제 성능이 떨어질 수 있어, 요세푸스 문제에서는 거의 불필요합니다.

**4. 세그먼트 트리 / Order Statistic Tree**

세그먼트 트리나 Order Statistic Tree(균형 이진 탐색 트리의 확장)를 사용하면 K번째 요소를 찾고 제거하는 연산을 O(log N) 시간에 수행할 수 있어 전체 시간 복잡도는 O(N log N)입니다. N이 매우 클 때(예: 10⁶ 이상) 유리하지만, 구현이 복잡하고 BOJ 1158번의 제약 조건(N ≤ 5,000)에서는 오버엔지니어링입니다.

**5. 리스트 시뮬레이션 (선택)**

```java
List<Integer> people = new ArrayList<>();
// ... 초기화

while (!people.isEmpty()) {
    currentIndex = (currentIndex + K - 1) % people.size();
    result.add(people.remove(currentIndex));
}
```

시간 복잡도는 O(N²)이지만, N ≤ 5,000이므로 충분히 효율적입니다. 구현이 간단하고 직관적이며, 전체 제거 순서를 자연스럽게 얻을 수 있습니다. 또한 배열의 연속 메모리 접근으로 캐시 효율이 좋아 실제 성능이 우수합니다.

**결론**: BOJ 1158번의 제약 조건(N, K ≤ 5,000)에서는 리스트 시뮬레이션이 구현의 간단함과 효율성의 균형이 가장 좋습니다.

**N이 매우 클 때의 고려사항:**

만약 N이 훨씬 컸다면(예: N ≤ 10⁶, K ≤ 10⁶), 시간 복잡도에 따라 다음과 같이 선택해야 합니다:

- **N ≤ 10⁴, K가 작을 때**: 리스트 시뮬레이션(O(N²)) 또는 큐 시뮬레이션(O(N × K))이 여전히 가능합니다.
- **N ≤ 10⁵, K가 작을 때**: 큐 시뮬레이션(O(N × K))이 적합합니다. K가 작다면 O(N × K)는 O(N²)보다 효율적입니다.
- **N ≤ 10⁶ 이상이거나 K가 클 때**: 세그먼트 트리나 Order Statistic Tree(O(N log N))를 사용해야 합니다. O(N²)나 O(N × K)는 시간 초과가 발생할 수 있습니다.

**링크드 리스트의 적합성**: 링크드 리스트는 요세푸스 문제에서 거의 불필요합니다. 큐와 동일한 O(N × K) 시간 복잡도를 가지지만, 구현이 더 복잡하고 캐시 효율이 떨어집니다. 링크드 리스트가 유리한 경우는 삭제할 위치를 이미 알고 있을 때인데, 요세푸스 문제에서는 매번 K번째를 찾아야 하므로 이 이점을 활용할 수 없습니다. 따라서 N의 크기와 관계없이 큐나 리스트 시뮬레이션을 선택하는 것이 더 적합합니다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 리스트 초기화

```java
List<Integer> people = new ArrayList<>();
for (int i = 1; i <= N; i++) {
    people.add(i);
}
```

* **1부터 N까지의 사람을 리스트에 추가**
* 초기 상태를 리스트로 표현
* 시뮬레이션의 시작 상태 설정

➡️ **시뮬레이션의 초기 상태 설정**이 코드에 반영되어 있다.

---

### ② 제거 과정 반복

```java
while (!people.isEmpty()) {
    currentIndex = (currentIndex + K - 1) % people.size();
    result.add(people.remove(currentIndex));
}
```

* **조건**: 리스트가 비어있지 않은 동안 반복
* **인덱스 계산**: `(currentIndex + K - 1) % people.size()`
  * 현재 리스트 크기를 동적으로 사용
  * 제거된 사람을 고려한 계산
* **제거 및 기록**: 제거된 사람을 결과 리스트에 추가

➡️ **점화식이 코드에 정확히 구현**되어 있다.

---

### ③ 인덱스 자동 조정

**중요한 점:**
* 리스트에서 요소를 제거하면 뒤의 요소들이 앞으로 이동
* 제거된 위치의 인덱스가 다음 시작 위치가 됨
* 별도의 인덱스 조정이 필요 없음

**예시:**
```
리스트: [1, 2, 3, 4, 5], currentIndex = 2
제거: people.remove(2) → 3 제거
결과: [1, 2, 4, 5], currentIndex = 2 (자동으로 다음 시작 위치)
```

➡️ **리스트의 특성이 코드의 동작을 보장**한다.

---

## 3️⃣ 시간 복잡도 분석

### 리스트 제거 연산

* **리스트 제거**: O(N) (최악의 경우)
* **반복 횟수**: N번 (모든 사람 제거)
* **전체 시간 복잡도**: **O(N²)**

### 실제 연산 횟수

**최악의 경우:**
```
N = 5,000
각 제거마다 평균적으로 N/2번의 이동
총 연산: N × (N/2) = N²/2 = 12,500,000
```

**시간 평가:**
```
12,500,000 / 10⁸ = 0.125초 << 2초 (시간 제한)
매우 여유롭게 통과 가능 ✅
```

---

## 4️⃣ 공간 복잡도 분석

### 리스트 저장

* **사람 리스트**: O(N)
* **결과 리스트**: O(N)
* **추가 메모리**: O(1) (변수 몇 개)

**전체 공간 복잡도**: **O(N)**

---

## 5️⃣ 정리

이 `Main.java`는 고려사항을 분석하고 적절한 알고리즘을 선택하여 시뮬레이션 알고리즘을 정확히 적용한 해답 코드이다. 설명 → 알고리즘 → 코드가 하나의 사고 흐름으로 완전히 일치하도록 작성되었다.
