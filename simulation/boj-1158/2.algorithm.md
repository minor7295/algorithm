# 알고리즘: 시뮬레이션 (Simulation)

> 📖 **전체 알고리즘 설명**: [시뮬레이션 (Simulation) 정리](../simulation.md)

이 문제는 **시뮬레이션(Simulation)** 알고리즘을 사용하여 해결합니다.

---

## 이 문제에서의 시뮬레이션 적용

### 문제 특성

* **원형 구조**: N명의 사람이 원을 이루고 있음
* **순차적 제거**: K번째 사람을 반복적으로 제거
* **상태 변화**: 매 단계마다 리스트 크기가 줄어듦
* **전체 순서 출력**: 제거되는 순서 전체를 출력해야 함
* **입력 크기**: N, K ≤ 5,000 (작은 크기)

---

## 이 문제의 특이사항

### 1️⃣ 리스트를 이용한 제거 과정 시뮬레이션

이 문제는 **리스트에서 요소를 제거하는 과정을 직접 시뮬레이션**합니다.

**특징:**
* 살아있는 사람들의 리스트를 유지
* 매 단계마다 제거할 인덱스를 계산
* 제거 후 리스트 크기가 자동으로 줄어듦

### 2️⃣ 인덱스 계산 공식

**핵심 공식:**
```
removeIndex = (currentIndex + K - 1) % currentListSize
```

**설명:**
* `currentIndex`: 현재 위치 (이전에 제거한 위치)
* `K - 1`: K번째 사람을 찾기 위해 (K-1)만큼 이동
* `% currentListSize`: 원형 구조를 모듈로 연산으로 표현
* 제거 후 `currentIndex`는 제거된 위치로 자동 조정됨

### 3️⃣ 제거 후 인덱스 조정

**중요한 점:**
* 리스트에서 요소를 제거하면 뒤의 요소들이 앞으로 이동
* 제거된 위치의 인덱스가 다음 시작 위치가 됨
* 별도의 인덱스 조정이 필요 없음 (자동으로 조정됨)

**예시:**
```
리스트: [1, 2, 3, 4, 5], currentIndex = 2
제거: 인덱스 2의 요소 3 제거
결과: [1, 2, 4, 5], currentIndex = 2 (다음 시작 위치)
```

### 4️⃣ 시간 복잡도

* **리스트 제거 연산**: O(N) (최악의 경우)
* **반복 횟수**: N번 (모든 사람 제거)
* **전체 시간 복잡도**: **O(N²)**

**평가:**
* N ≤ 5,000이므로 최대 25,000,000 연산
* 시간 제한 2초 내에 충분히 해결 가능 ✅

### 5️⃣ 공간 복잡도

* **사람 리스트**: O(N)
* **결과 리스트**: O(N)
* **전체 공간 복잡도**: **O(N)**

---

## 핵심 구현 패턴

이 문제에 특화된 시뮬레이션 구현:

```java
List<Integer> people = new ArrayList<>();
// 1부터 N까지 초기화
for (int i = 1; i <= N; i++) {
    people.add(i);
}

List<Integer> result = new ArrayList<>();
int currentIndex = 0;

while (!people.isEmpty()) {
    // 제거할 인덱스 계산: (현재 위치 + K - 1) % 현재 리스트 크기
    currentIndex = (currentIndex + K - 1) % people.size();
    
    // 제거하고 결과에 추가
    result.add(people.remove(currentIndex));
    
    // currentIndex는 이미 조정됨 (제거 후 자동으로 다음 위치)
}
```

---

## 알고리즘 단계별 설명

### 1단계: 초기화

```java
List<Integer> people = new ArrayList<>();
for (int i = 1; i <= N; i++) {
    people.add(i);
}
List<Integer> result = new ArrayList<>();
int currentIndex = 0;
```

* 1부터 N까지의 사람을 리스트에 추가
* 결과를 저장할 리스트 초기화
* 현재 인덱스를 0으로 초기화

### 2단계: 제거 과정 반복

```java
while (!people.isEmpty()) {
    currentIndex = (currentIndex + K - 1) % people.size();
    result.add(people.remove(currentIndex));
}
```

* 리스트가 비어있지 않은 동안 반복
* 제거할 인덱스 계산
* 해당 인덱스의 사람을 제거하고 결과에 추가

### 3단계: 결과 출력

```java
System.out.print("<");
for (int i = 0; i < result.size(); i++) {
    System.out.print(result.get(i));
    if (i < result.size() - 1) {
        System.out.print(", ");
    }
}
System.out.println(">");
```

* 문제 요구 형식에 맞게 출력

---

## 주의사항

### 1. 인덱스 관리

* 리스트에서 요소를 제거하면 뒤의 요소들이 앞으로 이동
* 제거 후 `currentIndex`는 자동으로 다음 시작 위치가 됨
* 별도의 인덱스 조정이 필요 없음

### 2. 모듈로 연산

* `(currentIndex + K - 1) % people.size()`에서 `people.size()`는 현재 리스트 크기
* 매 단계마다 리스트 크기가 줄어들므로 동적으로 계산해야 함

### 3. 출력 형식

* 문제에서 요구하는 형식: `<3, 6, 2, 7, 5, 1, 4>`
* 마지막 요소 뒤에는 쉼표가 없어야 함

---

## 정리

이 문제는 **리스트를 이용한 시뮬레이션**으로 해결할 수 있습니다.

* 리스트에서 요소를 제거하는 과정을 직접 구현
* 매 단계마다 인덱스를 계산하여 제거
* O(N²) 시간 복잡도로 해결 가능 (N ≤ 5,000)

자세한 시뮬레이션 알고리즘 설명은 [시뮬레이션 정리](../simulation.md)를 참고하세요.

