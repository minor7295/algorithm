# 가스관 (BOJ 2931) 알고리즘

## 1) 핵심 아이디어
모든 빈칸(`.`)을 후보로 보면서, 해당 빈칸이 실제로 가져야 하는 연결 방향을 4방향에서 수집합니다.
수집된 방향 집합을 블록 문자로 역매핑하면 정답을 얻을 수 있습니다.

## 2) 방향/마스크 정의
방향 인덱스를 고정합니다.

- `0`: 상
- `1`: 하
- `2`: 좌
- `3`: 우

각 블록의 연결 방향을 비트마스크로 정의합니다.

- `|` -> `3`   (`0011`)
- `-` -> `12`  (`1100`)
- `+` -> `15`  (`1111`)
- `1` -> `10`  (`1010`)  // 하, 우
- `2` -> `9`   (`1001`)  // 상, 우
- `3` -> `5`   (`0101`)  // 상, 좌
- `4` -> `6`   (`0110`)  // 하, 좌
- `M`, `Z` -> `15` (연결 판정 편의)

## 3) 빈칸 하나의 마스크 구성 규칙
빈칸 `(r, c)`에 대해 방향 `d`를 순회하며 다음을 수행합니다.

1. 이웃 좌표 `(nr, nc)` 계산
2. 격자 밖이면 건너뜀
3. 이웃이 `.`이면 건너뜀
4. 이웃 마스크 `neighborMask` 획득
5. 반대 방향 `opposite = d ^ 1` 계산
6. `neighborMask`가 `opposite` 비트를 가지면 현재 방향 `d`를 `mask`에 추가

핵심 식:

```java
if ((neighborMask & (1 << opposite)) != 0) {
    mask |= (1 << d);
}
```

## 4) 정답 판정 규칙
구한 `mask`를 블록 문자로 변환합니다.

- 변환 결과가 `?`가 아니면 유효 블록입니다.
- 해당 칸이 정답이므로 `(r+1, c+1, block)` 출력 후 종료합니다.

## 5) 의사코드
```text
입력 파싱
for r in [0..R-1]:
  for c in [0..C-1]:
    if map[r][c] != '.': continue

    mask = 0
    for d in 0..3:
      nr, nc 계산
      범위 밖이면 continue
      이웃이 '.'이면 continue

      neighborMask = getMask(map[nr][nc])
      opposite = d ^ 1
      if neighborMask가 opposite 비트를 가지면:
        mask에 d 비트 추가

    block = getBlock(mask)
    if block이 유효하면:
      (r+1, c+1, block) 출력
      종료
```

## 6) 복잡도
- 시간 복잡도: `O(R * C)`
- 공간 복잡도: `O(1)` (입력 제외)

격자 최대 크기(`25 x 25`)에서 충분히 빠릅니다.
