# Main.java 설계 근거

## 1) 알고리즘 선택 이유
이 구현은 "빈칸 중심 국소 분석"을 선택했습니다.
선택 이유는 다음과 같습니다.

1. 정답 대상이 블록 하나이므로 탐색 초점이 명확합니다.
2. 문제에서 정답 유일성을 보장하므로 후보 판정이 단순합니다.
3. 전체 경로 추적보다 분기 수가 적고 구현 안정성이 높습니다.

## 2) 대안 접근과 비교

### A. 경로 추적(DFS/BFS) 중심 접근
`M`에서 시작해 경로를 따라가며 끊긴 지점을 찾는 방식입니다.

- 장점: 직관적으로 보입니다.
- 단점: `+` 다중 연결, `1~4` 방향 전환, `M/Z` 인접 예외 처리로 분기 수가 급증합니다.

### B. 빈칸 중심 국소 판정(현재 선택)
각 빈칸에서 "주변 블록이 이 칸을 요구하는 방향"만 계산하는 방식입니다.

- 장점: 로직이 지역적이고 단순합니다.
- 장점: 블록 복원이 마스크 비교로 끝납니다.
- 장점: 구현과 디버깅이 쉽습니다.

결론적으로 이 문제 조건에서는 B가 더 실용적입니다.

## 3) 핵심 설계 포인트

### (1) 방향 모델링 고정
```java
static int[] dr = {-1, 1, 0, 0};
static int[] dc = {0, 0, -1, 1};
```
방향을 인덱스로 고정해 반복 처리 일관성을 확보했습니다.

### (2) oppositeDir 계산
```java
int oppositeDir = d ^ 1;
```
연결은 양방향 조건이므로 이웃 블록의 반대 방향 개방 여부를 검사합니다.

### (3) bitmask 누적
```java
if ((neighborMask & (1 << oppositeDir)) != 0) {
    mask |= (1 << d);
}
```
연결 방향 집합을 정수 하나로 관리해 판정/매핑을 단순화했습니다.

### (4) 경계 검사 선행
```java
if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
```
안전성 확보와 동일한 루프 구조 유지를 동시에 달성했습니다.

### (5) 유효 블록 필터링
```java
char block = getBlock(mask);
if (block == '?') continue;
```
`mask != 0`만으로는 오검출 가능성이 있어 실제 블록 집합 여부를 추가 검증합니다.

## 4) 코드 구조와 의도의 대응
- `parseInput` : 입력 구조를 안정적으로 파싱합니다.
- `getMask` : 블록 -> 방향 집합 변환을 담당합니다.
- `getBlock` : 방향 집합 -> 블록 역매핑을 담당합니다.
- `main` : 빈칸 후보 순회 + 연결 판정 + 정답 출력을 담당합니다.

즉, 각 함수가 "입력", "정방향 매핑", "역매핑", "판정 루프" 역할로 분리되어 있어 유지보수가 쉽습니다.

## 5) 설계 결론
이 구현은 문제의 핵심을 "연결 요구 복원"으로 정확히 모델링했고,
대안 대비 분기 수가 적으며 디버깅 가능성이 높은 구조를 가집니다.

결과적으로 `Main.java`는 문제 조건(유일 정답, 작은 격자, 블록 고정 집합)에 맞춘
가장 실용적인 설계로 정리되어 있습니다.
