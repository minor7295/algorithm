# 시뮬레이션 (Simulation)

시뮬레이션 알고리즘은 문제에서 요구하는 과정을 그대로 구현하여 해결하는 방법입니다.

---

## 📖 시뮬레이션 알고리즘 개요

### 정의

**시뮬레이션(Simulation)**은 문제에서 설명하는 과정을 정확히 그대로 구현하여 해결하는 알고리즘입니다.

* 문제의 규칙과 과정을 코드로 직접 구현
* 복잡한 알고리즘보다는 **정확한 구현**이 중요
* 단계별로 문제의 요구사항을 충실히 따름

---

## 🔍 시뮬레이션 알고리즘의 특징

### 1. 문제 과정의 직접 구현

* 문제에서 설명하는 과정을 그대로 코드로 구현
* 각 단계를 순차적으로 처리
* 중간 상태를 추적하고 관리

### 2. 자료구조 선택의 중요성

* 문제에 따라 적절한 자료구조 선택
* 배열, 리스트, 큐, 스택 등 다양한 자료구조 활용
* 효율적인 삽입/삭제 연산이 중요할 수 있음

### 3. 구현 정확성

* 문제의 규칙을 정확히 구현해야 함
* 경계 조건 처리 중요
* 예외 상황 처리 필요

---

## 🎯 시뮬레이션 알고리즘 적용 조건

### 시뮬레이션을 사용하는 경우

1. **문제의 과정이 명확히 정의됨**
   * 각 단계가 명확히 설명되어 있음
   * 규칙이 복잡하지만 구현 가능함

2. **상태 변화를 추적해야 함**
   * 중간 상태를 저장하고 관리해야 함
   * 이전 상태에 따라 다음 상태가 결정됨

3. **직접 구현이 효율적임**
   * 수학적 공식보다 직접 구현이 간단함
   * 입력 크기가 작거나 중간 정도임

---

## 💻 시뮬레이션 구현 패턴

### 패턴 1: 단계별 처리

```java
// 문제의 각 단계를 순차적으로 처리
while (조건) {
    // 1단계: 현재 상태 확인
    // 2단계: 규칙에 따라 처리
    // 3단계: 상태 업데이트
    // 4단계: 결과 기록
}
```

### 패턴 2: 리스트/배열 조작

```java
// 리스트에서 요소를 제거하면서 처리
List<Integer> list = new ArrayList<>();
// ... 초기화

while (!list.isEmpty()) {
    int index = 계산(); // 제거할 인덱스 계산
    int removed = list.remove(index);
    // 제거된 요소 처리
}
```

### 패턴 3: 상태 추적

```java
// 현재 상태를 추적하면서 시뮬레이션
int currentState = 초기값;
List<Integer> history = new ArrayList<>();

while (조건) {
    history.add(currentState);
    currentState = 다음_상태_계산(currentState);
    
    // 순환 검출 등 필요시 처리
}
```

---

## ⏱️ 시간 복잡도

### 일반적인 시간 복잡도

* **O(N × M)**: N번 반복, 각 반복마다 M 크기 연산
* **O(N²)**: 리스트 제거 연산이 O(N)이고 N번 반복
* **O(N × K)**: N번 반복, 각 반복마다 K 크기 연산

### 공간 복잡도

* **O(N)**: 리스트/배열 저장
* **O(1)**: 추가 메모리 (변수 몇 개)

---

## 📝 시뮬레이션 알고리즘의 장단점

### 장점

* ✅ **직관적**: 문제의 과정을 그대로 구현하므로 이해하기 쉬움
* ✅ **구현 간단**: 복잡한 알고리즘 지식이 필요 없음
* ✅ **디버깅 용이**: 각 단계를 확인하기 쉬움

### 단점

* ❌ **비효율적일 수 있음**: 입력 크기가 크면 시간 초과 가능
* ❌ **구현 복잡**: 문제가 복잡하면 코드가 길어질 수 있음
* ❌ **경계 조건 처리**: 예외 상황 처리가 중요

---

## 🔄 다른 알고리즘과의 비교

### 시뮬레이션 vs 수학적 접근

* **시뮬레이션**: 과정을 직접 구현
* **수학적 접근**: 공식이나 점화식으로 해결
* 시뮬레이션이 더 직관적이지만, 수학적 접근이 더 효율적일 수 있음

### 시뮬레이션 vs 완전 탐색

* **시뮬레이션**: 문제의 규칙에 따라 단계별 처리
* **완전 탐색**: 모든 경우를 시도
* 시뮬레이션은 규칙에 따라 진행, 완전 탐색은 모든 경우 확인

---

## 📚 활용 예시

### 요세푸스 문제

* N명이 원을 이루고 K번째 사람을 제거하는 과정을 시뮬레이션
* 리스트를 사용하여 제거 과정을 직접 구현
* 시간 복잡도: O(N²) (리스트 제거 연산)

### 배열 회전

* 배열을 특정 규칙에 따라 회전하는 과정을 시뮬레이션
* 각 단계를 순차적으로 처리

### 게임 시뮬레이션

* 게임 규칙에 따라 상태를 업데이트하며 진행
* 각 턴의 상태를 추적

---

## ⚠️ 주의사항

### 1. 인덱스 관리

* 리스트에서 요소를 제거할 때 인덱스 관리 중요
* 제거 후 인덱스가 자동으로 조정됨을 고려

### 2. 경계 조건

* 리스트가 비어있는 경우 처리
* 인덱스가 범위를 벗어나는 경우 처리

### 3. 시간 복잡도

* 리스트 제거 연산이 O(N)이므로 주의
* 입력 크기가 크면 다른 방법 고려 필요

---

## 📖 참고

시뮬레이션 알고리즘은 문제의 요구사항을 정확히 구현하는 것이 핵심입니다. 복잡한 알고리즘보다는 **정확한 구현**과 **경계 조건 처리**가 중요합니다.

