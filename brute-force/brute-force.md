# 브루트포스(Brute Force) 알고리즘

## 1️⃣ 브루트포스 알고리즘의 핵심 개념

### 정의

브루트포스(Brute Force)는 **모든 가능한 경우를 체계적으로 탐색**하여 문제를 해결하는 알고리즘입니다.

### 특징

- **완전 탐색**: 모든 경우를 빠짐없이 탐색
- **단순함**: 복잡한 최적화 없이 직관적인 접근
- **확실함**: 모든 경우를 탐색하므로 정확한 답을 보장

---

## 2️⃣ 브루트포스의 구현 방법

브루트포스는 다양한 방법으로 구현할 수 있습니다:

**예시:**
- 중첩 반복문으로 모든 경우 탐색
- 재귀 함수로 모든 경우 탐색
- 비트마스크로 모든 부분집합 생성
- 백트래킹으로 가지치기하며 탐색 (구체적인 문제에서 적용)

---

## 3️⃣ 브루트포스 선택 기준

### ✅ 브루트포스를 선택해도 되는 경우

1. **제약 조건이 작은 경우**
   - N ≤ 20: O(2^N) 가능
   - N ≤ 10: O(N!) 가능
   - 작은 입력 크기: O(N²) 또는 O(N³) 가능

2. **가지치기가 효과적인 경우**
   - 불가능한 경우를 미리 제외할 수 있음
   - 실제 연산 횟수가 이론적 복잡도보다 훨씬 적음

3. **시간 복잡도 평가 결과 통과 가능**
   - 연산 횟수 ≤ 10⁸ (Java/C++)
   - 예상 시간 < 시간 제한

### ❌ 브루트포스를 선택하면 안 되는 경우

1. **제약 조건이 큰 경우**
   - N ≥ 100: O(2^N) 불가능
   - N ≥ 20: O(N!) 불가능

2. **시간 복잡도가 너무 큰 경우**
   - 연산 횟수 > 10⁸ (Java/C++)
   - 예상 시간 > 시간 제한

3. **효율적인 알고리즘이 명확한 경우**
   - 그리디, DP, 이분 탐색 등이 명확히 적용 가능

---

## 4️⃣ 시간 복잡도 평가 방법

### 계산 공식

```
예상 시간(초) = 연산 횟수 / 10⁸ (Java/C++)
예상 시간(초) = 연산 횟수 / 10⁷ (Python)
```

### 평가 단계

1. **최악의 경우 연산 횟수 계산**
2. **예상 시간 계산**
3. **시간 제한과 비교**
4. **통과 가능 여부 판단**

---

## 5️⃣ 브루트포스 문제 해결 전략

### 1단계: 효율적인 알고리즘 탐색

먼저 그리디, DP, 이분 탐색 등 효율적인 알고리즘을 찾아봅니다.

### 2단계: 브루트포스 고려

효율적인 방법이 없으면 브루트포스를 고려합니다.

### 3단계: 시간 복잡도 평가

반드시 시간 복잡도를 계산하고 시간 제한 내에 해결 가능한지 평가합니다.

### 4단계: 구현

시간 제한 내에 해결 가능하면 브루트포스로 구현합니다.

