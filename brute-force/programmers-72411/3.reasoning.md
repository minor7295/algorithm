# Main.java 설계 근거 정리

이 문서는 **프로그래머스 72411 메뉴 리뉴얼 문제**에 대한 알고리즘 선택과 설계 근거를 설명합니다.

---

## 1️⃣ 알고리즘 선택 의사결정 흐름

### 1단계: 효율적인 알고리즘 탐색

#### 그리디 알고리즘

**평가:**
- ❌ 탐욕 선택 속성이 없음
- 각 조합의 빈도를 알아야 최적 선택 가능
- 빈도를 모르는 상태에서는 그리디 적용 불가능

**소거 이유**: 탐욕 선택 속성이 없음 ❌

---

#### 동적 프로그래밍 (DP)

**평가:**
- ❌ 조합의 개수만 구할 수 있음
- 실제 조합을 만들어서 빈도를 카운트해야 하므로 사용 불가능

**소거 이유**: 실제 조합 생성 불가능 ❌

---

#### 이분 탐색

**평가:**
- ❌ 단조성이 없음
- 적용 불가능

**소거 이유**: 단조성 없음 ❌

---

#### 그래프 알고리즘

**평가:**
- ❌ 그래프 구조가 아님
- 적용 불가능

**소거 이유**: 그래프 구조 아님 ❌

---

### 2단계: 브루트포스 고려

**브루트포스 선택 이유:**
- ✅ 모든 조합을 생성해야 함
- ✅ 제약 조건이 작음 (N ≤ 20, M ≤ 10)
- ✅ 백트래킹으로 가지치기 가능

**시간 복잡도 평가:**
- 시간 복잡도: O(2^M × N × C × M)
- 실제 연산 횟수: 2^10 × 20 × 10 × 10 = 2,048,000
- 예상 시간: 2,048,000 / 10⁸ = 0.02048초
- 시간 제한: 보통 1~5초
- **판단: ✅ 통과 가능**

---

### 3단계: 최종 선택

**결론: 백트래킹(브루트포스) 선택 ✅**

- 다른 효율적인 알고리즘이 없음
- 제약 조건이 작아서 브루트포스로 충분히 빠름
- 백트래킹으로 가지치기하여 효율성 향상 가능

---

## 2️⃣ 다른 방법들과의 비교

### 중첩 반복문

**문제점:**
- 동적 크기 처리 불가능
- `course = [2, 3, 4]`인 경우, 2중첩, 3중첩, 4중첩 반복문이 각각 필요
- 컴파일 시점에 몇 중첩이 필요한지 알 수 없음

**소거 이유**: 동적 크기 조합 생성 불가능 ❌

---

### 백트래킹

**장점:**
- ✅ 동적 크기 조합 생성 가능
- ✅ 실제 조합 생성 가능
- ✅ 가지치기로 불가능한 경우 제외
- ✅ 상태 되돌리기로 효율적인 탐색

**선택 이유**: 모든 요구사항을 만족하는 유일한 방법 ✅

---

## 3️⃣ 함수 설계 근거

### generateCombinations 함수 시그니처

```java
static void generateCombinations(
    String order,           // 전체 문자열 (인덱스로 접근)
    int courseSize,         // 목표 크기
    int start,              // 현재 선택할 수 있는 시작 위치
    StringBuilder current,  // 현재까지 선택한 문자들
    Map<String, Integer> countMap  // 결과 저장
)
```

### 설계 결정 근거

**1. 인덱스 기반 접근**
- 부분 문자열을 만들면 새로운 메모리 할당 필요
- 인덱스 사용은 기존 문자열을 재사용하여 메모리 효율적

**2. StringBuilder 사용**
- 문자열 연결 연산이 많을 때 효율적
- 상태 되돌리기가 쉬움 (`setLength`로 길이 조절)

**3. 같은 Map에 누적 카운트**
- 모든 주문에서 생성된 조합들을 같은 Map에 저장
- 각 조합의 빈도를 자동으로 카운트

---

## 4️⃣ 핵심 판단

### 왜 백트래킹인가?

**문제의 본질:**
- 각 문자마다 "선택/선택 안 함" 두 가지 경우를 탐색
- 원하는 크기가 되면 저장

**백트래킹의 본질:**
- 각 단계에서 선택지를 탐색
- 선택하고 다음 단계로 진행
- 원하는 조건이 되면 저장
- 상태를 되돌려서 다른 선택지 탐색

➡️ **문제의 본질과 백트래킹의 본질이 완벽하게 일치합니다!**

### 브루트포스 선택의 타당성

**시간 복잡도 관점:**
- 최악의 경우 약 225만 번의 연산
- 약 0.0225초 소요
- 시간 제한 내에서 충분히 해결 가능 ✅

**공간 복잡도 관점:**
- 최악의 경우 약 400KB
- 메모리 제한의 0.3% ~ 0.03%
- 메모리 제한 내에서 충분히 해결 가능 ✅

**실제 성능:**
- 제약 조건이 작아서 브루트포스로도 충분히 빠름
- 가지치기로 불가능한 경우를 제외하여 실제 연산 횟수는 더 적음
- 코드가 간단하고 이해하기 쉬움

---

## 5️⃣ 결론

백트래킹(브루트포스)이 이 문제를 해결하는 가장 합리적이고 최적인 방법입니다.

1. **문제의 본질과 완벽하게 일치**: 각 문자마다 선택/선택 안 함을 탐색하는 문제
2. **모든 요구사항을 만족**: 동적 크기 처리, 실제 조합 생성, 완전 탐색
3. **다른 방법들의 근본적인 한계**: 중첩 반복문(동적 크기 불가), DP(실제 조합 생성 불가), 비트마스크(비효율적)
4. **시간/공간 복잡도 평가**: 충분히 빠르고 작음

