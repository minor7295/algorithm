# 알고리즘: 백트래킹

이 문제는 **브루트포스 전략**을 사용하여 해결하며, **백트래킹(Backtracking)**을 구현 방법으로 적용했습니다.  

---

## 브루트포스 전략 적용

각 주문에서 가능한 모든 조합을 생성하고, 모든 주문에서 생성된 조합들의 빈도를 카운트하는 문제입니다.

### 핵심 아이디어

1. **조합 생성**: 각 주문에서 모든 조합 생성 (브루트포스 전략)
2. **빈도 카운트**: 같은 Map에 누적하여 빈도 카운트
3. **최대 빈도 선택**: 각 코스 크기별로 가장 많이 주문된 조합 선택

### 백트래킹 적용 이유

일반적인 브루트포스로도 해결할 수 있지만, **백트래킹을 적용**하여 효율성을 향상시켰습니다.

---

## 구현 패턴

### 백트래킹 함수

```java
static void generateCombinations(String order, int courseSize, int start, 
                                 StringBuilder current, Map<String, Integer> countMap) {
    // 종료 조건: 원하는 크기의 조합을 만들었을 때
    if (current.length() == courseSize) {
        String combination = current.toString();
        countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
        return;
    }
    
    // 가지치기: 남은 문자로는 원하는 크기를 만들 수 없을 때
    if (order.length() - start < courseSize - current.length()) {
        return;
    }
    
    // 선택지 탐색
    for (int i = start; i < order.length(); i++) {
        current.append(order.charAt(i));  // 선택
        generateCombinations(order, courseSize, i + 1, current, countMap);
        current.setLength(current.length() - 1);  // 상태 되돌리기
    }
}
```

### 전체 알고리즘 흐름

```java
// 1. 빈도 카운트를 위한 Map 초기화
Map<String, Integer> countMap = new HashMap<>();

// 2. 각 주문에서 조합 생성 및 빈도 카운트
for (String order : orders) {
    char[] chars = order.toCharArray();
    Arrays.sort(chars);  // 알파벳 순으로 정렬
    String sortedOrder = new String(chars);
    
    for (int courseSize : course) {
        if (sortedOrder.length() >= courseSize) {
            generateCombinations(sortedOrder, courseSize, 0, 
                                new StringBuilder(), countMap);
        }
    }
}

// 3. 각 코스 크기별로 최대 빈도 조합 선택
for (int courseSize : course) {
    int maxCount = 0;
    List<String> candidates = new ArrayList<>();
    
    for (Map.Entry<String, Integer> entry : countMap.entrySet()) {
        String combination = entry.getKey();
        int count = entry.getValue();
        
        if (combination.length() == courseSize && count >= 2) {
            if (count > maxCount) {
                maxCount = count;
                candidates.clear();
                candidates.add(combination);
            } else if (count == maxCount) {
                candidates.add(combination);
            }
        }
    }
    
    result.addAll(candidates);
}
```

---

## 일반적인 브루트포스와의 차이

### 일반적인 브루트포스 접근

**중첩 반복문 방식:**
```java
// 2개 조합 생성
for (int i = 0; i < order.length(); i++) {
    for (int j = i + 1; j < order.length(); j++) {
        String combination = "" + order.charAt(i) + order.charAt(j);
        countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
    }
}

// 3개 조합 생성
for (int i = 0; i < order.length(); i++) {
    for (int j = i + 1; j < order.length(); j++) {
        for (int k = j + 1; k < order.length(); k++) {
            // ...
        }
    }
}
```

**문제점:**
- ❌ 동적 크기 처리 불가능 (`course = [2, 3, 4]`인 경우 각각 다른 중첩 필요)
- ❌ 코드 중복 (각 크기마다 거의 동일한 코드 반복)
- ❌ 가지치기 없이 모든 경우를 무조건 탐색

### 백트래킹 적용 (이 문제에서 사용)

**백트래킹 방식:**
```java
static void generateCombinations(String order, int courseSize, int start, 
                                 StringBuilder current, Map<String, Integer> countMap) {
    // 종료 조건
    if (current.length() == courseSize) {
        countMap.put(current.toString(), countMap.getOrDefault(current.toString(), 0) + 1);
        return;
    }
    
    // 가지치기: 불가능한 경우를 미리 제외
    if (order.length() - start < courseSize - current.length()) {
        return;
    }
    
    // 선택지 탐색
    for (int i = start; i < order.length(); i++) {
        current.append(order.charAt(i));  // 선택
        generateCombinations(order, courseSize, i + 1, current, countMap);
        current.setLength(current.length() - 1);  // 상태 되돌리기
    }
}
```

**장점:**
- ✅ **동적 크기 처리**: `courseSize`를 매개변수로 받아서 동적으로 처리
- ✅ **가지치기**: 불가능한 경우를 미리 제외하여 효율성 향상
  - 예: 남은 문자로는 원하는 크기를 만들 수 없을 때 조기 종료
- ✅ **상태 되돌리기**: 선택한 문자를 취소하고 다른 선택지 탐색
- ✅ **코드 재사용**: 한 함수로 모든 크기의 조합 생성 가능

**핵심 차이점:**
백트래킹은 브루트포스 전략을 개선한 구현 방법으로, 가지치기와 상태 되돌리기를 통해 불필요한 탐색을 줄이고 동적 크기 처리를 가능하게 합니다.

---

## 시간 복잡도

- **이론적 시간 복잡도**: O(2^M × N × C × M)
  - M: 주문의 최대 길이 (최대 10)
  - N: 주문 개수 (최대 20)
  - C: course 배열 크기 (최대 10)

- **최악의 경우 실제 연산 횟수**: 약 2,048,000번
- **예상 시간**: 약 0.02048초
- **평가**: ✅ 충분히 빠름

---

## 공간 복잡도

- **이론적 공간 복잡도**: O(2^M × N × M)
- **최악의 경우 실제 공간**: 약 400KB
- **평가**: ✅ 충분히 작음

