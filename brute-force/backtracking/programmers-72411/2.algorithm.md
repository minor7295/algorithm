# 알고리즘: 백트래킹(Backtracking)

> 📖 **전체 알고리즘 설명**: [백트래킹(Backtracking) 정리](../backtracking.md)

이 문제는 **백트래킹(Backtracking)** 알고리즘을 사용하여 해결합니다.  
상위 폴더의 [백트래킹 정리 문서](../backtracking.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 백트래킹 적용

### 문제 특성

* **조합 생성**: 각 손님의 주문에서 가능한 모든 조합을 생성해야 함
* **제약 조건**: 
  - 조합의 크기는 `course` 배열에 있는 값만 고려
  - 최소 2명 이상의 손님으로부터 주문된 조합만 유효
* **빈도 카운트**: 각 조합이 몇 번 주문되었는지 카운트
* **최대값 선택**: 각 코스 크기별로 가장 많이 주문된 조합 선택

---

## 이 문제의 특이사항

### 1️⃣ 조합 생성 (Combination Generation)

이 문제는 **각 주문에서 가능한 모든 조합을 생성**해야 합니다:

* 각 주문은 알파벳 대문자로 이루어진 문자열
* 각 주문에서 크기 `course[i]`인 모든 조합을 생성
* 조합은 순서가 중요하지 않지만, 결과는 알파벳 순으로 정렬되어야 함

**예시**: 주문 "ABCFG"에서 크기 2인 조합 생성
```
AB, AC, AF, AG, BC, BF, BG, CF, CG, FG
```

### 2️⃣ 빈도 카운트 및 최대값 선택

* **빈도 카운트**: `Map<String, Integer>`를 사용하여 각 조합의 빈도 카운트
* **최소 조건**: 최소 2명 이상의 손님으로부터 주문된 조합만 유효
* **최대값 선택**: 각 코스 크기별로 가장 많이 주문된 조합 선택
* **동일 최대값**: 최대 빈도가 같은 조합이 여러 개면 모두 포함

### 3️⃣ 정렬 요구사항

* **문자열 내부 정렬**: 각 조합은 알파벳 순으로 정렬되어야 함 (예: "AC"는 "CA"가 아님)
* **결과 배열 정렬**: 최종 결과 배열은 사전 순으로 정렬되어야 함

### 4️⃣ 시간 복잡도

* **조합 생성**: 각 주문에서 크기 `c`인 조합을 생성하는 경우의 수는 C(M, c) (M은 주문 길이)
* **최악의 경우**: 각 주문마다 모든 크기의 조합을 생성
* **전체 시간 복잡도**: O(2^M × N × C)
  - M: 주문의 최대 길이 (최대 10)
  - N: 주문 개수 (최대 20)
  - C: course 배열 크기 (최대 10)

제약 조건에 따라 최악의 경우 2^10 × 20 × 10 = 204,800번의 연산이 필요하지만, 실제로는 조합 생성 시 가지치기를 통해 더 적은 연산만 수행됩니다.

### 5️⃣ 공간 복잡도

* **조합 저장**: 생성된 조합들을 `Map`에 저장
* **최악의 경우**: 각 주문마다 모든 크기의 조합을 생성
* **전체 공간 복잡도**: O(2^M × N)

---

## 핵심 구현 패턴

### 방법 1: 백트래킹을 사용한 조합 생성 ✅ 권장

**핵심 로직:**
```java
// 각 주문에서 가능한 모든 조합 생성
void generateCombinations(String order, int courseSize, int start, StringBuilder current, Map<String, Integer> countMap) {
    // 종료 조건: 원하는 크기의 조합을 만들었을 때
    if (current.length() == courseSize) {
        String combination = current.toString();
        countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
        return;
    }
    
    // 가지치기: 남은 문자로는 원하는 크기를 만들 수 없을 때
    if (order.length() - start < courseSize - current.length()) {
        return;
    }
    
    // 각 문자를 선택하거나 선택하지 않는 두 가지 경우
    for (int i = start; i < order.length(); i++) {
        current.append(order.charAt(i));           // 선택
        generateCombinations(order, courseSize, i + 1, current, countMap);
        current.setLength(current.length() - 1);  // 선택 취소 (상태 되돌리기)
    }
}
```

**특징:**
* 백트래킹을 사용하여 조합 생성
* 상태 되돌리기: `StringBuilder`를 사용하므로 명시적으로 상태를 되돌려야 함
* 가지치기: 남은 문자로는 원하는 크기를 만들 수 없을 때 조기 종료

### 방법 2: 비트마스크를 사용한 조합 생성

**핵심 로직:**
```java
// 비트마스크를 사용하여 조합 생성
void generateCombinationsWithBitmask(String order, int courseSize, Map<String, Integer> countMap) {
    int n = order.length();
    for (int mask = 0; mask < (1 << n); mask++) {
        if (Integer.bitCount(mask) != courseSize) continue;
        
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if ((mask & (1 << i)) != 0) {
                sb.append(order.charAt(i));
            }
        }
        String combination = sb.toString();
        countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
    }
}
```

**특징:**
* 비트마스크를 사용하여 모든 부분 집합 생성
* 조합 크기가 `courseSize`와 일치하는 경우만 처리
* 구현이 간단하지만, 불필요한 경우도 탐색하므로 비효율적일 수 있음

### 구현 선택 가이드

| 버전 | 핵심 특징 | 권장 상황 |
|------|----------|----------|
| **백트래킹 버전** | 가지치기로 효율적 탐색 | ✅ **일반적인 경우 (권장)** |
| **비트마스크 버전** | 구현 간단, 모든 경우 탐색 | 주문 길이가 매우 작은 경우 |

**결론**: 주문 길이가 최대 10이므로 **백트래킹 버전이 더 효율적이며 권장**합니다.

---

## 다른 백트래킹 문제와의 차이점

| 특징 | 일반 백트래킹 (순열/조합) | 이 문제 (72411) |
|------|------------------------|----------------|
| 탐색 대상 | 1부터 N까지의 수 | 주문 문자열의 문자들 |
| 선택지 개수 | N개 (1부터 N까지) | 주문 길이만큼 |
| 결과 저장 | 배열에 저장 | Map에 빈도 카운트 |
| 정렬 요구사항 | 사전 순 출력 | 알파벳 순 정렬 + 사전 순 정렬 |
| 추가 처리 | 결과 출력 | 빈도 카운트 + 최대값 선택 |

---

## 상태 공간 트리 예시

`order = "ABC"`, `courseSize = 2`인 경우의 상태 공간 트리:

```
                    [""]
                   /  |  \
                  /   |   \
            [A]     [B]    [C]
           /  \     /  \
          /    \   /    \
    [AB]      [AC] [BC]  [C]
```

각 노드는 현재까지 선택한 문자들을 나타내며, 리프 노드가 크기 2인 조합입니다.

---

## 최적화 고려사항

### 현재 구현의 특징

* **가지치기**: 남은 문자로는 원하는 크기를 만들 수 없을 때 조기 종료
* **상태 되돌리기**: `StringBuilder`를 사용하므로 명시적으로 상태를 되돌려야 함
* **빈도 카운트**: `Map`을 사용하여 효율적으로 빈도 카운트

### 추가 최적화 가능성

* **문자 정렬**: 각 주문을 미리 알파벳 순으로 정렬하여 조합 생성 시 자동으로 정렬됨
* **조기 종료**: 최대 빈도를 미리 계산하여 불필요한 조합 생성 방지 (하지만 구현이 복잡해짐)
* **메모이제이션**: 동일한 주문 패턴에 대해 메모이제이션 가능하지만, 이 문제에서는 효과가 제한적

---

## 참고

* 전체 백트래킹 알고리즘 설명: [../backtracking.md](../backtracking.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

