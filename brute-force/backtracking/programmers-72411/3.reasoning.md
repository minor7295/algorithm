# Main.java 설계 근거 정리

이 문서는 **프로그래머스 72411 메뉴 리뉴얼 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **백트래킹 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 백트래킹(Backtracking)

### 문제 특성과의 적합성

* 문제 요구사항
  * 각 손님의 주문에서 가능한 모든 조합을 생성해야 함
  * 각 조합의 빈도를 카운트하여 가장 많이 주문된 조합 찾기
  * `course` 배열에 있는 크기의 조합만 고려
  * 최소 2명 이상의 손님으로부터 주문된 조합만 유효
* 제약 조건
  * 주문 길이: 2 이상 10 이하
  * 주문 개수: 2 이상 20 이하
  * course 배열 크기: 1 이상 10 이하

이 문제는 **조합 생성 문제**로, 다음과 같은 특성이 있다:

* 각 주문에서 가능한 모든 조합을 생성해야 함
* 조합의 크기는 `course` 배열에 있는 값만 고려
* 최소 2명 이상의 손님으로부터 주문된 조합만 유효
* 결과는 알파벳 순으로 정렬되어야 함

➡️ 이러한 조건을 가장 직관적으로 만족하는 방법이 **백트래킹(Backtracking)** 이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 조합 생성 함수 구조

```java
static void generateCombinations(String order, int courseSize, int start, StringBuilder current, Map<String, Integer> countMap) {
    // 종료 조건: 원하는 크기의 조합을 만들었을 때
    if (current.length() == courseSize) {
        String combination = current.toString();
        countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
        return;
    }
    
    // 가지치기: 남은 문자로는 원하는 크기를 만들 수 없을 때
    if (order.length() - start < courseSize - current.length()) {
        return;
    }
    
    // 각 문자를 선택하거나 선택하지 않는 두 가지 경우
    for (int i = start; i < order.length(); i++) {
        current.append(order.charAt(i));           // 선택
        generateCombinations(order, courseSize, i + 1, current, countMap);
        current.setLength(current.length() - 1);  // 선택 취소 (상태 되돌리기)
    }
}
```

* 알고리즘 문서에서 설명한 **백트래킹 기본 템플릿**과 정확히 일치한다
* `current.length() == courseSize`: 종료 조건 - 원하는 크기의 조합을 만들었을 때
* `current.append(order.charAt(i))`: 선택 - 현재 문자를 조합에 추가
* `current.setLength(current.length() - 1)`: 선택 취소 - 상태 되돌리기
* `generateCombinations(..., i + 1, ...)`: 다음 문자로 재귀 호출

➡️ **상태 공간 트리를 깊이 우선으로 탐색**하는 백트래킹 구조가 코드에 그대로 반영되어 있다.

---

### ② 가지치기 최적화

```java
// 가지치기: 남은 문자로는 원하는 크기를 만들 수 없을 때
if (order.length() - start < courseSize - current.length()) {
    return;
}
```

* **가지치기 원리**: 남은 문자 개수가 필요한 문자 개수보다 적으면 조합을 만들 수 없음
* **효과**: 불가능한 경로를 조기 종료하여 탐색 효율 향상
* **예시**: `order = "ABC"`, `courseSize = 2`, `start = 2`, `current.length() = 0`인 경우
  * 남은 문자: 1개 ("C")
  * 필요한 문자: 2개
  * 1 < 2이므로 조기 종료

➡️ 이는 **가지치기 최적화**가 코드에 구현된 것이다. 불가능한 경로를 조기 종료하여 탐색 효율을 높입니다.

---

### ③ 상태 되돌리기 (Backtracking)

```java
current.append(order.charAt(i));           // 선택
generateCombinations(order, courseSize, i + 1, current, countMap);
current.setLength(current.length() - 1);  // 선택 취소 (상태 되돌리기)
```

* **상태 되돌리기 원리**: `StringBuilder`는 누적 방식으로 동작하므로, 재귀 호출 후 명시적으로 상태를 되돌려야 함
* **필요성**: 다른 경로를 탐색할 때 이전 경로의 상태가 남아있으면 안 됨
* **구현**: `current.setLength(current.length() - 1)`로 마지막 문자 제거

➡️ 알고리즘 문서에서 설명한 **"상태를 되돌리는 특수한 형태의 DFS"**가 코드에 구현되어 있다.

---

### ④ 빈도 카운트 및 최대값 선택

```java
// 각 주문에서 조합 생성 및 빈도 카운트
for (String order : orders) {
    char[] chars = order.toCharArray();
    Arrays.sort(chars);  // 알파벳 순으로 정렬
    String sortedOrder = new String(chars);
    
    for (int courseSize : course) {
        if (sortedOrder.length() >= courseSize) {
            generateCombinations(sortedOrder, courseSize, 0, new StringBuilder(), countMap);
        }
    }
}

// 각 코스 크기별로 최대 빈도 찾기
for (int courseSize : course) {
    int maxCount = 0;
    List<String> candidates = new ArrayList<>();
    
    for (Map.Entry<String, Integer> entry : countMap.entrySet()) {
        String combination = entry.getKey();
        int count = entry.getValue();
        
        if (combination.length() == courseSize && count >= 2) {
            if (count > maxCount) {
                maxCount = count;
                candidates.clear();
                candidates.add(combination);
            } else if (count == maxCount) {
                candidates.add(combination);
            }
        }
    }
    
    result.addAll(candidates);
}
```

* **빈도 카운트**: `Map<String, Integer>`를 사용하여 각 조합의 빈도 카운트
* **최소 조건**: `count >= 2`로 최소 2명 이상의 손님으로부터 주문된 조합만 유효
* **최대값 선택**: 각 코스 크기별로 가장 많이 주문된 조합 선택
* **동일 최대값**: 최대 빈도가 같은 조합이 여러 개면 모두 포함

➡️ 알고리즘 문서에서 설명한 **"빈도 카운트 및 최대값 선택"**이 코드에 구현되어 있다.

---

### ⑤ 정렬 요구사항

```java
// 각 주문을 알파벳 순으로 정렬
char[] chars = order.toCharArray();
Arrays.sort(chars);
String sortedOrder = new String(chars);

// 결과를 사전 순으로 정렬
Collections.sort(result);
```

* **문자열 내부 정렬**: 각 주문을 미리 알파벳 순으로 정렬하여 조합 생성 시 자동으로 정렬됨
* **결과 배열 정렬**: 최종 결과 배열을 사전 순으로 정렬

➡️ 알고리즘 문서에서 설명한 **"정렬 요구사항"**이 코드에 구현되어 있다.

---

## 3️⃣ 재귀 호출의 의미

### 상태 공간 트리 탐색

재귀 호출 `generateCombinations(order, courseSize, i + 1, current, countMap)`는 다음과 같은 의미를 가진다:

1. **현재 문자를 선택한 상태**에서
2. **다음 문자로 진행**하여
3. **상태 공간 트리의 다음 레벨을 탐색**

### 예시: order="ABC", courseSize=2인 경우

```
generateCombinations("ABC", 2, 0, "", {})
  ├─ 선택: A
  │   └─ generateCombinations("ABC", 2, 1, "A", {})
  │       ├─ 선택: B → "AB" (크기 2 달성) ✅
  │       └─ 선택: C → "AC" (크기 2 달성) ✅
  ├─ 선택: B
  │   └─ generateCombinations("ABC", 2, 2, "B", {})
  │       └─ 선택: C → "BC" (크기 2 달성) ✅
  └─ 선택: C
      └─ generateCombinations("ABC", 2, 3, "C", {})
          └─ 가지치기: 남은 문자 없음 → 조기 종료
```

➡️ 이는 알고리즘 문서에서 설명한 **상태 공간 트리**를 그대로 탐색하는 과정이다.

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 조합 생성 시간 복잡도

* 각 주문에서 크기 `c`인 조합을 생성하는 경우의 수는 C(M, c) (M은 주문 길이)
* 최악의 경우: 각 주문마다 모든 크기의 조합을 생성
* 전체 시간 복잡도: **O(2^M × N × C)**
  - M: 주문의 최대 길이 (최대 10)
  - N: 주문 개수 (최대 20)
  - C: course 배열 크기 (최대 10)

### 코드에서의 대응

```java
// 각 주문마다 모든 코스 크기의 조합 생성
for (String order : orders) {  // O(N)
    for (int courseSize : course) {  // O(C)
        if (sortedOrder.length() >= courseSize) {
            generateCombinations(...);  // O(2^M)
        }
    }
}
```

* 각 주문마다 모든 코스 크기의 조합을 생성
* 가지치기를 통해 불가능한 경로는 조기 종료
* 전체 시간 복잡도: **O(2^M × N × C)** (최악의 경우, 실제로는 가지치기로 더 적음)

---

## 5️⃣ 공간 복잡도 분석

### 조합 저장 공간

* 생성된 조합들을 `Map`에 저장
* 최악의 경우: 각 주문마다 모든 크기의 조합을 생성
* 전체 공간 복잡도: **O(2^M × N)**

### 재귀 호출 스택

* 최대 재귀 깊이: M (주문의 최대 길이)
* 각 재귀 호출마다 스택 프레임 생성
* 스택 공간: **O(M)**

### 전체 공간 복잡도

* **O(2^M × N)** - 조합 저장 공간이 지배적

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 백트래킹 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 가지치기를 통해 불가능한 경로 조기 종료
* 코드가 간결하고 이해하기 쉬움

**단점:**
* 재귀 호출로 인한 스택 오버플로우 가능성 (하지만 M ≤ 10이므로 문제 없음)

### 방법 2: 비트마스크

```java
void generateCombinationsWithBitmask(String order, int courseSize, Map<String, Integer> countMap) {
    int n = order.length();
    for (int mask = 0; mask < (1 << n); mask++) {
        if (Integer.bitCount(mask) != courseSize) continue;
        
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if ((mask & (1 << i)) != 0) {
                sb.append(order.charAt(i));
            }
        }
        String combination = sb.toString();
        countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
    }
}
```

**장점:**
* 구현이 간단함
* 스택 오버플로우 걱정 없음

**단점:**
* 불필요한 경우도 탐색하므로 비효율적
* 비트마스크 개념 필요
* 시간 복잡도는 동일 (O(2^M))

### 방법 3: 반복문을 사용한 조합 생성

**단점:**
* 구현이 복잡함
* 동적 크기의 조합을 생성하기 어려움
* 이 문제에서는 백트래킹이 더 적합

➡️ **백트래킹이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응

---

## 8️⃣ 구현 세부사항

### 문자열 정렬

```java
char[] chars = order.toCharArray();
Arrays.sort(chars);
String sortedOrder = new String(chars);
```

* 각 주문을 미리 알파벳 순으로 정렬
* 조합 생성 시 자동으로 알파벳 순으로 정렬됨
* 결과 정렬 요구사항을 만족

### 빈도 카운트

```java
countMap.put(combination, countMap.getOrDefault(combination, 0) + 1);
```

* `Map`을 사용하여 각 조합의 빈도 카운트
* `getOrDefault`를 사용하여 초기값 0 처리

### 최대값 선택

```java
if (count > maxCount) {
    maxCount = count;
    candidates.clear();
    candidates.add(combination);
} else if (count == maxCount) {
    candidates.add(combination);
}
```

* 각 코스 크기별로 최대 빈도 찾기
* 동일한 최대값이면 모두 포함

---

## 9️⃣ 특수 케이스 처리

### 케이스 1: 주문 길이가 코스 크기보다 작은 경우

```java
if (sortedOrder.length() >= courseSize) {
    generateCombinations(sortedOrder, courseSize, 0, new StringBuilder(), countMap);
}
```

* 주문 길이가 코스 크기보다 작으면 조합 생성 불가
* 조기 종료하여 불필요한 연산 방지

### 케이스 2: 최소 2명 이상의 손님 조건

```java
if (combination.length() == courseSize && count >= 2) {
    // 최대값 선택 로직
}
```

* 최소 2명 이상의 손님으로부터 주문된 조합만 유효
* `count >= 2` 조건으로 필터링

### 케이스 3: 동일한 최대값이 여러 개인 경우

```java
if (count > maxCount) {
    maxCount = count;
    candidates.clear();
    candidates.add(combination);
} else if (count == maxCount) {
    candidates.add(combination);
}
```

* 최대 빈도가 같은 조합이 여러 개면 모두 포함
* `candidates` 리스트에 모두 추가

---

## 🔟 코드 최적화 고려사항

### 현재 구현의 특징

* **가지치기**: 남은 문자로는 원하는 크기를 만들 수 없을 때 조기 종료
* **상태 되돌리기**: `StringBuilder`를 사용하므로 명시적으로 상태를 되돌려야 함
* **빈도 카운트**: `Map`을 사용하여 효율적으로 빈도 카운트
* **정렬**: 각 주문을 미리 정렬하여 조합 생성 시 자동으로 정렬됨

### 추가 최적화 가능성

* **조기 종료**: 최대 빈도를 미리 계산하여 불필요한 조합 생성 방지 (하지만 구현이 복잡해짐)
* **메모이제이션**: 동일한 주문 패턴에 대해 메모이제이션 가능하지만, 이 문제에서는 효과가 제한적
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

