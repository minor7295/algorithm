# 알고리즘: 백트래킹

> 📖 **전체 알고리즘 설명**: [백트래킹(Backtracking) 정리](../backtracking.md)

이 문제는 **백트래킹(Backtracking)** 알고리즘을 사용하여 해결합니다.  
상위 폴더의 [백트래킹 정리 문서](../backtracking.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

> **참고**: 백트래킹은 DFS(깊이 우선 탐색)의 한 형태로, 상태를 되돌리는 특수한 형태의 DFS입니다. 자세한 내용은 [백트래킹과 DFS의 관계](../backtracking.md#4️⃣-백트래킹과-dfs의-관계)를 참고하세요.

---

## 이 문제에서의 백트래킹 적용

### 문제 특성

* **2차원 보드 탐색**: 상하좌우로 인접한 칸으로 이동
* **알파벳 중복 방지**: 지나온 모든 칸의 알파벳과 달라야 함
* **최대 경로 길이**: 모든 가능한 경로를 탐색하여 최대 길이 찾기
* **상태 되돌리기**: 한 경로를 탐색한 후 상태를 되돌려서 다른 경로 탐색 ✅
* **제약 조건**: `1 ≤ R, C ≤ 20` (최대 400칸)

---

## 이 문제의 특이사항

### 1️⃣ 2차원 보드에서의 백트래킹

이 문제는 **2차원 보드에서 백트래킹을 수행**합니다.

**특징:**
* 각 칸에서 상하좌우 4가지 방향으로 이동 가능
* 보드의 범위를 벗어나지 않아야 함
* 방문한 칸이 아닌 **방문한 알파벳**을 체크해야 함

### 2️⃣ 알파벳 집합 관리

이 문제의 핵심은 **방문한 알파벳 집합을 관리**하는 것입니다.

**특징:**
* 각 칸의 알파벳을 방문했는지 체크
* 새로운 칸으로 이동할 때 해당 알파벳이 이미 방문했는지 확인
* 백트래킹 시 방문한 알파벳 집합에서 제거 (상태 되돌리기) ✅

**구현 방법:**
* **방법 1**: `Set<Character>` 사용 (간단하지만 오버헤드)
* **방법 2**: `boolean[]` 배열 사용 (알파벳은 26개이므로 효율적) ✅ 권장

### 3️⃣ 상태 되돌리기 (백트래킹의 핵심)

이 문제는 **상태 되돌리기**가 핵심입니다.

**특징:**
* 한 경로를 끝까지 탐색한 후 되돌아와서 다른 경로 탐색
* 탐색 후 방문한 알파벳 집합에서 제거하여 다른 경로 탐색 가능하도록 함
* 모든 가능한 경로를 탐색하여 최대 길이를 찾아야 함

**구현:**
```java
visited[idx] = true;  // 상태 변경
// ... 탐색 ...
visited[idx] = false; // ✅ 상태 되돌리기 (백트래킹의 핵심!)
```

### 4️⃣ 시간 복잡도

* **상태 공간 크기**: 최대 26개 알파벳 (알파벳은 26개)
* **각 노드 처리 시간**: O(1) (알파벳 체크, 상하좌우 이동)
* **전체 시간 복잡도**: **O(4^L)** (L은 최대 경로 길이, 최악의 경우 26)
  * 실제로는 가지치기(이미 방문한 알파벳)로 인해 훨씬 적음
  * 최악의 경우: 4^26이지만 가지치기로 인해 실제로는 훨씬 적음

제약 조건 `1 ≤ R, C ≤ 20`로 인해 최대 400칸이지만, 알파벳은 26개이므로 최대 경로 길이는 26입니다.

### 5️⃣ 공간 복잡도

* **보드 저장**: O(R×C)
* **방문한 알파벳 체크**: O(26) = O(1)
* **재귀 호출 스택**: O(L) (L은 최대 경로 길이, 최대 26)
* **전체 공간 복잡도**: **O(R×C)**

---

## 핵심 구현 패턴

### 방법 1: Set을 사용한 구현

```java
Set<Character> visited = new HashSet<>();

void backtrack(int r, int c, int count) {
    char current = board[r][c];
    
    // 이미 방문한 알파벳이면 종료 (가지치기)
    if (visited.contains(current)) {
        return;
    }
    
    // 상태 변경: 방문한 알파벳 추가
    visited.add(current);
    maxCount = Math.max(maxCount, count);
    
    // 상하좌우 탐색
    for (int[] dir : directions) {
        int nr = r + dir[0];
        int nc = c + dir[1];
        
        if (isValid(nr, nc)) {
            backtrack(nr, nc, count + 1);
        }
    }
    
    // ✅ 상태 되돌리기: 방문한 알파벳 제거
    visited.remove(current);
}
```

### 방법 2: boolean 배열을 사용한 구현 ✅ 권장

```java
boolean[] visited = new boolean[26];  // A-Z: 0-25

void backtrack(int r, int c, int count) {
    char current = board[r][c];
    int idx = current - 'A';
    
    // 이미 방문한 알파벳이면 종료 (가지치기)
    if (visited[idx]) {
        return;
    }
    
    // 상태 변경: 방문한 알파벳 체크
    visited[idx] = true;
    maxCount = Math.max(maxCount, count);
    
    // 상하좌우 탐색
    for (int[] dir : directions) {
        int nr = r + dir[0];
        int nc = c + dir[1];
        
        if (isValid(nr, nc)) {
            backtrack(nr, nc, count + 1);
        }
    }
    
    // ✅ 상태 되돌리기: 방문한 알파벳 체크 해제
    visited[idx] = false;
}
```

**차이점:**
* **Set**: 구현이 간단하지만 오버헤드가 있음
* **boolean 배열**: 알파벳은 26개로 고정되어 있어 배열이 더 효율적

---

## 다른 백트래킹 문제와의 차이점

| 특징 | 일반 백트래킹 (순열/조합) | 이 문제 (1987) |
|------|------------------------|----------------|
| 탐색 대상 | 상태 공간 트리 | 2차원 보드의 칸 |
| 선택지 개수 | 가변적 (1~N) | 고정 (4개: 상하좌우) |
| 방문 체크 | 숫자 방문 여부 | 알파벳 방문 여부 |
| 상태 저장 | 숫자 배열 | (행, 열) 좌표 + 알파벳 집합 |
| 상태 되돌리기 | 선택적 | 필수 (최대 경로 찾기) |
| 구현 복잡도 | 중간 | 중간 |

---

## 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용 (O(R×C))
* **상태 되돌리기**: 모든 가능한 경로를 탐색하여 최대 길이 보장

### 추가 최적화 가능성

* **가지치기**: 현재 경로 길이 + 남은 가능한 알파벳 수가 현재 최대값보다 작으면 조기 종료
  * 하지만 구현이 복잡하고, R, C ≤ 20이므로 큰 효과가 없을 수 있음
* **비트마스크**: 알파벳 집합을 비트로 표현 (26비트)
  * 하지만 boolean 배열이 더 직관적이고 충분히 빠름

---

## 참고

* 전체 백트래킹 알고리즘 설명: [../backtracking.md](../backtracking.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

