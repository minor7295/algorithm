# 알파벳

## 📌 문제 요약

세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있습니다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸(1행 1열)에는 말이 놓여 있습니다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 합니다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없습니다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함됩니다.

---

## 🔍 문제 설명

* **목표**: 같은 알파벳을 두 번 지나지 않고 최대한 많은 칸을 지나는 경로 찾기
* **제약 조건**: 
  - 새로 이동한 칸의 알파벳은 지금까지 지나온 모든 칸의 알파벳과 달라야 함
  - 상하좌우로만 이동 가능
  - 시작 위치: 좌측 상단 (1행 1열)
* **출력**: 말이 지날 수 있는 최대 칸 수

---

## 📥 입력 조건

* 첫째 줄에 R과 C가 빈칸을 사이에 두고 주어짐 (1 ≤ R, C ≤ 20)
* 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어짐

---

## 📤 출력 조건

* 첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력

---

## 💡 문제 핵심 해석

이 문제는 **백트래킹(Backtracking)** 알고리즘을 사용하여 해결할 수 있는 전형적인 문제입니다.

### 핵심 조건

* **2차원 보드 탐색**: 상하좌우로 인접한 칸으로 이동
* **알파벳 중복 방지**: 지나온 모든 칸의 알파벳과 달라야 함
* **최대 경로 길이**: 모든 가능한 경로를 탐색하여 최대 길이 찾기
* **상태 되돌리기**: 한 경로를 탐색한 후 상태를 되돌려서 다른 경로 탐색

### 백트래킹 접근 가능성

이 문제는 **백트래킹 알고리즘이 적합**합니다:

* **상태 공간 트리**: 각 칸에서 상하좌우 4가지 이동 선택지로 구성된 상태 공간 트리
* **상태 되돌리기**: 같은 알파벳을 만나면 되돌아가서 다른 경로 탐색
* **완전 탐색 필요**: 모든 가능한 경로를 탐색하여 최대 길이를 찾아야 함
* **제약 조건**: R, C ≤ 20이므로 최대 400칸 (충분히 처리 가능)

### 상태 정의

* **현재 위치**: (r, c)
* **방문한 알파벳 집합**: 지금까지 지나온 칸의 알파벳들
* **경로 길이**: 현재까지 지나온 칸의 개수

---

## 🧠 해결 전략 개요

1. **백트래킹 재귀 함수 정의**: 현재 위치, 방문한 알파벳 집합, 경로 길이를 매개변수로 받는 함수
2. **종료 조건**: 더 이상 이동할 수 없는 경우 (상하좌우 모두 같은 알파벳이거나 범위 밖)
3. **재귀 호출**: 상하좌우 네 방향으로 이동 가능한 칸에 대해 백트래킹 탐색
4. **상태 되돌리기**: 탐색 후 방문한 알파벳 집합에서 제거하여 다른 경로 탐색 가능하도록 함 ✅
5. **최대값 갱신**: 각 경로의 길이를 비교하여 최대값 갱신

---

## ✨ 예시

### 예시 1: 문제에서 제공한 예제

**입력**
```
2 4
CAAB
ADCB
```

**보드**
```
C A A B
A D C B
```

**처리 과정**
```
시작: (0, 0) = 'C', 경로 길이 = 1
  방문한 알파벳: {C}

(0, 0)에서 이동 가능한 칸:
  - (0, 1) = 'A' → 가능 (A는 방문하지 않음)
    방문한 알파벳: {C, A}, 경로 길이 = 2
    - (0, 2) = 'A' → 불가능 (A는 이미 방문함)
    - (1, 1) = 'D' → 가능
      방문한 알파벳: {C, A, D}, 경로 길이 = 3
      - (1, 0) = 'A' → 불가능 (A는 이미 방문함)
      - (1, 2) = 'C' → 불가능 (C는 이미 방문함)
      - 더 이상 이동 불가 → 최대 길이 = 3
      - visited['D'] = false (상태 되돌리기) ✅
    - visited['A'] = false (상태 되돌리기) ✅
  - (1, 0) = 'A' → 가능
    방문한 알파벳: {C, A}, 경로 길이 = 2
    - (0, 1) = 'A' → 불가능 (A는 이미 방문함)
    - (1, 1) = 'D' → 가능
      방문한 알파벳: {C, A, D}, 경로 길이 = 3
      - 더 이상 이동 불가 → 최대 길이 = 3
      - visited['D'] = false (상태 되돌리기) ✅
    - visited['A'] = false (상태 되돌리기) ✅
  - visited['C'] = false (상태 되돌리기) ✅

최대 경로 길이: 3
```

**출력**
```
3
```

### 예시 2: 문제에서 제공한 예제

**입력**
```
3 6
HFDFFB
AJHGDH
DGAGEH
```

**보드**
```
H F D F F B
A J H G D H
D G A G E H
```

**처리 과정**
```
시작: (0, 0) = 'H', 경로 길이 = 1
  방문한 알파벳: {H}

(0, 0)에서 이동 가능한 칸:
  - (1, 0) = 'A' → 가능
    방문한 알파벳: {H, A}, 경로 길이 = 2
    - (0, 0) = 'H' → 불가능 (H는 이미 방문함)
    - (1, 1) = 'J' → 가능
      방문한 알파벳: {H, A, J}, 경로 길이 = 3
      - (0, 1) = 'F' → 가능
        방문한 알파벳: {H, A, J, F}, 경로 길이 = 4
        - (0, 2) = 'D' → 가능
          방문한 알파벳: {H, A, J, F, D}, 경로 길이 = 5
          - (0, 3) = 'F' → 불가능 (F는 이미 방문함)
          - (1, 2) = 'H' → 불가능 (H는 이미 방문함)
          - (0, 1) = 'F' → 불가능 (F는 이미 방문함)
          - 더 이상 이동 불가 → 최대 길이 = 5
          - visited['D'] = false (상태 되돌리기) ✅
        - visited['F'] = false (상태 되돌리기) ✅
      - visited['J'] = false (상태 되돌리기) ✅
    - visited['A'] = false (상태 되돌리기) ✅
  - visited['H'] = false (상태 되돌리기) ✅

최대 경로 길이: 6
```

**출력**
```
6
```

### 예시 3: 간단한 경우

**입력**
```
2 2
AB
CD
```

**보드**
```
A B
C D
```

**처리 과정**
```
시작: (0, 0) = 'A', 경로 길이 = 1
  방문한 알파벳: {A}

(0, 0)에서 이동 가능한 칸:
  - (0, 1) = 'B' → 가능
    방문한 알파벳: {A, B}, 경로 길이 = 2
    - (1, 1) = 'D' → 가능
      방문한 알파벳: {A, B, D}, 경로 길이 = 3
      - (1, 0) = 'C' → 가능
        방문한 알파벳: {A, B, D, C}, 경로 길이 = 4
        - 더 이상 이동 불가 → 최대 길이 = 4
        - visited['C'] = false (상태 되돌리기) ✅
      - visited['D'] = false (상태 되돌리기) ✅
    - visited['B'] = false (상태 되돌리기) ✅
  - (1, 0) = 'C' → 가능
    방문한 알파벳: {A, C}, 경로 길이 = 2
    - (1, 1) = 'D' → 가능
      방문한 알파벳: {A, C, D}, 경로 길이 = 3
      - (0, 1) = 'B' → 가능
        방문한 알파벳: {A, C, D, B}, 경로 길이 = 4
        - 더 이상 이동 불가 → 최대 길이 = 4
        - visited['B'] = false (상태 되돌리기) ✅
      - visited['D'] = false (상태 되돌리기) ✅
    - visited['C'] = false (상태 되돌리기) ✅
  - visited['A'] = false (상태 되돌리기) ✅

최대 경로 길이: 4
```

**출력**
```
4
```

---

## 📝 정리

이 문제는 **백트래킹(Backtracking) 알고리즘**을 사용하여 해결할 수 있는 전형적인 문제입니다.

* **핵심 조건**: 같은 알파벳을 두 번 지나지 않고 최대한 많은 칸을 지나기
* **전략**: 백트래킹으로 모든 가능한 경로를 탐색하며, 방문한 알파벳 집합을 관리하여 상태 되돌리기
* **시간 복잡도**: O(4^L) - L은 최대 경로 길이 (최악의 경우 26개 알파벳)
* **공간 복잡도**: O(R×C) - 보드 크기 + 재귀 호출 스택
* **제약 조건**: R, C ≤ 20이므로 최대 400칸 (충분히 처리 가능)

