# 알고리즘: 백트래킹

> 📖 **전체 알고리즘 설명**: [백트래킹(Backtracking) 정리](../backtracking.md)

이 문제는 **백트래킹(Backtracking)** 알고리즘을 사용하여 해결합니다.  
상위 폴더의 [백트래킹 정리 문서](../backtracking.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 백트래킹 적용

### 문제 특성

* **중복 순열 생성**: 같은 수를 여러 번 선택할 수 있음
* **사전 순 출력**: 결과를 사전 순으로 출력해야 함
* **제약 조건**: `1 ≤ M ≤ N ≤ 7` (최대 경우의 수: 7^7 = 823,543)

---

## 이 문제의 특이사항

### 1️⃣ 중복 허용으로 인한 단순화

일반적인 백트래킹 문제와 달리, 이 문제는 **중복이 허용**되므로:

* ✅ **방문 체크 불필요**: 같은 수를 여러 번 선택할 수 있으므로 방문 배열이 필요 없음
* ✅ **가지치기 불필요**: 모든 경로가 유효한 해이므로 가지치기 로직이 필요 없음
* ✅ **선택 취소 불필요**: 백트래킹 후 선택을 취소할 필요가 없음

### 2️⃣ 사전 순 출력의 자연스러운 보장

각 자리에서 **1부터 N까지 순서대로** 선택하면 자연스럽게 사전 순으로 출력됩니다.

> **자세한 설명**: [백트래킹 문서의 사전 순 출력 섹션](../backtracking.md#🔟-특수-케이스-사전-순-출력)을 참고하세요.

### 3️⃣ 시간 복잡도

* **상태 공간 크기**: N^M
* **각 노드 처리 시간**: O(1) (출력 제외)
* **전체 시간 복잡도**: **O(N^M)**

제약 조건 `1 ≤ M ≤ N ≤ 7`로 인해 최악의 경우 7^7 = 823,543개의 수열을 생성하지만, 이는 충분히 처리 가능한 범위입니다.

### 4️⃣ 공간 복잡도

* **재귀 호출 스택**: O(M) (최대 깊이 M)
* **결과 저장**: O(M)
* **전체 공간 복잡도**: **O(M)**

---

## 핵심 구현 패턴

이 문제에 특화된 백트래킹 구현:

```java
int[] result = new int[M];

void backtrack(int depth) {
    // 종료 조건: M개의 자리를 모두 채웠을 때
    if (depth == M) {
        printResult();
        return;
    }
    
    // 각 자리마다 1부터 N까지 모든 수를 선택
    for (int i = 1; i <= N; i++) {
        result[depth] = i;           // 선택
        backtrack(depth + 1);        // 다음 자리로 재귀 호출
        // 중복이 허용되므로 선택 취소 불필요
    }
}
```

---

## 다른 백트래킹 문제와의 차이점

| 특징 | 일반 백트래킹 | 이 문제 (15651) |
|------|-------------|---------------|
| 방문 체크 | 필요 (중복 방지) | 불필요 (중복 허용) |
| 가지치기 | 필요 (조건 불만족 시) | 불필요 (모든 경로 유효) |
| 선택 취소 | 필요 | 불필요 |
| 구현 복잡도 | 높음 | 낮음 |

---

## 참고

* 전체 백트래킹 알고리즘 설명: [../backtracking.md](../backtracking.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)
