# 알고리즘 선택 및 코드 설계 근거

이 문서는 **BOJ 2295 세 수의 합 문제**에서 왜 이 알고리즘을 선택했는지, 그리고 코드가 어떻게 설계되었는지를 설명합니다.

---

## 1️⃣ 알고리즘 선택 근거: 왜 "두 수의 합을 미리 계산 + 해시셋"인가?

> 📖 **알고리즘 상세 설명**: [2.algorithm.md](./2.algorithm.md)를 참고하세요.

### 🔑 핵심 사고 과정: 문제 변환을 통한 효율성 향상

**왜 "두 수의 합을 미리 계산"이라는 접근을 했을까?**

**핵심 사고 과정:**

1. **목표: 세 수의 합 d = a + b + c를 찾기**
   - 문제: "세 수를 선택하여 그 합이 집합에 있는 가장 큰 값"
   - 하지만 모든 세 수의 조합을 확인하면 O(N³) 시간이 걸림

2. **전략: 문제 변환**
   - 원래: d = a + b + c (3개의 수를 선택)
   - 변환: d - a = b + c (1개의 수와 2개의 수의 합)
   - 이렇게 하면 두 수의 합을 미리 계산해둘 수 있음

3. **효율성 향상**
   - 모든 세 수의 조합: O(N³)
   - 두 수의 합을 미리 계산: O(N²)
   - 각 d와 a에 대해 확인: O(N²)
   - 총 시간: O(N²) (정렬 제외)

---

### 🔍 다른 접근 방식과의 비교

**알고리즘을 결정할 때, 여러 방식 중에서 왜 "두 수의 합을 미리 계산 + 해시셋"을 선택했을까?**

#### 방식 1: 모든 세 수의 조합 확인 (브루트 포스)

**접근:**
```java
long maxD = 0;
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        for (int k = 0; k < N; k++) {
            long sum = arr[i] + arr[j] + arr[k];
            if (set.contains(sum)) {
                maxD = Math.max(maxD, sum);
            }
        }
    }
}
```

**장점:**
- 구현이 간단하고 직관적
- 모든 경우를 확인하므로 정확함

**단점:**
- ❌ **시간 복잡도 O(N³)**: N=10³일 때 10⁹번의 연산
- 시간 초과 가능성 높음

---

#### 방식 2: 이진 탐색 활용

**접근:**
```java
// 배열 정렬
Arrays.sort(arr);

// 각 d와 a에 대해 이진 탐색
for (int i = 0; i < N; i++) {
    long d = arr[i];
    for (int j = 0; j < N; j++) {
        long a = arr[j];
        long target = d - a;
        
        // b + c = target을 만족하는 b, c 찾기
        for (int k = 0; k < N; k++) {
            long b = arr[k];
            long c = target - b;
            if (Arrays.binarySearch(arr, c) >= 0) {
                // 찾음
            }
        }
    }
}
```

**장점:**
- 이진 탐색으로 일부 최적화 가능

**단점:**
- ❌ **여전히 O(N³) 시간**: 각 d, a, b에 대해 이진 탐색
- 해시셋보다 느림

---

#### 방식 3: 두 수의 합을 미리 계산 + 해시셋 (현재 방식) ✅

**접근:**
```java
// 1단계: 두 수의 합을 미리 계산
Set<Long> twoSumSet = new HashSet<>();
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        twoSumSet.add(arr[i] + arr[j]);
    }
}

// 2단계: 각 d와 a에 대해 확인
for (int i = 0; i < N; i++) {
    long d = arr[i];
    for (int j = 0; j < N; j++) {
        long a = arr[j];
        if (twoSumSet.contains(d - a)) {
            // 찾음
        }
    }
}
```

**장점:**
- ✅ **시간 복잡도 O(N²)**: 두 수의 합 계산 + 각 d와 a 확인
- ✅ **HashSet 조회 O(1)**: 빠른 확인 가능
- ✅ **구현이 간단하고 효율적**

**단점:**
- 공간 복잡도 O(N²) (하지만 N ≤ 10³이므로 충분)

---

### 📊 종합 비교

| 방식 | 시간 복잡도 | 공간 복잡도 | 구현 난이도 | 효율성 |
|------|------------|------------|------------|--------|
| 모든 세 수의 조합 확인 | O(N³) | O(N) | 쉬움 | ❌ |
| 이진 탐색 활용 | O(N³) | O(N) | 보통 | ❌ |
| 두 수의 합 + 해시셋 | O(N²) | O(N²) | 쉬움 | ✅ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **"두 수의 합을 미리 계산 + 해시셋"이 가장 적합함**
- 시간 복잡도 O(N²)로 효율적
- 구현이 간단하고 직관적

---

## 2️⃣ 코드 설계 근거: 코드와 알고리즘의 1:1 대응

### ① 두 수의 합을 미리 계산

```java
Set<Long> twoSumSet = new HashSet<>();
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        twoSumSet.add(arr[i] + arr[j]);
    }
}
```

* **목적**: 모든 두 수의 합을 미리 계산하여 O(1) 조회 가능
* **시간**: O(N²)
* **공간**: O(N²)
* **같은 수를 여러 번 사용 가능**: i == j인 경우도 포함

### ② 내림차순 정렬

```java
Arrays.sort(arr);
// 오름차순 정렬 후 역순으로 확인
for (int i = N - 1; i >= 0; i--) {
    // ...
}
```

**왜 내림차순으로 확인해야 하는가?**

**핵심 이유: 첫 번째로 찾은 값이 최대값이기 때문**

**내림차순으로 확인:**
```
arr = [18, 10, 5, 3, 2] (정렬 후)

d = 18: 확인 → 찾음! → 답: 18 (즉시 반환)
```

**오름차순으로 확인:**
```
arr = [2, 3, 5, 10, 18]

d = 2: 확인 → 찾을 수도 있음 → 하지만 최대값이 아닐 수 있음
d = 3: 확인 → 찾을 수도 있음 → 하지만 최대값이 아닐 수 있음
...
d = 18: 확인 → 찾음 → 답: 18
```

**결론:**
- 내림차순으로 확인하면 첫 번째로 찾은 값이 최대값
- 오름차순으로 확인하면 모든 값을 확인해야 최대값을 찾을 수 있음
- **내림차순이 더 효율적**

### ③ 각 d와 a에 대해 확인

**"d = a + b + c"를 "d - a = b + c"로 변환:**

```java
for (int i = N - 1; i >= 0; i--) {
    long d = arr[i];
    boolean found = false;
    
    for (int j = 0; j < N; j++) {
        long a = arr[j];
        long remainder = d - a;
        
        if (twoSumSet.contains(remainder)) {
            // d = a + b + c를 만족하는 경우 발견
            found = true;
            break;
        }
    }
    
    if (found) {
        System.out.println(d);
        return;
    }
}
```

**변환의 의미:**
1. **원래 문제**: d = a + b + c를 만족하는 d 찾기
2. **변환**: d - a = b + c로 변환
3. **효과**: b + c의 모든 경우를 미리 계산해두고 O(1) 조회 가능

**경계 조건:**
* `d - a`가 음수가 될 수 있지만, 자연수만 입력되므로 문제 없음
* `d - a`가 0이 될 수 있지만, 자연수만 입력되므로 d > a인 경우만 고려

---

## 3️⃣ 시간/공간 복잡도와 코드의 대응

> **시간/공간 복잡도 분석**: [2.algorithm.md](./2.algorithm.md)의 시간/공간 복잡도 섹션을 참고하세요.

**코드와의 대응:**
- 시간 복잡도 O(N²): 두 수의 합 계산 O(N²) + 각 d와 a 확인 O(N²)
- 공간 복잡도 O(N²): `Set<Long> twoSumSet`에 최대 N²개의 합 저장

---

## 4️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(N²) 시간 복잡도
* **HashSet 활용**: O(1) 조회로 빠른 확인

### 추가 최적화 가능성

* 공간 최적화: 두 수의 합을 모두 저장하지 않고 필요한 것만 저장 (하지만 구현이 복잡해짐)
* 입력 최적화: BufferedReader 사용 (이미 사용 중)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 5️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **"세 수의 합"을 "두 수의 합"으로 변환**하여 효율성을 향상시키고
* 알고리즘 문서에서 설명한 **해시셋을 활용한 빠른 조회**를 그대로 활용하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 6️⃣ 핵심 설계 원칙

1. **효율성**: O(N²) 시간 복잡도로 최적화
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
4. **간결성**: 불필요한 복잡성 없이 핵심만 구현

---

## 참고

* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 상세 설명: [2.algorithm.md](./2.algorithm.md)
