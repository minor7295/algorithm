# 알고리즘 선택 및 코드 설계 근거

이 문서는 **프로그래머스 42579 베스트 앨범 문제**에서 왜 이 알고리즘을 선택했는지, 그리고 코드가 어떻게 설계되었는지를 설명합니다.

---

## 1️⃣ 처음 문제를 봤을 때의 판단

**초기 우려:**
- 문제가 복잡해 보여서 1~2초 안에 해결되지 못할 것 같다는 걱정
- 반복문을 여러 번 사용해야 할 것 같음

**핵심 통찰:**
- 반복문이 여러 개 있지만 **중첩되는 것이 아니라 순차적으로 진행**됨
- 따라서 생각보다 오래 걸리는 문제가 아니라고 판단

---

## 2️⃣ 반복문 구조 분석

**3개의 반복문:**

1. **장르별 재생수 구하기**: O(N) - 단일 반복문
2. **장르별 노래 목록 구하기**: O(N) - 단일 반복문
3. **장르별 노래 정렬하기**: O(N log N) - 각 장르마다 정렬하지만 전체적으로는 O(N log N)

**핵심:**
- 각 반복문은 순차적으로 실행됨 (중첩 아님)
- 각 노래는 정확히 한 번만 처리됨

---

## 3️⃣ 시간 복잡도 판단

**각 단계별 시간 복잡도:**
- O(N) + O(N) + O(N log N)

**핵심 원리:**
- 순차적으로 실행되는 반복문들의 시간 복잡도는 **가장 비용이 큰 것을 기준**으로 결정
- O(N log N)이 가장 크므로 전체 시간 복잡도는 **O(N log N)**

**장르와 음악의 크기 비교:**
- 장르는 100개 정도이고 음악은 만 개 정도
- **N(음악 개수)이 훨씬 크므로 N 기준으로만 생각**
- O(G log G)는 O(N log N)에 비해 무시 가능

---

## 4️⃣ 왜 장르별 정렬이 중첩 반복문이 아닌가?

**질문: for 루프 안에서 sort를 하는데, sort도 항목별로 순회하니까 중첩 반복 아닌가요?**

**핵심 구분:**
- **중첩 반복문**: 각 외부 반복마다 **모든** 내부 항목을 처리 (예: `for i in N: for j in M:` → N × M번)
- **이 경우**: 각 외부 반복마다 **해당 장르의 노래만** 처리
- **결과**: 각 노래는 정확히 한 번만 정렬됨 (자신이 속한 장르에서)

**예시:**
- N = 5, classic 3개, pop 2개
- pop 정렬: 2개 노래만 정렬
- classic 정렬: 3개 노래만 정렬
- 총 5개 노래가 각각 한 번씩만 정렬됨 → O(N log N)

**수학적 증명:**
- 각 장르 i의 노래 수: nᵢ, 전체 노래 수: n₁ + n₂ + ... + nG = N
- 전체 정렬 시간: O(n₁ log n₁) + ... + O(nG log nG) ≤ O(N log N) ✅

**결론:**
- sort() 함수는 내부적으로 반복문을 사용하지만
- 각 노래는 자신이 속한 장르의 리스트에서만 정렬됨
- 따라서 O(N log N)이지 O(G × N log N)이 아님

---

## 5️⃣ 알고리즘 선택 근거

### 다른 접근 방식과의 비교

| 방식 | 시간 복잡도 | 특징 | 결론 |
|------|------------|------|------|
| 배열만 사용 | O(G × N) | 매번 배열 전체 탐색 | ❌ 1,000,000 연산 |
| 해시맵 + 정렬 | O(N log N) | 해시맵 O(1) 조회 | ✅ 130,000 연산 |

**결론:**
- **"해시맵 + 정렬"이 가장 적합함**

---

## 6️⃣ 코드 설계 근거

**코드와 알고리즘의 1:1 대응:**

1. **장르별 총 재생 횟수 계산**: O(N) - `getOrDefault`로 초기값 처리
2. **장르별 노래 정보 저장**: O(N) - 각 장르에 노래 그룹화
3. **장르 정렬**: O(G log G) - 총 재생 횟수 내림차순
4. **각 장르 내 노래 정렬 및 선택**: O(N log N) - 재생 횟수 내림차순, 같으면 고유 번호 오름차순, 최대 2개 선택

---

## 7️⃣ 정리

이 `Solution.java`는 단순히 정답을 반환하는 코드가 아니라,

* 문제의 **"장르별 그룹화"를 해시맵으로 효율적으로 처리**하고
* 알고리즘 문서에서 설명한 **정렬을 통한 우선순위 결정**을 그대로 활용하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.
