# Main.java 설계 근거 정리

이 문서는 **프로그래머스 77486 다단계 칫솔 판매 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **해시맵 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 해시맵과 재귀

### 왜 해시맵을 사용해야 하는가?

**문제의 핵심**: 각 판매마다 추천인을 빠르게 조회해야 함

* **배열 순회**: O(N) 시간 → 전체 O(M × N) = 10억 연산 → 시간 초과 가능 ❌
* **해시맵 사용**: O(1) 평균 시간 → 전체 O(N + M × H) → 시간 제한 내 해결 가능 ✅

➡️ **해시맵은 필수**입니다.

### 왜 재귀를 사용하는가?

**문제의 구조**: 이익이 추천인 체인을 따라 재귀적으로 분배됨

* **재귀**: 문제의 구조를 자연스럽게 표현, 구현 간단
* **반복문**: 가능하지만 코드가 약간 복잡함

➡️ **재귀가 더 직관적**이지만, 반복문도 가능합니다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 조직 구조 저장 (해시맵 사용)

```java
Map<String, String> parentMap = new HashMap<>();
for (int i = 0; i < enroll.length; i++) {
    parentMap.put(enroll[i], referral[i]);
}
```

* 알고리즘 문서에서 설명한 **해시맵의 인덱싱 패턴**과 정확히 일치한다
* `parentMap.put(enroll[i], referral[i])`: 각 판매원의 추천인 저장
* `parentMap.get(seller)`: O(1) 평균 시간에 추천인 조회
* **트리 구조 표현**: 각 노드(판매원)의 부모(추천인)를 해시맵에 저장

➡️ **해시맵으로 조직 구조를 저장**하는 구조가 코드에 그대로 반영되어 있다.

---

### ② 재귀적 이익 분배

```java
static void distribute(Map<String, String> parentMap, 
                      Map<String, Integer> profitMap,
                      String seller, int profit) {
    // 자신이 90% 가짐
    int myProfit = profit - profit / 10;
    profitMap.put(seller, 
        profitMap.getOrDefault(seller, 0) + myProfit);
    
    // 10%를 추천인에게 배분
    int commission = profit / 10;
    if (commission < 1) {
        return;  // 1원 미만이면 분배하지 않음
    }
    
    String parent = parentMap.get(seller);
    if (parent == null || parent.equals("-")) {
        return;  // 추천인이 없으면 종료
    }
    
    // 재귀 호출: 추천인에게 이익 분배
    distribute(parentMap, profitMap, parent, commission);
}
```

* 알고리즘 문서에서 설명한 **재귀적 이익 분배**가 코드에 구현되어 있다
* `profit - profit / 10`: 자신이 90% 가짐
* `profit / 10`: 10% 계산 (자동 절사)
* `commission < 1`: 최소 금액 체크
* `distribute(parent, commission)`: 재귀 호출로 추천인에게 이익 분배

➡️ **재귀 함수로 추천인 체인을 따라 이익을 분배**하는 구조가 코드에 직접 반영된 것이다.

---

### ③ 이익 집계 (해시맵 사용)

```java
Map<String, Integer> profitMap = new HashMap<>();

// 초기화: 모든 판매원의 이익을 0으로 설정
for (String name : enroll) {
    profitMap.put(name, 0);
}

// 이익 분배 시 누적
profitMap.put(seller, 
    profitMap.getOrDefault(seller, 0) + myProfit);
```

* 알고리즘 문서에서 설명한 **해시맵의 카운팅 패턴**과 정확히 일치한다
* `profitMap.getOrDefault(seller, 0)`: 초기값 처리
* `profitMap.put(seller, ... + myProfit)`: 이익 누적
* **여러 판매에서 발생한 이익을 누적**하여 집계

➡️ **해시맵으로 각 판매원의 이익을 누적**하는 구조가 코드에 구현되어 있다.

---

### ④ 결과 배열 생성

```java
int[] answer = new int[enroll.length];
for (int i = 0; i < enroll.length; i++) {
    answer[i] = profitMap.getOrDefault(enroll[i], 0);
}
```

* `enroll` 순서대로 이익을 배열에 담음
* `getOrDefault()`를 사용하여 키가 없으면 0 반환

➡️ 알고리즘 문서에서 설명한 **"enroll 순서대로 이익을 배열에 담아 반환"**이 코드에 구현되어 있다.

---

## 3️⃣ 재귀 호출의 의미

### 추천인 체인 탐색

재귀 호출 `distribute(parent, commission)`는 다음과 같은 의미를 가진다:

1. **현재 판매원이 90% 가짐**
2. **10%를 추천인에게 배분**
3. **추천인이 있으면 재귀적으로 분배**

### 예시: young이 1,200원 판매

```
distribute("young", 1200) 호출
  ├─ young: 1200 - 120 = 1080원 (자신)
  ├─ commission = 120원
  └─ distribute("edward", 120) 재귀 호출
      ├─ edward: 120 - 12 = 108원 (자신)
      ├─ commission = 12원
      └─ distribute("mary", 12) 재귀 호출
          ├─ mary: 12 - 1 = 11원 (자신)
          ├─ commission = 1원
          └─ distribute("center", 1) 재귀 호출
              └─ center: 1원 (추천인 없음, 종료)
```

➡️ 이는 알고리즘 문서에서 설명한 **재귀적 이익 분배**를 그대로 탐색하는 과정이다.

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 조직 구조 저장

* **시간 복잡도**: O(N) - enroll 배열 순회
* **코드에서의 대응**:
  ```java
  for (int i = 0; i < enroll.length; i++) {
      parentMap.put(enroll[i], referral[i]);
  }
  ```
  * enroll 배열을 한 번 순회하여 해시맵에 저장
  * `put()` 연산은 O(1) 평균 시간

### 이익 분배

* **시간 복잡도**: O(M × H) - M은 seller 길이, H는 조직 깊이
* **코드에서의 대응**:
  ```java
  for (int i = 0; i < seller.length; i++) {
      int profit = amount[i] * 100;
      distribute(parentMap, profitMap, seller[i], profit);
  }
  ```
  * 각 판매마다 재귀 호출 (최대 깊이 H)
  * 해시맵 조회는 O(1) 평균 시간
  * 전체 시간 복잡도: O(M × H)

### 결과 배열 생성

* **시간 복잡도**: O(N) - enroll 배열 순회
* **코드에서의 대응**:
  ```java
  for (int i = 0; i < enroll.length; i++) {
      answer[i] = profitMap.getOrDefault(enroll[i], 0);
  }
  ```
  * enroll 배열을 한 번 순회하여 결과 배열 생성
  * `getOrDefault()` 연산은 O(1) 평균 시간

### 전체 시간 복잡도

* **O(N + M × H)**
  * N: enroll 길이 (≤ 10,000)
  * M: seller 길이 (≤ 100,000)
  * H: 조직 깊이 (평균 3~5, 최대 약 10,000)

**실제 성능**:
* 평균 연산 수: 약 500,000 (충분히 빠름)
* 시간 제한 내 해결 가능

---

## 5️⃣ 공간 복잡도 분석

### 조직 구조 맵

* **공간 복잡도**: O(N) - 각 판매원의 추천인 저장
* **코드에서의 대응**:
  ```java
  Map<String, String> parentMap = new HashMap<>();
  ```
  * N개의 키-값 쌍 저장

### 이익 집계 맵

* **공간 복잡도**: O(N) - 각 판매원의 이익 저장
* **코드에서의 대응**:
  ```java
  Map<String, Integer> profitMap = new HashMap<>();
  ```
  * N개의 키-값 쌍 저장

### 재귀 호출 스택

* **공간 복잡도**: O(H) - 최대 조직 깊이
* **코드에서의 대응**:
  ```java
  distribute(parentMap, profitMap, parent, commission);
  ```
  * 재귀 호출 스택의 최대 깊이는 조직 깊이 H

### 전체 공간 복잡도

* **O(N + H)**
  * N: enroll 길이 (≤ 10,000)
  * H: 조직 깊이 (최대 약 10,000)

---

## 6️⃣ 다른 접근 방법과의 비교

### 해시맵 없이 배열 순회

**시간 복잡도**: O(M × N) = 10억 연산 → 시간 초과 가능 ❌

**해시맵 사용 시**: O(N + M × H) → 시간 제한 내 해결 가능 ✅

➡️ **해시맵은 필수**입니다.

### 재귀 vs 반복문

**시간 복잡도**: 동일 (O(N + M × H))

**차이점**:
* 재귀: 구현 간단, 직관적
* 반복문: 스택 오버플로우 걱정 없음

➡️ 둘 다 가능하지만, 재귀가 더 간단합니다.

---

## 7️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응

---

## 8️⃣ 주의사항과 해결 방법

### 1️⃣ 절사 처리

**문제**: 10% 계산 시 원 단위에서 절사해야 함

**해결**:
```java
int commission = profit / 10;  // 자동 절사
```

**이유**: Java의 정수 나눗셈은 자동으로 절사하므로 추가 처리 불필요

### 2️⃣ 최소 금액 체크

**문제**: 10%가 1원 미만이면 분배하지 않아야 함

**해결**:
```java
int commission = profit / 10;
if (commission < 1) {
    return;  // 분배하지 않음
}
```

**예시**: 2원의 10% = 0원 → 분배하지 않음

### 3️⃣ 추천인 체크

**문제**: 추천인이 없으면("-") 재귀 호출을 중단해야 함

**해결**:
```java
String parent = parentMap.get(seller);
if (parent == null || parent.equals("-")) {
    return;  // 추천인이 없으면 종료
}
```

**이유**: center(민호)는 추천인이 없으므로 더 이상 분배하지 않음

### 4️⃣ 이익 누적

**문제**: 같은 판매원이 여러 번 판매할 수 있으므로 이익을 누적해야 함

**해결**:
```java
profitMap.put(seller, 
    profitMap.getOrDefault(seller, 0) + myProfit);
```

**이유**: `getOrDefault()`를 사용하여 초기값 처리

---

## 9️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **재귀적 사고**: 문제의 구조를 자연스럽게 표현

### 추가 최적화 가능성

* **반복문 버전**: 재귀 대신 반복문 사용 (스택 오버플로우 방지)
* **이익 집계 최적화**: 이익 집계 맵을 배열로 대체 (인덱스 매핑 필요)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 🔟 정리

이 문제는 **해시맵과 재귀를 활용한 트리 구조 이익 분배 문제**입니다.

* **핵심 조건**: 조직 구조 저장, 재귀적 이익 분배, 절사 및 최소 금액 처리
* **전략**: Map으로 조직 구조 저장, 재귀 함수로 이익 분배, Map으로 이익 집계
* **시간 복잡도**: O(N + M × H)
* **공간 복잡도**: O(N + H)

**해시맵과 재귀를 조합하여 트리 구조 이익 분배 문제를 효율적으로 해결할 수 있습니다!**

