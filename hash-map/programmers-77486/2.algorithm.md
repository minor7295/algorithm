# 알고리즘: 해시맵과 재귀를 활용한 트리 구조 이익 분배

> 📖 **전체 알고리즘 설명**: [해시맵(HashMap) 정리](../hash-map.md)

이 문제는 **해시맵(HashMap)과 재귀(Recursion)**를 사용하여 해결합니다.  
상위 폴더의 [해시맵 정리 문서](../hash-map.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 해시맵과 재귀 적용

### 문제 특성

* **트리 구조**: 조직 구조가 트리 형태 (각 판매원은 하나의 추천인만 가짐)
* **재귀적 분배**: 이익이 추천인 체인을 따라 재귀적으로 분배됨
* **빠른 조회**: 해시맵으로 추천인을 O(1) 시간에 조회
* **이익 집계**: 해시맵으로 각 판매원의 이익을 누적

---

## 이 문제의 특이사항

### 1️⃣ 해시맵으로 조직 구조 저장

이 문제는 **각 판매원의 추천인을 해시맵에 저장**합니다:

```java
Map<String, String> parentMap = new HashMap<>();
for (int i = 0; i < enroll.length; i++) {
    parentMap.put(enroll[i], referral[i]);
}
```

**핵심 이유**:
* **빠른 조회**: 추천인을 O(1) 평균 시간에 조회 가능
* **트리 구조 표현**: 각 노드(판매원)의 부모(추천인)를 저장
* **재귀 탐색**: 재귀 함수에서 추천인을 빠르게 찾아 이익 분배

**예시**:
```
parentMap = {
  "young": "edward",
  "edward": "mary",
  "mary": "-"  // center를 의미
}
```

### 2️⃣ 재귀적 이익 분배

이 문제는 **재귀 함수로 추천인 체인을 따라 이익을 분배**합니다:

```java
static void distribute(Map<String, String> parentMap, 
                      Map<String, Integer> profitMap,
                      String seller, int profit) {
    // 자신이 90% 가짐
    profitMap.put(seller, 
        profitMap.getOrDefault(seller, 0) + profit - profit / 10);
    
    // 10%를 추천인에게 배분
    int commission = profit / 10;  // 자동 절사
    if (commission < 1) {
        return;  // 1원 미만이면 분배하지 않음
    }
    
    String parent = parentMap.get(seller);
    if (parent == null || parent.equals("-")) {
        return;  // 추천인이 없으면 종료
    }
    
    // 재귀 호출: 추천인에게 이익 분배
    distribute(parentMap, profitMap, parent, commission);
}
```

**핵심 로직**:
1. **자신이 90% 가짐**: `profit - profit / 10`
2. **10% 계산**: `profit / 10` (자동 절사)
3. **최소 금액 체크**: `commission < 1`이면 분배하지 않음
4. **재귀 호출**: 추천인이 있으면 재귀적으로 분배

**예시**: young이 1,200원 판매
```
distribute("young", 1200):
  - young: 1200 - 120 = 1080원
  - commission = 120원
  - distribute("edward", 120):
    - edward: 120 - 12 = 108원
    - commission = 12원
    - distribute("mary", 12):
      - mary: 12 - 1 = 11원
      - commission = 1원
      - distribute("center", 1): 종료
```

### 3️⃣ 이익 집계 맵

이 문제는 **해시맵으로 각 판매원의 이익을 누적**합니다:

```java
Map<String, Integer> profitMap = new HashMap<>();

// 초기화: 모든 판매원의 이익을 0으로 설정
for (String name : enroll) {
    profitMap.put(name, 0);
}

// 이익 분배 시 누적
profitMap.put(seller, 
    profitMap.getOrDefault(seller, 0) + profit - commission);
```

**핵심 이유**:
* **누적 계산**: 여러 판매에서 발생한 이익을 누적
* **빠른 조회**: O(1) 평균 시간에 이익 조회
* **결과 배열 생성**: enroll 순서대로 이익을 배열에 담음

### 4️⃣ 시간 복잡도

* **조직 구조 저장**: O(N) - enroll 배열 순회
* **이익 분배**: O(M × H) - M은 seller 길이, H는 조직 깊이
  * 각 판매마다 재귀 호출 (최대 깊이 H)
  * 해시맵 조회는 O(1) 평균
* **결과 배열 생성**: O(N) - enroll 배열 순회
* **전체 시간 복잡도**: **O(N + M × H)**
  * N ≤ 10,000, M ≤ 100,000, H ≤ 조직 깊이

**실제 성능**:
* 평균적으로 H는 3~5 정도로 매우 작음 (조기 종료 효과)
* 평균 연산 수: 약 500,000 (충분히 빠름)
* 시간 제한 내 해결 가능

### 5️⃣ 공간 복잡도

* **조직 구조 맵**: O(N) - 각 판매원의 추천인 저장
* **이익 집계 맵**: O(N) - 각 판매원의 이익 저장
* **재귀 호출 스택**: O(H) - 최대 조직 깊이
* **전체 공간 복잡도**: **O(N + H)**
  * H는 조직 깊이로, 최악의 경우 N (선형 구조)

---

## 핵심 구현 패턴

### 재귀 함수를 사용한 이익 분배

**핵심 로직**:
```java
static void distribute(Map<String, String> parentMap, 
                      Map<String, Integer> profitMap,
                      String seller, int profit) {
    // 자신이 90% 가짐
    int myProfit = profit - profit / 10;
    profitMap.put(seller, 
        profitMap.getOrDefault(seller, 0) + myProfit);
    
    // 10%를 추천인에게 배분
    int commission = profit / 10;
    if (commission < 1) {
        return;  // 1원 미만이면 분배하지 않음
    }
    
    String parent = parentMap.get(seller);
    if (parent == null || parent.equals("-")) {
        return;  // 추천인이 없으면 종료
    }
    
    // 재귀 호출: 추천인에게 이익 분배
    distribute(parentMap, profitMap, parent, commission);
}
```

**동작 과정**:
1. 자신이 90% 가짐 (`profit - profit / 10`)
2. 10% 계산 (`profit / 10` - 자동 절사)
3. 최소 금액 체크 (`commission < 1`이면 종료)
4. 추천인 조회 및 재귀 호출

---

## 다른 해시맵 문제와의 차이점

| 특징 | 일반 해시맵 문제 | 이 문제 (77486) |
|------|----------------|----------------|
| 주요 용도 | 카운팅, 그룹핑, 인덱싱 | 트리 구조 저장 + 재귀적 분배 |
| 재귀 사용 | 없음 | 필수 (이익 분배) |
| 트리 구조 | 없음 | 있음 (조직 구조) |
| 구현 복잡도 | 낮음 | 중간 |

---

## 주의사항

### 1️⃣ 절사 처리
```java
int commission = profit / 10;  // 자동 절사 (정수 나눗셈)
```

### 2️⃣ 최소 금액 체크
```java
if (commission < 1) return;  // 1원 미만이면 분배하지 않음
```

### 3️⃣ 추천인 체크
```java
if (parent == null || parent.equals("-")) return;  // center 도달 시 종료
```

### 4️⃣ 이익 누적
```java
profitMap.put(seller, profitMap.getOrDefault(seller, 0) + myProfit);
```

---

## 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용 (O(N))
* **재귀적 사고**: 문제의 구조를 자연스럽게 표현

### 추가 최적화 가능성

* **반복문 버전**: 재귀 대신 반복문 사용 (스택 오버플로우 방지)
* **이익 집계 최적화**: 이익 집계 맵을 배열로 대체 (인덱스 매핑 필요)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 참고

* 전체 해시맵 알고리즘 설명: [../hash-map.md](../hash-map.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

