# Main.java 설계 근거 정리

이 문서는 **프로그래머스 92334 신고 결과 받기 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **해시맵 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 해시맵과 집합

### 문제 특성과의 적합성

* 문제 요구사항
  * 중복 신고 제거: 같은 유저가 같은 유저를 여러 번 신고해도 1회로 처리
  * 신고 횟수 카운트: 각 유저가 신고당한 횟수를 세어야 함
  * 그룹핑: 각 유저가 신고한 유저 목록을 저장해야 함
  * 빠른 조회: 유저 ID로 빠르게 값을 조회해야 함
* 제약 조건
  * `2 ≤ id_list.length ≤ 1,000` (유저 수)
  * `1 ≤ report.length ≤ 200,000` (신고 수)
  * `1 ≤ k ≤ 200` (정지 기준)

이 문제는 **해시맵과 집합을 활용한 구현 문제**로, 다음과 같은 특성이 있다:

* **중복 제거**: Set을 사용하여 중복 신고 제거
* **카운팅**: Map을 사용하여 신고 횟수 카운트
* **그룹핑**: Map을 사용하여 유저별 신고 목록 저장
* **빠른 조회**: 해시맵의 O(1) 평균 시간 복잡도로 효율적 처리

➡️ 이러한 조건을 가장 효율적으로 만족하는 방법이 **해시맵과 집합**이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 중복 신고 제거 (Set 사용)

```java
Set<String> uniqueReports = new HashSet<>();
for (String report : report) {
    uniqueReports.add(report);
}
```

* 알고리즘 문서에서 설명한 대로, **Set을 사용하여 중복 신고 제거**
* `HashSet`은 중복을 자동으로 제거하므로 간단하게 처리 가능
* 이는 알고리즘 문서의 **"중복 제거 패턴"**과 정확히 일치한다

**예시**:
```
입력: ["ryan con", "ryan con", "ryan con", "ryan con"]
출력: {"ryan con"}  // 중복 제거됨
```

➡️ **Set의 중복 제거 기능**이 코드에 직접 반영된 것이다.

---

### ② 신고 횟수 카운트 (Map 사용)

```java
Map<String, Integer> reportCount = new HashMap<>();
for (String report : uniqueReports) {
    String[] parts = report.split(" ");
    String reported = parts[1];
    reportCount.put(reported, 
        reportCount.getOrDefault(reported, 0) + 1);
}
```

* **신고당한 유저 추출**: `parts[1]`로 신고당한 유저 ID 추출
* **카운팅**: `getOrDefault()`를 사용하여 기존 값에 1을 더함
  * 키가 없으면 0을 기본값으로 사용
  * 키가 있으면 기존 값에 1을 더함

이 과정은 알고리즘 문서에서 설명한 **"카운팅 패턴"**과 정확히 일치한다:

* `getOrDefault()`를 사용하여 초기값 처리
* `put()`을 사용하여 값 업데이트
* O(1) 평균 시간에 카운팅

**예시**:
```
입력: {"muzi frodo", "apeach frodo", "frodo neo", "muzi neo"}
처리:
  "frodo" → 1 → 2
  "neo" → 1 → 2
출력: {"frodo": 2, "neo": 2}
```

➡️ 알고리즘 문서에서 설명한 **"카운팅 패턴"**이 코드에 구현되어 있다.

---

### ③ 정지된 유저 확인 (Set 사용)

```java
Set<String> bannedUsers = new HashSet<>();
for (Map.Entry<String, Integer> entry : reportCount.entrySet()) {
    if (entry.getValue() >= k) {
        bannedUsers.add(entry.getKey());
    }
}
```

* **신고 횟수 확인**: `entry.getValue() >= k`로 k번 이상 신고당한 유저 확인
* **정지된 유저 저장**: `bannedUsers` Set에 추가
* **빠른 조회**: Set을 사용하여 O(1) 평균 시간에 조회 가능

이 과정은 알고리즘 문서에서 설명한 **"정지된 유저 확인"**과 정확히 일치한다:

* 신고 횟수 맵을 순회하며 k 이상인 유저를 찾음
* Set에 저장하여 빠른 조회 가능

**예시**:
```
입력: reportCount = {"frodo": 2, "neo": 2, "muzi": 1}, k = 2
처리:
  "frodo": 2 >= 2 → 추가
  "neo": 2 >= 2 → 추가
  "muzi": 1 < 2 → 추가 안 함
출력: {"frodo", "neo"}
```

➡️ 알고리즘 문서에서 설명한 **"정지된 유저 확인"**이 코드에 구현되어 있다.

---

### ④ 유저별 신고한 유저 목록 저장 (Map + Set 사용)

```java
Map<String, Set<String>> userReports = new HashMap<>();
for (String report : uniqueReports) {
    String[] parts = report.split(" ");
    String reporter = parts[0];
    String reported = parts[1];
    userReports.computeIfAbsent(reporter, k -> new HashSet<>())
                .add(reported);
}
```

* **신고한 유저 추출**: `parts[0]`로 신고한 유저 ID 추출
* **신고당한 유저 추출**: `parts[1]`로 신고당한 유저 ID 추출
* **그룹핑**: `computeIfAbsent()`를 사용하여 키가 없으면 새로운 Set 생성
* **추가**: Set에 신고당한 유저 추가

이 과정은 알고리즘 문서에서 설명한 **"그룹핑 패턴"**과 정확히 일치한다:

* `computeIfAbsent()`를 사용하여 키가 없으면 값 생성
* Set을 사용하여 중복 자동 제거
* O(1) 평균 시간에 그룹핑

**예시**:
```
입력: {"muzi frodo", "apeach frodo", "frodo neo", "muzi neo"}
처리:
  "muzi" → {"frodo"} → {"frodo", "neo"}
  "apeach" → {"frodo"}
  "frodo" → {"neo"}
출력: {
  "muzi": {"frodo", "neo"},
  "apeach": {"frodo"},
  "frodo": {"neo"}
}
```

➡️ 알고리즘 문서에서 설명한 **"그룹핑 패턴"**이 코드에 구현되어 있다.

---

### ⑤ 메일 수 계산 (Set 교집합)

```java
int[] answer = new int[id_list.length];
for (int i = 0; i < id_list.length; i++) {
    String user = id_list[i];
    Set<String> reported = userReports.getOrDefault(user, new HashSet<>());
    
    int mailCount = 0;
    for (String reportedUser : reported) {
        if (bannedUsers.contains(reportedUser)) {
            mailCount++;
        }
    }
    answer[i] = mailCount;
}
```

* **유저별 신고 목록 조회**: `getOrDefault()`를 사용하여 키가 없으면 빈 Set 반환
* **교집합 계산**: 각 유저가 신고한 유저 중 정지된 유저의 수를 세어야 함
  * `bannedUsers.contains()`를 사용하여 O(1) 평균 시간에 확인
  * 정지된 유저이면 `mailCount` 증가
* **결과 저장**: `id_list` 순서대로 메일 수 저장

이 과정은 알고리즘 문서에서 설명한 **"메일 수 계산"**과 정확히 일치한다:

* 각 유저가 신고한 유저 집합과 정지된 유저 집합의 교집합 개수 계산
* Set의 `contains()`를 사용하여 O(1) 평균 시간에 확인

**예시**:
```
입력:
  userReports = {"muzi": {"frodo", "neo"}, "frodo": {"neo"}}
  bannedUsers = {"frodo", "neo"}

처리:
  "muzi": {"frodo", "neo"} ∩ {"frodo", "neo"} = 2개
  "frodo": {"neo"} ∩ {"frodo", "neo"} = 1개
  "apeach": {"frodo", "muzi"} ∩ {"frodo", "neo"} = 1개
  "neo": {} ∩ {"frodo", "neo"} = 0개

출력: [2, 1, 1, 0]
```

➡️ 알고리즘 문서에서 설명한 **"메일 수 계산"**이 코드에 구현되어 있다.

---

## 3️⃣ 입력 처리 방식

### 문자열 배열 처리

```java
String[] parts = report.split(" ");
String reporter = parts[0];
String reported = parts[1];
```

* `split(" ")`을 사용하여 공백으로 구분된 문자열을 배열로 분리
* `parts[0]`: 신고한 유저 ID
* `parts[1]`: 신고당한 유저 ID

**예시**:
```
입력: "muzi frodo"
출력: parts = ["muzi", "frodo"]
  reporter = "muzi"
  reported = "frodo"
```

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 연산별 시간 복잡도

* **중복 제거**: O(R) - report 배열 길이에 비례
* **신고 횟수 카운트**: O(R) - 고유한 신고 수에 비례
* **정지된 유저 확인**: O(N) - 유저 수에 비례
* **유저별 신고 목록 저장**: O(R) - 고유한 신고 수에 비례
* **메일 수 계산**: O(N × M) - 유저 수 × 평균 신고한 유저 수

**전체 시간 복잡도**: **O(R + N × M)**
- R: report 배열 길이 (최대 200,000)
- N: id_list 길이 (최대 1,000)
- M: 평균 신고한 유저 수 (보통 작음)

### 코드에서의 대응

```java
// 1. 중복 제거: O(R)
Set<String> uniqueReports = new HashSet<>();
for (String report : report) {  // R번 반복
    uniqueReports.add(report);  // O(1) 평균
}

// 2. 신고 횟수 카운트: O(R)
Map<String, Integer> reportCount = new HashMap<>();
for (String report : uniqueReports) {  // 최대 R번 반복
    reportCount.put(reported, ...);  // O(1) 평균
}

// 3. 정지된 유저 확인: O(N)
Set<String> bannedUsers = new HashSet<>();
for (Map.Entry<String, Integer> entry : reportCount.entrySet()) {  // 최대 N번 반복
    if (entry.getValue() >= k) {  // O(1)
        bannedUsers.add(entry.getKey());  // O(1) 평균
    }
}

// 4. 유저별 신고 목록 저장: O(R)
Map<String, Set<String>> userReports = new HashMap<>();
for (String report : uniqueReports) {  // 최대 R번 반복
    userReports.computeIfAbsent(...).add(...);  // O(1) 평균
}

// 5. 메일 수 계산: O(N × M)
for (int i = 0; i < id_list.length; i++) {  // N번 반복
    for (String reportedUser : reported) {  // 평균 M번 반복
        if (bannedUsers.contains(reportedUser)) {  // O(1) 평균
            mailCount++;
        }
    }
}
```

* 첫 번째 루프: R번 반복 (중복 제거)
* 두 번째 루프: 최대 R번 반복 (신고 횟수 카운트)
* 세 번째 루프: 최대 N번 반복 (정지된 유저 확인)
* 네 번째 루프: 최대 R번 반복 (유저별 신고 목록 저장)
* 다섯 번째 루프: N × M번 반복 (메일 수 계산)

➡️ 알고리즘 문서에서 설명한 **"시간 복잡도 분석"**이 코드의 실제 동작과 일치한다.

---

## 5️⃣ 공간 복잡도 분석

### 자료구조별 공간 복잡도

* `uniqueReports` (Set): O(R) - 최대 R개의 고유한 신고 저장
* `reportCount` (Map): O(N) - 유저 수에 비례
* `bannedUsers` (Set): O(N) - 최대 N개의 정지된 유저 저장
* `userReports` (Map): O(N + R) - 유저 수 + 신고 수에 비례
* `answer` (배열): O(N) - 유저 수에 비례

**전체 공간 복잡도**: **O(N + R)**
- N: id_list 길이 (최대 1,000)
- R: report 배열 길이 (최대 200,000)

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 해시맵과 집합 (현재 방법) ✅

**장점**:
* 구현이 간단하고 직관적
* 시간 복잡도 O(R + N × M)로 매우 효율적
* 코드가 간결함
* 해시맵의 O(1) 평균 시간 복잡도로 빠른 조회

**단점**:
* 공간 복잡도 O(N + R)로 추가 메모리 사용

### 방법 2: 배열과 리스트

```java
// 유저 ID를 인덱스로 변환
Map<String, Integer> userIndex = new HashMap<>();
for (int i = 0; i < id_list.length; i++) {
    userIndex.put(id_list[i], i);
}

// 배열로 신고 횟수 카운트
int[] reportCount = new int[id_list.length];
List<List<String>> userReports = new ArrayList<>();
```

**장점**:
* 메모리 효율적 (배열 사용)

**단점**:
* 유저 ID를 인덱스로 변환하는 과정 필요
* 코드가 복잡해짐
* 가독성이 떨어짐

### 방법 3: 완전 탐색

```java
// 모든 신고를 순회하며 직접 계산
for (String user : id_list) {
    int mailCount = 0;
    for (String report : report) {
        // 직접 계산...
    }
}
```

**단점**:
* 시간 복잡도 O(N × R)로 비효율적
* 중복 신고 처리 복잡
* 코드가 복잡함

➡️ **해시맵과 집합을 사용하는 것이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(R + N × M) 시간 복잡도로 문제 제약 조건 내에서 충분히 빠름
* **가독성**: 각 단계가 명확하게 분리되어 이해하기 쉬움

### 추가 최적화 가능성

* **통합 처리**: report 배열을 한 번만 순회하여 처리
  * 가독성이 떨어지므로 권장하지 않음
* **스트림 API**: 함수형 프로그래밍 스타일 사용
  * 가독성 향상, 하지만 성능 오버헤드 가능

현재 구현이 문제 제약 조건 내에서 충분히 효율적이다.

---

## 8️⃣ 해시맵의 효율성

### O(1) 평균 시간 복잡도

해시맵의 주요 연산은 평균적으로 O(1) 시간에 수행됩니다:

* `put(key, value)`: O(1) 평균
* `get(key)`: O(1) 평균
* `containsKey(key)`: O(1) 평균
* `remove(key)`: O(1) 평균

**예시**:
```java
Map<String, Integer> map = new HashMap<>();
map.put("muzi", 1);        // O(1) 평균
int count = map.get("muzi");  // O(1) 평균
```

### 코드에서의 반영

```java
// 신고 횟수 카운트: O(1) 평균
reportCount.put(reported, 
    reportCount.getOrDefault(reported, 0) + 1);

// 정지된 유저 확인: O(1) 평균
if (bannedUsers.contains(reportedUser)) {
    mailCount++;
}
```

➡️ 알고리즘 문서에서 설명한 **"해시맵의 효율성"**이 코드에 명확히 구현되어 있다.

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **해시맵 구조**를 인식하고
* 알고리즘 문서에서 설명한 **해시맵 패턴**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **단순성**: 복잡한 알고리즘 없이 해시맵과 집합 활용
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적 (O(R + N × M))
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **가독성**: 각 단계가 명확하게 분리되어 이해하기 쉬움

