# 알고리즘 선택 이유

### 그래프 모델링
- **정점(Vertex)**: 각 좌표 (i, j)에서 값이 1인 셀
- **엣지(Edge)**: 상하좌우로 인접한 두 개의 1 사이
- **연결된 컴포넌트**: 하나의 단지

### 왜 그래프 탐색인가?
- 인접한 집들을 하나의 그룹으로 묶어야 함
- 연결성을 확인하기 위해 탐색이 필요
- DFS/BFS로 연결된 모든 노드를 방문할 수 있음

## DFS 선택 이유

### DFS vs BFS의 핵심 차이

**중요한 오해 해소**: 상하좌우를 확인하는 것은 DFS와 BFS **모두 동일**합니다!

#### 공통점
- 둘 다 상하좌우 네 방향을 확인합니다
- 둘 다 `visited` 배열로 중복 방문을 방지합니다
- 둘 다 연결된 컴포넌트를 찾을 수 있습니다

#### 차이점: 탐색 방식

**DFS (현재 코드)**:
```java
// 재귀를 사용 - 한 방향으로 깊이 들어감
static int dfs(int x, int y) {
    visited[x][y] = true;
    int count = 1;
    
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        
        if (범위 체크 && 집 있음 && 미방문) {
            count += dfs(nx, ny);  // 즉시 재귀 호출 → 깊이 우선
        }
    }
    return count;
}
```

**탐색 순서**: 한 경로를 끝까지 따라간 후, 되돌아와서 다음 방향 확인
- 예: (0,0) → (0,1) → (0,2) → ... (끝까지) → 돌아와서 (1,0) 확인

**BFS (대안)**:
```java
// 큐를 사용 - 같은 레벨의 모든 노드를 먼저 확인
static int bfs(int startX, int startY) {
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{startX, startY});
    visited[startX][startY] = true;
    int count = 0;
    
    while (!queue.isEmpty()) {
        int[] current = queue.poll();
        count++;
        
        for (int i = 0; i < 4; i++) {
            int nx = current[0] + dx[i];
            int ny = current[1] + dy[i];
            
            if (범위 체크 && 집 있음 && 미방문) {
                visited[nx][ny] = true;
                queue.offer(new int[]{nx, ny});  // 큐에 추가 → 나중에 처리
            }
        }
    }
    return count;
}
```

**탐색 순서**: 시작점에서 거리 0 → 거리 1 → 거리 2 순서로 레벨별 탐색
- 예: (0,0) → (0,0)의 모든 인접 노드 → 그 다음 레벨의 모든 노드

#### 시각적 비교

```
지도:
111
101
111

DFS 탐색 순서 (깊이 우선):
1 → 2 → 5 → 8 → 9 → 6 → 3 → 4 → 7
(한 경로를 끝까지)

BFS 탐색 순서 (너비 우선):
1 → 2 → 4 → 3 → 5 → 7 → 6 → 8 → 9
(레벨별: 거리 0 → 1 → 2)
```

### DFS vs BFS 선택 기준

두 방법 모두 가능하지만, 이 문제에서는 **DFS가 더 간단**합니다:

1. **코드 간결성**: 재귀 호출로 구현이 간단 (BFS는 큐 필요)
2. **메모리 효율**: 스택 공간만 필요 (BFS는 큐에 많은 노드 저장 가능)
3. **카운팅 용이**: 재귀 반환값으로 쉽게 집의 수를 계산

### DFS의 장점
- 재귀 호출로 자연스럽게 카운트 누적 가능
- 구현이 직관적이고 이해하기 쉬움
- 이 문제의 규모(N ≤ 25)에서는 스택 오버플로우 걱정 없음

## 시간 복잡도 분석

### 왜 O(N²)인가?

1. **외부 이중 루프**: O(N²)
   ```java
   for (int i = 0; i < n; i++) {
       for (int j = 0; j < n; j++) {
           // 각 셀을 한 번씩 확인
       }
   }
   ```

2. **DFS 호출**: 각 셀은 최대 한 번만 방문됨
   - `visited` 배열로 중복 방문 방지
   - 전체 그래프를 한 번만 순회하므로 O(N²)

3. **전체 시간 복잡도**: O(N²)
   - 모든 셀을 한 번씩 확인: O(N²)
   - 각 셀에서 DFS: 최대 O(N²)이지만, 각 셀은 한 번만 방문되므로
   - **실제로는 O(N²)**

### 공간 복잡도
- 지도 저장: O(N²)
- visited 배열: O(N²)
- 재귀 스택: 최대 O(N²) (최악의 경우 모든 셀이 연결된 경우)
- **총 O(N²)**

## 제한 조건 검증

- **N ≤ 25**: N² = 625
- **시간 제한 1초**: O(N²) 알고리즘으로 충분히 해결 가능
- **메모리 제한 128MB**: O(N²) 공간 사용으로 충분

## 구현 세부사항의 선택 이유

### 범위 체크가 필요한 이유
- 2차원 배열의 경계에서 인접 셀 탐색 시 범위를 벗어날 수 있음
- 예: (0, 0)에서 위쪽(-1)이나 왼쪽(-1)으로 이동하면 음수 인덱스 접근
- 예: (n-1, n-1)에서 아래쪽(n)이나 오른쪽(n)으로 이동하면 배열 크기 초과
- 범위 체크 없이는 `ArrayIndexOutOfBoundsException` 발생

### 방문 체크가 필요한 이유

#### 집 여부 확인 (`map[nx][ny] == 1`)
- **없으면**: 0인 셀도 탐색하게 되어 잘못된 결과 발생
- **효과**: 집이 있는 곳만 탐색하여 정확한 단지 구성

#### 방문 여부 확인 (`!visited[nx][ny]`)
- **없으면**: 
  - 무한 루프 발생 가능 (A → B → A → B ...)
  - 같은 집을 여러 번 카운트하여 잘못된 집 수 계산
  - 시간 복잡도가 O(N²)를 초과할 수 있음
- **효과**: 
  - 각 셀을 정확히 한 번만 방문
  - 시간 복잡도 O(N²) 보장
  - 정확한 집 수 계산

**조건들의 상호작용:**
- 세 조건은 **AND 연산**으로 결합되어 모두 만족해야만 탐색 진행
- 각 조건은 서로 다른 목적을 가짐:
  - 범위 체크: 안전성 (예외 방지)
  - 집 여부: 정확성 (올바른 셀만 탐색)
  - 방문 여부: 효율성 (중복 방문 방지)

## 대안 방법

### BFS 사용 가능
- 큐를 사용하여 레벨별 탐색
- 동일한 시간 복잡도 O(N²)
- 이 문제에서는 DFS가 더 간단

**BFS 구현 예시:**
```java
static int bfs(int startX, int startY) {
    Queue<int[]> queue = new LinkedList<>();
    queue.offer(new int[]{startX, startY});
    visited[startX][startY] = true;
    int count = 0;
    
    while (!queue.isEmpty()) {
        int[] current = queue.poll();
        count++;
        
        for (int i = 0; i < 4; i++) {
            int nx = current[0] + dx[i];
            int ny = current[1] + dy[i];
            
            if (nx >= 0 && nx < n && ny >= 0 && ny < n 
                && map[nx][ny] == 1 && !visited[nx][ny]) {
                visited[nx][ny] = true;
                queue.offer(new int[]{nx, ny});
            }
        }
    }
    return count;
}
```

**차이점 요약:**
- **DFS**: 재귀 호출 → 즉시 깊이 들어감 → 스택 사용
- **BFS**: 큐에 추가 → 나중에 처리 → 큐 사용
- **결과**: 둘 다 같은 결과를 얻지만, 탐색 순서만 다름

### Union-Find 사용 가능
- 각 셀을 독립적인 집합으로 시작
- 인접한 1들을 union
- 최종적으로 집합의 개수와 크기 계산
- 이 문제에서는 오버엔지니어링

## 결론

- **그래프 탐색 문제**로 올바르게 해석
- **DFS**로 구현하는 것이 적절
- **O(N²) 시간 복잡도**로 효율적
- **제한 조건 내에서 충분히 해결 가능**

