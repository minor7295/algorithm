# 알고리즘 설계

## 문제 해석

이 문제는 **그래프의 연결된 컴포넌트(Connected Component)**를 찾는 문제입니다.

- 각 좌표를 정점(vertex)으로 볼 수 있음
- 인접한 1들(상하좌우)은 엣지(edge)로 연결된 것으로 해석
- 하나의 단지 = 하나의 연결된 컴포넌트
- 각 컴포넌트의 크기(집의 수)를 계산해야 함

## 접근 방법

1. **2차원 배열로 지도 저장**
   - 입력받은 지도를 2차원 배열에 저장
   - 1의 위치를 파악

2. **DFS/BFS로 그래프 탐색**
   - 모든 셀을 순회하면서 1을 발견하면 DFS 시작
   - DFS로 연결된 모든 1을 탐색하며 집의 수를 카운트
   - 방문한 곳은 `visited` 배열로 표시하여 중복 방문 방지

3. **단지 정보 수집 및 정렬**
   - 각 단지의 집 수를 리스트에 저장
   - 오름차순으로 정렬하여 출력

## 시간 복잡도 분석

- **시간 복잡도: O(N²)**
  - 모든 셀을 한 번씩 순회: O(N²)
  - 각 셀에서 DFS 수행: 최대 O(N²) (모든 셀을 방문하는 경우)
  - 하지만 각 셀은 최대 한 번만 방문되므로 전체적으로 O(N²)
  
- **공간 복잡도: O(N²)**
  - 지도 저장: O(N²)
  - visited 배열: O(N²)
  - 재귀 호출 스택: 최대 O(N²) (최악의 경우)

## 전체 흐름

```
1. 입력 받기
   - N 읽기
   - N×N 지도 읽기

2. 초기화
   - visited 배열 생성 (방문 여부 체크)
   - 단지별 집 수를 저장할 리스트 생성

3. 그래프 탐색
   - 모든 셀 (i, j)를 순회:
     - map[i][j] == 1이고 visited[i][j] == false이면
       - DFS 시작
       - 연결된 집의 수를 카운트하여 리스트에 추가

4. 결과 출력
   - 단지 수 출력 (리스트 크기)
   - 리스트를 오름차순 정렬
   - 각 단지의 집 수 출력
```

## DFS 알고리즘

```java
dfs(x, y):
    1. visited[x][y] = true (방문 표시)
    2. count = 1 (현재 집 포함)
    
    3. 상하좌우 네 방향 확인:
       for each direction (상, 하, 좌, 우):
           nx = x + dx[direction]
           ny = y + dy[direction]
           
           if (범위 내 && map[nx][ny] == 1 && !visited[nx][ny]):
               count += dfs(nx, ny)
    
    4. return count
```

## 상세 구현

### 1. 방향 벡터
```java
int[] dx = {-1, 1, 0, 0};  // 상, 하, 좌, 우
int[] dy = {0, 0, -1, 1};
```

### 2. 범위 체크
- 0 ≤ nx < N
- 0 ≤ ny < N

**필요성:**
- 배열 인덱스 범위를 벗어나면 `ArrayIndexOutOfBoundsException` 발생
- 경계 셀(가장자리)에서 상하좌우 탐색 시 범위를 벗어날 수 있음
- 예: (0, 0)에서 위쪽(-1)이나 왼쪽(-1)으로 이동하면 범위 초과

**구현:**
```java
if (nx >= 0 && nx < n && ny >= 0 && ny < n 
    && map[nx][ny] == 1 && !visited[nx][ny]) {
    count += dfs(nx, ny);
}
```

### 3. 방문 조건

#### 3.1 집 여부 확인: `map[nx][ny] == 1`
- **목적**: 집이 있는 곳만 탐색
- **이유**: 0은 집이 없는 곳이므로 단지에 포함되지 않음
- **효과**: 불필요한 탐색 방지, 알고리즘 효율성 향상

#### 3.2 방문 여부 확인: `!visited[nx][ny]`
- **목적**: 이미 방문한 셀은 다시 방문하지 않음
- **이유**: 
  - 무한 루프 방지 (이미 탐색한 단지에 다시 들어가는 것 방지)
  - 중복 카운팅 방지 (같은 집을 여러 번 세는 것 방지)
  - 시간 복잡도 보장 (각 셀은 최대 한 번만 방문)

**조건 결합의 의미:**
- 세 가지 조건을 모두 만족해야 DFS 재귀 호출
  1. **범위 내**: 배열 인덱스 유효성
  2. **집 존재**: 실제로 집이 있는 곳
  3. **미방문**: 아직 탐색하지 않은 곳
- 하나라도 만족하지 않으면 해당 방향으로는 더 이상 탐색하지 않음

**예시:**
```
현재 위치: (2, 3)
상하좌우 확인:
- 위쪽 (1, 3): 범위 내 ✓, 집 있음 ✓, 미방문 ✓ → DFS 호출
- 아래쪽 (3, 3): 범위 내 ✓, 집 없음 ✗ → 스킵
- 왼쪽 (2, 2): 범위 내 ✓, 집 있음 ✓, 이미 방문 ✗ → 스킵
- 오른쪽 (2, 4): 범위 초과 ✗ → 스킵
```

### 4. 결과 수집
- 각 DFS 호출마다 연결된 집의 수를 반환
- 리스트에 추가 후 정렬

## 예제 실행 흐름

```
지도:
0110100
0110101
1110101
0000111
0100000
0111110
0111000

1. (0,1)에서 시작 → DFS → 단지 1: 7개 집
2. (0,5)에서 시작 → DFS → 단지 2: 8개 집  
3. (3,4)에서 시작 → DFS → 단지 3: 9개 집

결과: 3개 단지, 집 수: 7, 8, 9
```

