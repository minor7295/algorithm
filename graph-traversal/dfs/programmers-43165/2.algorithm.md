# 알고리즘: DFS (깊이 우선 탐색)

> 📖 **전체 알고리즘 설명**: [DFS (깊이 우선 탐색) 정리](../dfs.md)

이 문제는 **DFS (Depth-First Search, 깊이 우선 탐색)** 알고리즘을 사용하여 해결합니다.  
상위 폴더의 [DFS 정리 문서](../dfs.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 DFS 적용

### 문제 특성

* **이진 선택**: 각 숫자마다 더하기(+) 또는 빼기(-) 중 하나를 선택
* **순서 고정**: 숫자들의 순서를 바꿀 수 없음
* **목표 달성**: 최종 합이 타겟 넘버와 일치해야 함
* **제약 조건**: `2 ≤ n ≤ 20` (최대 경우의 수: 2^20 = 1,048,576)

---

## 이 문제의 특이사항

### 1️⃣ 이진 선택 트리 구조

이 문제는 **각 단계마다 정확히 2가지 선택지**만 있습니다:

* ✅ **더하기 (+)**: 현재 숫자를 합에 더함
* ✅ **빼기 (-)**: 현재 숫자를 합에서 뺌

이로 인해 상태 공간 트리가 **이진 트리(Binary Tree)** 구조를 가집니다.

### 2️⃣ 가지치기 최적화 (선택사항)

이 문제에서 **가지치기(Pruning)**를 사용할 수 있습니다.

**가지치기 원리:**
* 남은 숫자들의 합을 미리 계산하여 불가능한 경로 조기 종료
* 최대 가능한 합: `sum + suffixSum[index]` (남은 숫자들을 모두 더하기)
* 최소 가능한 합: `sum - suffixSum[index]` (남은 숫자들을 모두 빼기)
* 가지치기 조건: 타겟이 `[minSum, maxSum]` 범위 밖에 있으면 불가능 → 조기 종료

**효용성:**
* 일반적인 경우: 가지치기 효과가 제한적 (타겟이 합 범위 내에 있는 경우가 많음)
* 극단적인 경우: 가지치기가 효과적 (타겟이 매우 크거나 작은 경우)

**권장사항:**
* n ≤ 20이므로 **간단한 버전(가지치기 없음)으로도 충분히 빠름**
* 가지치기 판단 기준과 구체적인 예시는 [3.reasoning.md](./3.reasoning.md) 참고

### 3️⃣ 시간 복잡도

* **상태 공간 크기**: 2^n (각 숫자마다 2가지 선택지)
* **각 노드 처리 시간**: O(1) (덧셈/뺄셈 연산, 가지치기 체크)
* **전체 시간 복잡도**: **O(2^n)** (최악의 경우)
  * 가지치기를 통해 실제 탐색하는 노드 수는 최악의 경우보다 훨씬 적을 수 있음
  * 하지만 시간 복잡도는 여전히 지수 시간

제약 조건 `2 ≤ n ≤ 20`로 인해 최악의 경우 2^20 = 1,048,576개의 경우를 탐색하지만, 가지치기를 통해 실제로는 더 적은 경우만 탐색하게 됩니다.

### 4️⃣ 공간 복잡도

* **재귀 호출 스택**: O(n) (최대 깊이 n)
* **suffixSum 배열**: O(n) (남은 숫자들의 합을 저장)
* **추가 공간**: O(1) (합을 저장하는 변수만 필요)
* **전체 공간 복잡도**: **O(n)**

---

## 핵심 구현 패턴

### 방법 1: 간단한 버전 (가지치기 없음) ✅ 권장

**핵심 로직:**
```java
dfs(index, sum):
    if index == numbers.length:
        return (sum == target) ? 1 : 0
    
    return dfs(index + 1, sum + numbers[index]) +    // 더하기
           dfs(index + 1, sum - numbers[index])       // 빼기
```

구현이 간단하고, n ≤ 20이므로 충분히 빠릅니다.

### 방법 2: 최적화 버전 (가지치기 포함)

**핵심 로직:**
```java
// 전처리: suffixSum[i] = numbers[i..n-1]의 합
suffixSum = [남은 숫자들의 합 배열]

dfs(index, sum):
    if index == numbers.length:
        return (sum == target) ? 1 : 0
    
    // 가지치기: 타겟이 도달 가능 범위 밖이면 조기 종료
    if target < (sum - suffixSum[index]) || target > (sum + suffixSum[index]):
        return 0
    
    return dfs(index + 1, sum + numbers[index]) +
           dfs(index + 1, sum - numbers[index])
```

**차이점:** 가지치기 조건 체크 추가 (`target ∈ [minSum, maxSum]`)

### 구현 선택 가이드

| 버전 | 핵심 특징 | 권장 상황 |
|------|----------|----------|
| **간단한 버전** | 구현 간단, 코드 명확 | ✅ **일반적인 경우 (권장)** |
| **최적화 버전** | 가지치기로 극단적 케이스 최적화 | 극단적인 케이스 예상 시 |

**결론**: n ≤ 20이므로 **간단한 버전으로도 충분히 빠르며, 구현이 간단하여 권장**합니다.

---

## 다른 DFS 문제와의 차이점

| 특징 | 일반 DFS (그래프 탐색) | 이 문제 (43165) |
|------|---------------------|----------------|
| 탐색 대상 | 그래프의 정점과 간선 | 상태 공간 트리 |
| 선택지 개수 | 가변적 (인접 정점 개수) | 고정 (2개: 더하기/빼기) |
| 방문 체크 | 필요 (같은 정점 재방문 방지) | 불필요 (상태 공간 트리) |
| 상태 저장 | 정점 번호 | (인덱스, 합) 조합 |
| 구현 복잡도 | 중간 | 낮음 |

---

## 상태 공간 트리 예시

`numbers = [1, 1, 1]`, `target = 1`인 경우의 상태 공간 트리:

```
                    [index=0, sum=0]
                   /                  \
                  /                    \
        [+1]                            [-1]
    [index=1, sum=1]              [index=1, sum=-1]
       /        \                    /        \
      /          \                  /          \
  [+1]          [-1]            [+1]          [-1]
[index=2, sum=2] [index=2, sum=0] [index=2, sum=0] [index=2, sum=-2]
   /      \         /      \         /      \         /      \
  ...     ...      ...     ...      ...     ...      ...     ...
```

각 레벨에서 더하기와 빼기를 선택하여 다음 레벨로 진행하고, 모든 숫자를 처리했을 때(`index == numbers.length`) 합이 타겟과 일치하는지 확인합니다.

---

## 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용 (O(n))
* **완전 탐색**: 모든 경우의 수를 탐색하여 정확한 답 보장

### 가지치기 최적화의 실제 효과

* 가지치기를 통해 불가능한 경로를 조기 종료하여 탐색 효율을 높일 수 있음
* 하지만 일반적인 케이스에서는 효과가 제한적
* 구체적인 판단 기준과 예시는 [3.reasoning.md](./3.reasoning.md) 참고

### 추가 최적화 가능성

* **메모이제이션**: 동일한 (index, sum) 조합이 반복될 수 있지만, 이 문제에서는 각 경로가 독립적이므로 메모이제이션의 이점이 제한적
* **간단한 버전**: 가지치기 없이 구현해도 n ≤ 20이므로 충분히 빠름
* 현재 구현(가지치기 포함)은 최적화 버전이며, 필요에 따라 간단한 버전도 사용 가능

---

## 참고

* 전체 DFS 알고리즘 설명: [../dfs.md](../dfs.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

