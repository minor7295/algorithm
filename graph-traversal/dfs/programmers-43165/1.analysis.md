# 타겟 넘버

## 📌 문제 요약

n개의 음이 아닌 정수들이 있습니다. 이 정수들을 **순서를 바꾸지 않고** 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 반환해야 합니다.

---

## 🔍 문제 설명

* **목표**: 주어진 숫자들을 순서대로 더하거나 빼서 타겟 넘버를 만드는 방법의 수 찾기
* **제약 조건**: 
  - 숫자들의 순서는 바꿀 수 없음
  - 각 숫자는 더하거나 빼야 함 (선택지 2가지)
* **예시**: `[1, 1, 1, 1, 1]`로 숫자 3을 만들려면 다음 다섯 방법이 있습니다:
  - `-1+1+1+1+1 = 3`
  - `+1-1+1+1+1 = 3`
  - `+1+1-1+1+1 = 3`
  - `+1+1+1-1+1 = 3`
  - `+1+1+1+1-1 = 3`

---

## 📥 입력 조건

* `numbers`: 사용할 수 있는 숫자가 담긴 배열
  * 배열의 길이: 2 이상 20 이하
  * 각 숫자: 1 이상 50 이하인 자연수
* `target`: 타겟 넘버
  * 1 이상 1000 이하인 자연수

---

## 📤 출력 조건

* 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 반환
* 반환 타입: `int`

---

## 💡 문제 핵심 해석

이 문제는 **DFS(Depth-First Search, 깊이 우선 탐색)**를 사용하여 해결할 수 있는 전형적인 문제입니다.

### 핵심 조건

* **순서 고정**: 숫자들의 순서를 바꿀 수 없음
* **이진 선택**: 각 숫자마다 더하기(+) 또는 빼기(-) 중 하나를 선택
* **목표 달성**: 최종 합이 타겟 넘버와 일치해야 함

### DFS 접근 가능성

이 문제는 **DFS 알고리즘이 적합**합니다:

* **상태 공간**: 각 숫자마다 2가지 선택지 (더하기 또는 빼기)
* **총 경우의 수**: 2^n (n은 숫자의 개수)
* **제약 조건**: n ≤ 20이므로 최대 2^20 = 1,048,576가지 경우 (충분히 처리 가능)
* **탐색 방식**: 재귀를 사용하여 모든 경우를 탐색
* **가지치기 최적화**: 남은 숫자들의 합을 미리 계산하여 불가능한 경로를 조기 종료

예를 들어, `numbers = [1, 1, 1, 1, 1]`, `target = 3`인 경우:

**상태 공간 트리 (일부):**
```
                    [0] (시작 합: 0)
                   /  \
                  /    \
            [+1]        [-1]
            /  \        /  \
           /    \      /    \
      [+1]      [-1]  [+1]  [-1]
      /  \      /  \  /  \  /  \
    ...  ...  ... ... ... ... ...
```

각 레벨에서 더하기 또는 빼기를 선택하여 다음 레벨로 진행하고, 모든 숫자를 처리했을 때 합이 타겟과 일치하는지 확인합니다.

---

## 🧠 해결 전략 개요

1. **재귀 함수 정의**: 현재 인덱스와 현재까지의 합을 매개변수로 받는 함수
2. **종료 조건**: 모든 숫자를 처리했을 때 (`index == numbers.length`)
   - 현재 합이 타겟과 일치하면 카운트 증가
3. **재귀 호출**: 각 숫자마다 더하기와 빼기 두 가지 경우를 모두 탐색
4. **결과 반환**: 타겟과 일치하는 경우의 수 반환

---

## ✨ 예시

### 예시 1: 문제에서 제공한 예제

**입력**
```
numbers = [1, 1, 1, 1, 1]
target = 3
```

**처리 과정**
```
시작: index=0, sum=0

index=0, sum=0
├─ +1 선택 → index=1, sum=1
│  ├─ +1 선택 → index=2, sum=2
│  │  ├─ +1 선택 → index=3, sum=3
│  │  │  ├─ +1 선택 → index=4, sum=4
│  │  │  │  └─ +1 선택 → index=5, sum=5 (불일치)
│  │  │  └─ -1 선택 → index=4, sum=2
│  │  │     └─ +1 선택 → index=5, sum=3 ✅ (일치!)
│  │  └─ -1 선택 → index=3, sum=1
│  │     └─ ... (계속 탐색)
│  └─ -1 선택 → index=2, sum=0
│     └─ ... (계속 탐색)
└─ -1 선택 → index=1, sum=-1
   └─ ... (계속 탐색)

총 5가지 방법 발견:
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```

**출력**
```
5
```

### 예시 2: 문제에서 제공한 예제

**입력**
```
numbers = [4, 1, 2, 1]
target = 4
```

**처리 과정**
```
시작: index=0, sum=0

index=0, sum=0
├─ +4 선택 → index=1, sum=4
│  ├─ +1 선택 → index=2, sum=5
│  │  ├─ +2 선택 → index=3, sum=7
│  │  │  └─ +1 선택 → index=4, sum=8 (불일치)
│  │  └─ -2 선택 → index=3, sum=3
│  │     └─ +1 선택 → index=4, sum=4 ✅ (일치!)
│  └─ -1 선택 → index=2, sum=3
│     ├─ +2 선택 → index=3, sum=5
│     │  └─ +1 선택 → index=4, sum=6 (불일치)
│     └─ -2 선택 → index=3, sum=1
│        └─ +1 선택 → index=4, sum=2 (불일치)
└─ -4 선택 → index=1, sum=-4
   └─ ... (계속 탐색, 타겟 4에 도달 불가)

총 2가지 방법 발견:
+4+1-2+1 = 4
+4-1+2-1 = 4
```

**출력**
```
2
```

### 예시 3: 간단한 경우

**입력**
```
numbers = [1, 1]
target = 0
```

**처리 과정**
```
시작: index=0, sum=0

index=0, sum=0
├─ +1 선택 → index=1, sum=1
│  └─ -1 선택 → index=2, sum=0 ✅ (일치!)
└─ -1 선택 → index=1, sum=-1
   └─ +1 선택 → index=2, sum=0 ✅ (일치!)

총 2가지 방법 발견:
+1-1 = 0
-1+1 = 0
```

**출력**
```
2
```

---

## 📝 정리

이 문제는 **DFS (깊이 우선 탐색) 알고리즘**을 사용하여 해결할 수 있는 전형적인 문제입니다.

* **핵심 조건**: 숫자들을 순서대로 더하거나 빼서 타겟 넘버 만들기
* **전략**: 재귀를 사용하여 상태 공간 트리를 깊이 우선으로 탐색하며, 각 숫자마다 더하기와 빼기 두 가지 경우를 모두 탐색
* **시간 복잡도**: O(2^n) - 각 숫자마다 2가지 선택지, n개의 숫자
* **공간 복잡도**: O(n) - 재귀 호출 스택의 최대 깊이
* **제약 조건**: n ≤ 20이므로 최대 2^20 = 1,048,576가지 경우 (충분히 처리 가능)

