# Main.java 설계 근거 정리

이 문서는 **프로그래머스 43165 타겟 넘버 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **DFS 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: DFS (깊이 우선 탐색)

### 문제 특성과의 적합성

* 문제 요구사항
  * n개의 숫자를 순서대로 더하거나 빼서 타겟 넘버 만들기
  * 각 숫자마다 **더하기(+) 또는 빼기(-)** 중 하나를 선택
  * 타겟과 일치하는 경우의 수 찾기
* 제약 조건
  * `2 ≤ n ≤ 20`
  * 최대 경우의 수: 2^20 = 1,048,576 (충분히 처리 가능)

이 문제는 **이진 선택 트리 탐색** 문제로, 다음과 같은 특성이 있다:

* 각 단계마다 **정확히 2가지 선택지** (더하기 또는 빼기)
* **순서 고정**: 숫자들의 순서를 바꿀 수 없음
* **완전 탐색 필요**: 모든 경우의 수를 탐색해야 정확한 답을 얻을 수 있음

➡️ 이러한 조건을 가장 직관적으로 만족하는 방법이 **DFS (깊이 우선 탐색)** 이다.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 재귀 함수 구조

```java
static int dfs(int[] numbers, int target, int index, int sum) {
    // 종료 조건
    if (index == numbers.length) {
        return (sum == target) ? 1 : 0;
    }
    
    // 더하기 선택
    int add = dfs(numbers, target, index + 1, sum + numbers[index]);
    
    // 빼기 선택
    int subtract = dfs(numbers, target, index + 1, sum - numbers[index]);
    
    return add + subtract;
}
```

* 알고리즘 문서에서 설명한 **DFS 기본 템플릿**과 정확히 일치한다
* `index == numbers.length`: 종료 조건 - 모든 숫자를 처리했을 때
* `sum + numbers[index]`: 더하기 선택
* `sum - numbers[index]`: 빼기 선택
* `dfs(index + 1, ...)`: 다음 숫자로 재귀 호출

➡️ **상태 공간 트리를 깊이 우선으로 탐색**하는 DFS 구조가 코드에 그대로 반영되어 있다.

---

### ② 이진 선택의 구현

```java
// 더하기 선택
int add = dfs(numbers, target, index + 1, sum + numbers[index], suffixSum);

// 빼기 선택
int subtract = dfs(numbers, target, index + 1, sum - numbers[index], suffixSum);

return add + subtract;
```

* 알고리즘 문서에서 설명한 대로, **각 단계마다 정확히 2가지 선택지**만 있다
* 더하기와 빼기를 각각 재귀 호출하여 탐색
* 두 가지 경우의 결과를 합산하여 반환

➡️ 이는 **이진 선택 트리의 핵심 특징**이 코드에 직접 반영된 것이다.

### ②-1 가지치기 최적화

```java
// 가지치기: 남은 숫자들을 모두 더하거나 빼도 타겟에 도달할 수 없는 경우
int maxSum = sum + suffixSum[index];
int minSum = sum - suffixSum[index];
if (target < minSum || target > maxSum) {
    return 0;  // 불가능한 경로 조기 종료
}
```

* **suffixSum[index]**: `numbers[index]`부터 `numbers[n-1]`까지의 합
* **maxSum**: 현재 합에서 남은 숫자들을 모두 더했을 때의 최대값
* **minSum**: 현재 합에서 남은 숫자들을 모두 뺐을 때의 최소값
* 타겟이 `[minSum, maxSum]` 범위 밖에 있으면 도달 불가능 → 조기 종료

➡️ 이는 **가지치기 최적화**가 코드에 구현된 것이다. 불가능한 경로를 조기 종료하여 탐색 효율을 높입니다.

**가지치기 판단 기준과 구체적인 예시는 아래 "7️⃣ 가지치기 최적화 판단 기준" 섹션을 참고**

---

### ③ 종료 조건과 결과 집계

```java
if (index == numbers.length) {
    return (sum == target) ? 1 : 0;
}
```

* 모든 숫자를 처리했을 때(`index == numbers.length`) 타겟과 일치하는지 확인
* 일치하면 1을 반환 (하나의 방법 발견)
* 불일치하면 0을 반환 (방법 없음)
* 재귀 호출의 결과를 합산하여 최종 답을 구함

➡️ 알고리즘 문서에서 설명한 **"모든 숫자를 처리한 후 타겟과 일치하는지 확인"**이 코드에 구현되어 있다.

---

## 3️⃣ 재귀 호출의 의미

### 상태 공간 트리 탐색

재귀 호출 `dfs(index + 1, sum + numbers[index])`와 `dfs(index + 1, sum - numbers[index])`는 다음과 같은 의미를 가진다:

1. **현재 숫자를 더하거나 뺀 상태**에서
2. **다음 숫자로 진행**하여
3. **상태 공간 트리의 다음 레벨을 탐색**

### 예시: numbers=[1, 1, 1], target=1인 경우

```
dfs(0, 0) 호출
  ├─ 더하기 선택: dfs(1, 0+1=1)
  │   ├─ 더하기 선택: dfs(2, 1+1=2)
  │   │   └─ 더하기 선택: dfs(3, 2+1=3) → index==3, sum=3≠1 → 0 반환
  │   │   └─ 빼기 선택: dfs(3, 2-1=1) → index==3, sum=1==1 → 1 반환 ✅
  │   └─ 빼기 선택: dfs(2, 1-1=0)
  │       └─ ... (계속 탐색)
  └─ 빼기 선택: dfs(1, 0-1=-1)
      └─ ... (계속 탐색)
```

➡️ 이는 알고리즘 문서에서 설명한 **상태 공간 트리**를 그대로 탐색하는 과정이다.

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 상태 공간 크기

* 각 숫자마다 2개의 선택지
* n개의 숫자
* 총 경우의 수: **2^n**

### 재귀 호출 횟수

* 각 노드에서 2개의 자식 노드 생성
* 깊이 n까지 탐색
* 총 노드 수: 1 + 2 + 2^2 + ... + 2^n = 2^(n+1) - 1
* 하지만 실제로는 리프 노드만 결과에 기여하므로, **O(2^n)** 시간 복잡도

### 코드에서의 대응

```java
// 가지치기: 불가능한 경로 조기 종료
int maxSum = sum + suffixSum[index];
int minSum = sum - suffixSum[index];
if (target < minSum || target > maxSum) {
    return 0;  // 가지치기
}

int add = dfs(numbers, target, index + 1, sum + numbers[index], suffixSum);
int subtract = dfs(numbers, target, index + 1, sum - numbers[index], suffixSum);
```

* 각 재귀 호출마다 2개의 선택지 탐색
* 재귀 깊이: n
* 가지치기를 통해 불가능한 경로는 조기 종료
* 전체 시간 복잡도: **O(2^n)** (최악의 경우, 실제로는 가지치기로 더 적음)

---

## 5️⃣ 공간 복잡도 분석

### 재귀 호출 스택

* 최대 재귀 깊이: n
* 각 재귀 호출마다 스택 프레임 생성
* 스택 공간: **O(n)**

### 추가 공간

* `sum` 변수: O(1)
* `index` 변수: O(1)
* 기타 변수: O(1)

### 전체 공간 복잡도

* **O(n)** - 재귀 스택이 n에 비례

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: DFS (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 메모리 효율적 (O(n))
* 코드가 간결하고 이해하기 쉬움

**단점:**
* 재귀 호출로 인한 스택 오버플로우 가능성 (하지만 n ≤ 20이므로 문제 없음)

### 방법 2: 반복문 + 비트마스크

```java
int count = 0;
for (int mask = 0; mask < (1 << n); mask++) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        if ((mask & (1 << i)) != 0) {
            sum += numbers[i];
        } else {
            sum -= numbers[i];
        }
    }
    if (sum == target) count++;
}
```

**장점:**
* 스택 오버플로우 걱정 없음
* 반복문만 사용하여 구현

**단점:**
* 코드가 복잡하고 이해하기 어려움
* 비트마스크 개념 필요
* 시간 복잡도는 동일 (O(2^n))

### 방법 3: 동적 프로그래밍 (DP)

**단점:**
* 합의 범위가 넓어서 (최대 ±1000) 메모이제이션 테이블이 커짐
* 구현이 복잡함
* 이 문제에서는 DFS가 더 적합

➡️ **DFS가 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 가지치기 최적화 판단 기준

### 가지치기 원리

* 남은 숫자들의 합(`suffixSum`)을 미리 계산하여 타겟이 도달 가능한 범위 `[minSum, maxSum]` 밖에 있으면 조기 종료
* 오버헤드: `suffixSum` 배열 생성 O(n), 각 노드 체크 O(1) → n ≤ 20이므로 무시 가능

### 가지치기 효용성 예시

| 케이스 | 가지치기 없이 | 가지치기 있으면 | 성능 차이 | 판단 |
|--------|--------------|----------------|----------|------|
| `[1,1,1,1,1]`, `target=100`<br/>(도달 불가능) | 32번 호출 | 1번 호출 | **32배** | ✅ 가장 효과적 |
| `[100,200,300]`, `target=1`<br/>(극단적) | 8번 호출 | 여러 경로 조기 종료 | **2-3배** | ✅ 효과적 |
| `[50,50,50,50,50]`, `target=1`<br/>(큰 숫자) | 32번 호출 | 많은 경로 조기 종료 | **3-5배** | ✅ 효과적 |
| `[1,1,1,1,1]`, `target=3`<br/>(일반적) | 32번 호출 | 거의 조기 종료 없음 | **미미함** | ❌ 효과 제한적 |

### 판단 기준

**가지치기가 효과적인 경우:**
* 타겟이 도달 불가능한 경우 → 첫 노드에서 즉시 종료
* 타겟이 가능하지만 극단적인 경우 (합 범위의 양 끝, 큰 숫자들)

**가지치기가 효과가 제한적인 경우:**
* 일반적인 케이스 (타겟이 합 범위 중간, 작은 숫자들) → 대부분 경로가 유효

### 최종 권장사항

**간단한 버전(가지치기 없음) 권장 ✅**
* n ≤ 20이므로 2^20 = 1,048,576개 노드도 충분히 빠름
* 구현 간단, 코드 명확
* 일반적인 케이스에서는 가지치기 효과 제한적

**가지치기 버전 고려:** 극단적인 케이스 예상 시 (타겟이 매우 크거나 작은 경우, 큰 숫자들)

---

## 8️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **재귀적 사고**: 문제의 구조를 자연스럽게 표현

### 추가 최적화 가능성

* **메모이제이션**: 동일한 (index, sum) 조합이 반복될 수 있지만, 이 문제에서는 각 경로가 독립적이므로 메모이제이션의 이점이 제한적
* **가지치기**: 위 "7️⃣ 가지치기 최적화 판단 기준" 섹션 참고
* 현재 구현(간단한 버전)이 문제 제약 조건 내에서 충분히 효율적

---

## 9️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응

