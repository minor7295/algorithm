# 알고리즘: DFS (깊이 우선 탐색)

> 📖 **전체 알고리즘 설명**: [DFS (깊이 우선 탐색) 정리](../dfs.md)

이 문제는 **DFS (Depth-First Search, 깊이 우선 탐색)** 알고리즘을 사용하여 해결합니다.

---

## 이 문제에서의 DFS 적용

### 문제 특성

* **방향 그래프**: 순열을 방향 그래프로 표현
* **사이클 찾기**: 각 정점이 정확히 하나의 사이클에 속함
* **연결 요소 개수**: 사이클의 개수 = 연결 요소의 개수
* **입력 크기**: N ≤ 1,000 (작은 크기)

---

## 이 문제의 특이사항

### 1️⃣ 순열 그래프 모델링

이 문제는 **순열을 방향 그래프로 모델링**합니다.

**특징:**
* 각 정점 i에서 정점 πi로 가는 간선이 존재
* 각 정점은 정확히 하나의 나가는 간선을 가짐
* 각 정점은 정확히 하나의 들어오는 간선을 가짐
* 따라서 그래프는 여러 개의 사이클로 구성됨

### 2️⃣ 그래프 표현

* **정점**: 1부터 N까지의 정수
* **간선**: i → permutation[i]
* **그래프 표현**: 배열 `permutation[]`로 표현
  * `permutation[i]`는 정점 i에서 가는 간선의 목적지

### 3️⃣ 사이클 찾기

* 방문하지 않은 정점에서 DFS를 시작
* DFS가 완료되면 하나의 사이클을 찾은 것
* DFS를 시작한 횟수 = 사이클의 개수

### 4️⃣ 시간 복잡도

* **그래프 구성**: O(N) (순열 입력 읽기)
* **DFS 수행**: O(N) (모든 정점을 최대 한 번씩 방문)
* **전체 시간 복잡도**: **O(N)**

입력 크기가 작으므로(N ≤ 1,000) 충분히 빠르게 동작합니다.

### 5️⃣ 공간 복잡도

* **순열 저장**: O(N)
* **방문 배열**: O(N)
* **재귀 스택**: O(N) (최악의 경우)
* **전체 공간 복잡도**: **O(N)**

---

## 핵심 구현 패턴

이 문제에 특화된 DFS 구현:

```java
boolean[] visited = new boolean[N + 1];
int[] permutation = new int[N + 1];
int cycleCount = 0;

// DFS 함수
void dfs(int current) {
    visited[current] = true;
    int next = permutation[current];
    
    if (!visited[next]) {
        dfs(next);
    }
}

// 모든 정점에 대해 DFS 수행
for (int i = 1; i <= N; i++) {
    if (!visited[i]) {
        dfs(i);
        cycleCount++;  // 새로운 사이클 발견
    }
}
```

---

## 다른 DFS 문제와의 차이점

| 특징 | 일반 DFS | 이 문제 (10451) |
|------|---------|----------------|
| 그래프 형태 | 인접 리스트 | 순열 배열 |
| 정점 표현 | 단일 정수 | 1부터 N까지 |
| 간선 탐색 | `graph[current]` 순회 | `permutation[current]` 하나만 |
| 목적 | 경로 찾기, 연결 요소 | 사이클 개수 |
| 방문 체크 | 선택적 | 필수 (사이클 개수 계산) |

---

## 참고

* 전체 DFS 알고리즘 설명: [../dfs.md](../dfs.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

