# Main.java 설계 근거 정리

이 문서는 **BOJ 10451 순열 사이클 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **DFS 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: DFS

### 문제 특성과의 적합성

* **순열을 방향 그래프로 모델링**
* **사이클 찾기**: 각 정점이 정확히 하나의 사이클에 속함
* **연결 요소 개수**: 사이클의 개수 = 연결 요소의 개수
* 입력 크기: N ≤ 1,000

이 문제는 **순열 그래프에서 사이클의 개수를 찾는** 문제입니다.

따라서 다음 조건을 만족하는 알고리즘이 필요합니다:

* 그래프의 모든 정점을 방문
* 사이클을 찾을 수 있어야 함
* O(N) 시간 복잡도
* 구현이 간단하고 직관적

➡️ 이러한 조건을 가장 잘 만족하는 방법이 **DFS (깊이 우선 탐색)** 입니다.

---

## 2️⃣ 코드 구조와 DFS 논의의 1:1 대응

### ① 순열 그래프 초기화

```java
int N = Integer.parseInt(br.readLine());
int[] permutation = new int[N + 1];
boolean[] visited = new boolean[N + 1];
```

* DFS 문서에서 설명한 **그래프 표현**을 사용
* `permutation[]`: 순열 정보 저장 (i → permutation[i])
* `visited[]`: 방문 체크 배열

### ② 순열 입력 처리

```java
StringTokenizer st = new StringTokenizer(br.readLine());
for (int i = 1; i <= N; i++) {
    permutation[i] = Integer.parseInt(st.nextToken());
}
```

* 순열을 배열로 저장
* `permutation[i]`는 정점 i에서 가는 간선의 목적지

### ③ DFS 함수 정의

```java
static void dfs(int current, int[] permutation, boolean[] visited) {
    visited[current] = true;
    int next = permutation[current];
    
    if (!visited[next]) {
        dfs(next, permutation, visited);
    }
}
```

이 코드는 DFS 문서의 **기본 구현**과 **순열 그래프 탐색 패턴**을 결합한 것입니다.

**DFS 문서의 핵심 원칙과의 대응:**

1. **현재 정점 방문**: `visited[current] = true` → 현재 정점 방문 체크
2. **다음 정점 찾기**: `int next = permutation[current]` → 순열 그래프에서 다음 정점
3. **방문 체크**: `!visited[next]` → 방문하지 않은 정점만 처리
4. **재귀 호출**: `dfs(next, ...)` → 다음 정점으로 DFS 진행

### ④ 사이클 개수 계산

```java
int cycleCount = 0;
for (int i = 1; i <= N; i++) {
    if (!visited[i]) {
        dfs(i, permutation, visited);
        cycleCount++;
    }
}
```

* **방문하지 않은 정점에서 DFS 시작**: 새로운 사이클 발견
* **DFS 완료 후 사이클 개수 증가**: 하나의 사이클을 찾았음을 의미

### ⑤ 순열 그래프의 특성 활용

```java
int next = permutation[current];
```

* 순열의 특성상 각 정점은 **정확히 하나의 나가는 간선**을 가짐
* 따라서 `permutation[current]` 하나만 확인하면 됨
* 일반 그래프와 달리 인접 리스트를 순회할 필요가 없음

---

## 3️⃣ DFS의 사이클 찾기 원리

### 왜 DFS가 사이클을 찾을 수 있는가?

* 순열 그래프의 특성:
  * 각 정점은 정확히 하나의 나가는 간선을 가짐
  * 각 정점은 정확히 하나의 들어오는 간선을 가짐
  * 따라서 그래프는 여러 개의 사이클로 구성됨

* DFS 탐색 과정:
  1. 방문하지 않은 정점에서 DFS 시작
  2. 간선을 따라 다음 정점으로 이동
  3. 이미 방문한 정점을 만나면 사이클 완성
  4. 모든 정점이 방문될 때까지 반복

이 문제에서:
* `visited[i]`는 정점 i의 방문 여부를 나타냄
* 방문하지 않은 정점에서 DFS를 시작하면 하나의 사이클을 찾을 수 있음
* DFS를 시작한 횟수가 사이클의 개수

---

## 4️⃣ 순열 그래프 DFS의 특징

### 단일 간선 탐색

```java
int next = permutation[current];
if (!visited[next]) {
    dfs(next, permutation, visited);
}
```

* 일반 그래프와 달리 **하나의 간선만** 확인
* 인접 리스트를 순회할 필요가 없음
* 순열의 특성을 활용한 간단한 구현

### 방문 체크 시점

```java
visited[current] = true;
int next = permutation[current];
```

* DFS 함수 시작 시점에 방문 체크
* 다음 정점으로 이동하기 전에 현재 정점을 방문 처리
* 중복 방문 방지

---

## 5️⃣ 시간 복잡도와 코드의 대응

### 시간 복잡도: O(N)

* **각 정점을 최대 한 번씩 방문**: O(N)
* **각 정점에서 하나의 간선만 확인**: O(1) (상수 시간)
* **전체**: O(N)

코드에서:
* `for (int i = 1; i <= N; i++)`: 최대 N번 반복
* `dfs()` 함수: 각 정점을 최대 한 번씩 방문

---

## 6️⃣ 공간 복잡도와 코드의 대응

### 공간 복잡도: O(N)

* **순열 저장**: `permutation[N + 1]` → O(N)
* **방문 배열**: `visited[N + 1]` → O(N)
* **재귀 스택**: 최악의 경우 O(N)

---

## 7️⃣ 다른 접근 방법과의 비교

### BFS를 사용하지 않은 이유

* **사이클 개수만 필요**: BFS도 가능하지만 DFS가 더 간단
* **재귀 구현의 간결성**: DFS는 재귀로 간단하게 구현 가능
* **메모리 효율**: 이 문제에서는 큰 차이 없지만 DFS가 약간 더 효율적

### Union-Find를 사용하지 않은 이유

* **방향 그래프**: Union-Find는 무방향 그래프에 적합
* **과도한 복잡도**: 이 문제는 DFS로 충분히 해결 가능
* **구현 간결성**: DFS가 더 간단하고 직관적

---

## ✨ 결론

이 문제는 **순열을 방향 그래프로 모델링하여 사이클의 개수를 찾는** 문제로, DFS 알고리즘을 사용하는 것이 가장 적합합니다. 순열의 특성상 각 정점은 정확히 하나의 사이클에 속하므로, 방문하지 않은 정점에서 DFS를 시작할 때마다 하나의 사이클을 찾을 수 있습니다.

