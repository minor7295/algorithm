# Main.java 설계 근거 정리

이 문서는 **BOJ 15651 N과 M (3) 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **백트래킹 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 백트래킹

이 문제는 **중복 순열 생성** 문제로, 백트래킹이 가장 적합합니다.

**핵심 특징:**
* 각 자리마다 독립적으로 1부터 N까지 선택 가능
* 중복 허용으로 방문 체크 불필요
* 모든 경로가 유효한 해이므로 가지치기 불필요
* 사전 순 출력이 자연스럽게 보장됨

> **문제 분석**: [1.analysis.md](./1.analysis.md)의 문제 핵심 해석 섹션을 참고하세요.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 재귀 함수 구조

```java
static void backtrack(int depth) {
    // 종료 조건
    if (depth == M) {
        printResult();
        return;
    }
    
    // 선택지 탐색
    for (int i = 1; i <= N; i++) {
        result[depth] = i;
        backtrack(depth + 1);
    }
}
```

* 알고리즘 문서에서 설명한 **백트래킹 기본 템플릿**과 정확히 일치한다
* `depth == M`: 종료 조건 - M개의 자리를 모두 채웠을 때
* `for (int i = 1; i <= N; i++)`: 각 자리마다 1부터 N까지 모든 수를 선택
* `backtrack(depth + 1)`: 다음 자리로 재귀 호출

➡️ **상태 공간 트리를 깊이 우선으로 탐색**하는 구조가 코드에 그대로 반영되어 있다.

---

### ② 중복 허용의 구현

```java
for (int i = 1; i <= N; i++) {
    result[depth] = i;
    backtrack(depth + 1);
    // 선택 취소 불필요
}
```

* 중복이 허용되므로 방문 체크 불필요
* 각 자리마다 독립적으로 선택 가능
* 선택 취소 단계 불필요

> **자세한 설명**: [2.algorithm.md](./2.algorithm.md)의 중복 허용으로 인한 단순화 섹션을 참고하세요.

---

## 3️⃣ 결과 저장 방식

### 배열 기반 저장

```java
int[] result = new int[M];
```

* 각 자리에 선택한 수를 저장하는 배열 사용
* 인덱스 `depth`에 현재 자리의 값을 저장
* 메모리 효율적이고 접근이 빠름

### 출력 방식

```java
if (depth == M) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < M; i++) {
        sb.append(result[i]);
        if (i < M - 1) sb.append(' ');
    }
    System.out.println(sb.toString());
    return;
}
```

* 완전한 해를 찾았을 때(`depth == M`) 결과를 출력
* `StringBuilder`를 사용하여 출력 최적화
* 공백으로 구분하여 출력

---

## 4️⃣ 재귀 호출의 의미

### 상태 공간 트리 탐색

재귀 호출 `backtrack(depth + 1)`은 다음과 같은 의미를 가진다:

1. **현재 자리에 값을 선택한 상태**에서
2. **다음 자리로 진행**하여
3. **상태 공간 트리의 다음 레벨을 탐색**

### 예시: N=3, M=2인 경우

```
backtrack(0) 호출
  ├─ result[0] = 1
  │   └─ backtrack(1) 호출
  │       ├─ result[1] = 1 → 출력: "1 1"
  │       ├─ result[1] = 2 → 출력: "1 2"
  │       └─ result[1] = 3 → 출력: "1 3"
  ├─ result[0] = 2
  │   └─ backtrack(1) 호출
  │       ├─ result[1] = 1 → 출력: "2 1"
  │       ├─ result[1] = 2 → 출력: "2 2"
  │       └─ result[1] = 3 → 출력: "2 3"
  └─ result[0] = 3
      └─ backtrack(1) 호출
          ├─ result[1] = 1 → 출력: "3 1"
          ├─ result[1] = 2 → 출력: "3 2"
          └─ result[1] = 3 → 출력: "3 3"
```

➡️ 이는 알고리즘 문서에서 설명한 **상태 공간 트리**를 그대로 탐색하는 과정이다.

---

## 5️⃣ 시간/공간 복잡도와 코드의 대응

### 시간 복잡도

* 상태 공간 크기: N^M
* 코드 구조: `for (int i = 1; i <= N; i++)` (N번 반복) × 재귀 깊이 M
* 전체 시간 복잡도: **O(N^M)**

### 공간 복잡도

* 재귀 호출 스택: O(M)
* 결과 저장: O(M)
* 전체 공간 복잡도: **O(M)**

> **자세한 분석**: [2.algorithm.md](./2.algorithm.md)의 시간/공간 복잡도 섹션을 참고하세요.

---

## 7️⃣ 다른 접근 방법과의 비교

### 방법 1: 백트래킹 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 메모리 효율적 (O(M))
* 사전 순 출력이 자연스럽게 보장됨

**단점:**
* 재귀 호출로 인한 스택 오버플로우 가능성 (하지만 M ≤ 7이므로 문제 없음)

### 방법 2: 반복문 중첩

```java
for (int i1 = 1; i1 <= N; i1++) {
    for (int i2 = 1; i2 <= N; i2++) {
        // ... M번 중첩
    }
}
```

**단점:**
* M이 변수이므로 반복문 중첩이 불가능
* 동적 중첩이 필요하므로 결국 재귀와 유사한 구조 필요

### 방법 3: 비트마스크

**단점:**
* 중복 순열에는 적합하지 않음
* 비트마스크는 중복을 허용하지 않는 조합/순열에 적합

➡️ **백트래킹이 이 문제에 가장 적합한 방법이다.**

---

## 8️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **출력 최적화**: StringBuilder 사용

### 추가 최적화 가능성

* 출력 버퍼링: 모든 결과를 메모리에 저장 후 한 번에 출력 (하지만 메모리 사용량 증가)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 9️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **중복 순열 구조**를 백트래킹으로 모델링하고
* 알고리즘 문서에서 설명한 **상태 공간 트리 탐색**을 그대로 구현하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 🔟 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응

