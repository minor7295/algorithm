# Main.java 설계 근거 정리

이 문서는 **BOJ 1987 알파벳 문제**에 대한 최종 해답 코드인 `Main.java`가
앞서 정리한 **백트래킹 개념, 알고리즘 논의와 어떻게 정확히 대응되는지**를 설명한다.

---

## 1️⃣ 알고리즘 선택 근거: 백트래킹

### 문제 특성과의 적합성

* 문제 요구사항
  * 2차원 보드에서 상하좌우로 이동
  * 같은 알파벳을 두 번 지나지 않기
  * 최대한 많은 칸을 지나는 경로 찾기
* 제약 조건
  * `1 ≤ R, C ≤ 20`
  * 알파벳은 26개 (최대 경로 길이는 26)

이 문제는 **2차원 보드에서 백트래킹** 문제로, 다음과 같은 특성이 있다:

* 각 칸에서 **상하좌우 4가지 선택지**
* **알파벳 중복 방지**: 지나온 모든 칸의 알파벳과 달라야 함
* **완전 탐색 필요**: 모든 가능한 경로를 탐색하여 최대 길이를 찾아야 함
* **상태 되돌리기**: 한 경로를 탐색한 후 상태를 되돌려서 다른 경로 탐색 ✅

➡️ 이러한 조건을 가장 직관적으로 만족하는 방법이 **백트래킹**이다.

> **참고**: 백트래킹은 DFS(깊이 우선 탐색)의 한 형태로, 상태를 되돌리는 특수한 형태의 DFS입니다. 자세한 내용은 [백트래킹과 DFS의 관계](../backtracking.md#4️⃣-백트래킹과-dfs의-관계)를 참고하세요.

---

## 2️⃣ 코드 구조와 알고리즘 논의의 1:1 대응

### ① 보드 초기화

```java
int R = Integer.parseInt(st.nextToken());
int C = Integer.parseInt(st.nextToken());
char[][] board = new char[R][C];
boolean[] visited = new boolean[26];  // A-Z: 0-25
```

* 백트래킹 문서에서 설명한 **2차원 보드 탐색**을 사용
* `board[][]`: 보드 정보 저장
* `visited[]`: 방문한 알파벳 체크 (알파벳은 26개이므로 boolean 배열 사용)

### ② 백트래킹 함수 정의

```java
static void backtrack(int r, int c, int count) {
    char current = board[r][c];
    int idx = current - 'A';
    
    // 이미 방문한 알파벳이면 종료 (가지치기)
    if (visited[idx]) {
        return;
    }
    
    // 상태 변경: 방문한 알파벳 체크
    visited[idx] = true;
    maxCount = Math.max(maxCount, count);
    
    // 상하좌우 탐색
    for (int[] dir : directions) {
        int nr = r + dir[0];
        int nc = c + dir[1];
        
        if (isValid(nr, nc)) {
            backtrack(nr, nc, count + 1);
        }
    }
    
    // ✅ 상태 되돌리기: 방문한 알파벳 체크 해제
    visited[idx] = false;
}
```

이 코드는 백트래킹 문서의 **기본 템플릿**과 **상태 되돌리기 패턴**을 그대로 구현한 것입니다.

**백트래킹 문서의 핵심 원칙과의 대응:**

1. **종료 조건**: `if (visited[idx]) return` → 이미 방문한 알파벳이면 종료 (가지치기)
2. **상태 변경**: `visited[idx] = true` → 현재 칸의 알파벳 방문 체크
3. **최대값 갱신**: `maxCount = Math.max(maxCount, count)` → 현재 경로 길이와 비교
4. **선택지 탐색**: `for (int[] dir : directions)` → 상하좌우 네 방향 탐색
5. **재귀 호출**: `backtrack(nr, nc, count + 1)` → 다음 칸으로 백트래킹 진행
6. **상태 되돌리기**: `visited[idx] = false` → ✅ 백트래킹의 핵심! 탐색 후 방문 체크 해제하여 다른 경로 탐색 가능

### ③ 상하좌우 이동

```java
int[] dr = {-1, 1, 0, 0};  // 상, 하, 좌, 우
int[] dc = {0, 0, -1, 1};

for (int i = 0; i < 4; i++) {
    int nr = r + dr[i];
    int nc = c + dc[i];
    
    if (isValid(nr, nc)) {
        backtrack(nr, nc, count + 1);
    }
}
```

* 2차원 보드에서 **상하좌우 네 방향**으로 이동
* `isValid()` 함수로 보드 범위 체크

### ④ 상태 되돌리기 (백트래킹의 핵심)

```java
// 상태 변경: 방문한 알파벳 체크
visited[idx] = true;
// ... 백트래킹 탐색 ...
// ✅ 상태 되돌리기: 방문한 알파벳 체크 해제
visited[idx] = false;
```

* 탐색 전에 방문한 알파벳 체크
* 탐색 후에 방문한 알파벳 체크 해제
* 다른 경로를 탐색할 수 있도록 상태 복원

➡️ 이는 **백트래킹의 핵심 원리**가 코드에 구현된 것이다. 한 경로를 탐색한 후 되돌아와서 다른 경로를 탐색할 수 있도록 상태를 복원한다.

---

## 3️⃣ 재귀 호출의 의미

### 2차원 보드 탐색

재귀 호출 `backtrack(nr, nc, count + 1)`는 다음과 같은 의미를 가진다:

1. **현재 칸에서 인접한 칸으로 이동**하여
2. **다음 칸의 알파벳을 확인**하고
3. **방문하지 않은 알파벳이면 계속 탐색**

### 예시: `board = ["CAAB", "ADCB"]`, 시작 위치 (0, 0)

```
backtrack(0, 0, 1) 호출
  현재: 'C', 방문한 알파벳: {C}, 경로 길이: 1
  ├─ (0, 1) = 'A' → 가능 (A는 방문하지 않음)
  │   방문한 알파벳: {C, A}, 경로 길이: 2
  │   ├─ (0, 2) = 'A' → 불가능 (A는 이미 방문함) ❌
  │   └─ (1, 1) = 'D' → 가능
  │       방문한 알파벳: {C, A, D}, 경로 길이: 3
  │       ├─ (1, 0) = 'A' → 불가능 (A는 이미 방문함) ❌
  │       ├─ (1, 2) = 'C' → 불가능 (C는 이미 방문함) ❌
  │       └─ 더 이상 이동 불가 → 최대 길이: 3
  │       └─ visited['D'] = false (상태 되돌리기) ✅
  │   └─ visited['A'] = false (상태 되돌리기) ✅
  └─ (1, 0) = 'A' → 가능
      방문한 알파벳: {C, A}, 경로 길이: 2
      └─ ... (계속 탐색)
      └─ visited['A'] = false (상태 되돌리기) ✅
  └─ visited['C'] = false (상태 되돌리기) ✅
```

➡️ 이는 알고리즘 문서에서 설명한 **2차원 보드에서의 백트래킹 탐색**을 그대로 수행하는 과정이다.

---

## 4️⃣ 시간 복잡도와 코드의 대응

### 상태 공간 크기

* 각 칸에서 4개의 선택지 (상하좌우)
* 최대 경로 길이: 26 (알파벳은 26개)
* 이론적 경우의 수: 4^26

### 재귀 호출 횟수

* 각 노드에서 4개의 자식 노드 생성
* 깊이 최대 26까지 탐색
* 가지치기(이미 방문한 알파벳)로 인해 실제 탐색하는 노드 수는 훨씬 적음

### 코드에서의 대응

```java
// 이미 방문한 알파벳이면 종료 (가지치기)
if (visited[idx]) {
    return;
}

// 상하좌우 탐색
for (int i = 0; i < 4; i++) {
    int nr = r + dr[i];
    int nc = c + dc[i];
    
    if (isValid(nr, nc)) {
        backtrack(nr, nc, count + 1);
    }
}
```

* 각 재귀 호출마다 4개의 선택지 탐색
* 재귀 깊이: 최대 26
* 가지치기를 통해 이미 방문한 알파벳은 조기 종료
* 전체 시간 복잡도: **O(4^L)** (L은 최대 경로 길이, 실제로는 가지치기로 훨씬 적음)

---

## 5️⃣ 공간 복잡도 분석

### 보드 저장

* `board[R][C]`: O(R×C)
* `visited[26]`: O(1) (알파벳은 26개로 고정)

### 재귀 호출 스택

* 최대 재귀 깊이: 26 (최대 경로 길이)
* 각 재귀 호출마다 스택 프레임 생성
* 스택 공간: **O(26) = O(1)**

### 전체 공간 복잡도

* **O(R×C)** - 보드 크기가 공간 복잡도를 결정

---

## 6️⃣ 다른 접근 방법과의 비교

### 방법 1: 백트래킹 (현재 방법) ✅

**장점:**
* 구현이 간단하고 직관적
* 메모리 효율적 (O(R×C))
* 코드가 간결하고 이해하기 쉬움
* 상태 되돌리기로 모든 가능한 경로 탐색 보장

**단점:**
* 재귀 호출로 인한 스택 오버플로우 가능성 (하지만 최대 깊이 26이므로 문제 없음)

### 방법 2: BFS

**단점:**
* 최대 경로 길이를 찾기 위해서는 모든 경로를 탐색해야 함
* BFS는 레벨별로 탐색하므로 최대 경로를 찾기 어려움
* 상태 공간이 큼 (각 노드가 (r, c, visited 알파벳 집합)을 저장해야 함)

### 방법 3: 동적 프로그래밍 (DP)

**단점:**
* 상태가 (r, c, visited 알파벳 집합)이므로 상태 공간이 너무 큼 (2^26)
* 메모이제이션 테이블이 너무 커서 비효율적
* 이 문제에서는 백트래킹이 더 적합

➡️ **백트래킹이 이 문제에 가장 적합한 방법이다.**

---

## 7️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **메모리 효율적**: 필요한 공간만 사용
* **상태 되돌리기**: 모든 가능한 경로를 탐색하여 최대 길이 보장

### 추가 최적화 가능성

* **비트마스크**: 알파벳 집합을 비트로 표현 (26비트)
  * 하지만 boolean 배열이 더 직관적이고 충분히 빠름
* **가지치기**: 현재 경로 길이 + 남은 가능한 알파벳 수가 현재 최대값보다 작으면 조기 종료
  * 하지만 구현이 복잡하고, R, C ≤ 20이므로 큰 효과가 없을 수 있음

---

## 8️⃣ 핵심 설계 원칙

1. **단순성**: 복잡한 최적화 없이 알고리즘의 핵심만 구현
2. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
3. **효율성**: 문제 제약 조건 내에서 충분히 효율적
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응

---

## 9️⃣ 백트래킹 문서와의 대응

이 코드는 [백트래킹 문서](../backtracking.md)의 다음 섹션들과 정확히 대응합니다:

* **기본 템플릿**: [5️⃣ 알고리즘 구조](../backtracking.md#5️⃣-알고리즘-구조)
* **상태 되돌리기**: [3️⃣ 핵심 개념](../backtracking.md#3️⃣-핵심-개념)
* **구현 패턴**: [8️⃣ 구현 패턴](../backtracking.md#8️⃣-구현-패턴) - 패턴 2: 명시적 상태 되돌리기

특히 **상태 되돌리기**가 이 문제의 핵심이며, 백트래킹의 가장 중요한 특징입니다.

