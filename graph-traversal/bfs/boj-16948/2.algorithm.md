# 알고리즘: BFS (너비 우선 탐색)

> 전체 BFS 개념은 [../bfs.md](../bfs.md)를 참고합니다.

## 1. 좌표 이동의 표현

데스 나이트의 6가지 이동을 `DR`, `DC` 배열로 표현하고, 반복문으로 다음 좌표를 생성합니다.

```java
int[] DR = {-2, -2, 0, 0, 2, 2};
int[] DC = {-1, 1, -2, 2, -1, 1};

for (int i = 0; i < 6; i++) {
    int nr = r + DR[i];
    int nc = c + DC[i];
}
```

## 2. BFS 적용

`dist` 배열은 두 역할을 함께 수행합니다.
- `dist[r][c] == -1`: 아직 방문하지 않은 좌표
- `dist[r][c] >= 0`: 방문한 좌표이며, 시작점에서 해당 좌표까지의 최소 이동 횟수

여기서 `sr`, `sc`는 시작 좌표의 행(row), 열(column)입니다. 시작점은 이동 횟수 0에서 출발하므로 `dist[sr][sc] = 0`으로 둡니다.

또한 `dist`는 초기에 전부 `-1`로 채워져 있어야 위 방문 규칙이 성립합니다. 이후 BFS를 진행하면서
- 큐에서 현재 좌표를 꺼내고
- 6방향 이웃 중 유효한 좌표를 검사한 뒤
- 미방문 이웃만 거리(`현재 거리 + 1`)를 기록하고 큐에 넣습니다.

핵심은 "큐에 넣는 시점에 거리 기록을 함께 수행"한다는 점입니다. 이렇게 해야 같은 좌표가 중복으로 큐에 들어가는 것을 막을 수 있습니다.

```java
Queue<int[]> q = new ArrayDeque<>();
q.offer(new int[]{sr, sc});
dist[sr][sc] = 0;

while (!q.isEmpty()) {
    int[] cur = q.poll();
    int r = cur[0], c = cur[1];

    // ... 6방향 이웃 (nr, nc) 생성 ...
    // ... 경계 조건을 통과한 경우만 처리 ...
    if (dist[nr][nc] != -1) continue;      // 이미 방문한 좌표
    dist[nr][nc] = dist[r][c] + 1;         // 방문 + 최소 이동 횟수 기록
    q.offer(new int[]{nr, nc});            // 다음 레벨 탐색 대상으로 추가
}
```

### 경계 조건 판단

생성한 다음 좌표가 체스판 범위를 벗어나면 제외합니다.

```java
if (nr < 0 || nr >= n || nc < 0 || nc >= n) continue;
```

## 3. 최소 이동 횟수와 도달 불가 판정

여기서 `tr`, `tc`는 각각 목표 좌표의 행(row), 열(column)입니다. 도착점을 처음 만난 시점의 `dist`가 최소 이동 횟수이며, 끝까지 못 찾으면 `-1`입니다.

```java
while (!q.isEmpty()) {
    int[] cur = q.poll();
    int r = cur[0], c = cur[1];

    if (r == tr && c == tc) return dist[r][c];

    // ... 6방향 탐색 및 큐 확장 ...
}

return -1;
```
