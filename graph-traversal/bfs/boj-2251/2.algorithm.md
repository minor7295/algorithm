# 알고리즘: 상태공간 탐색 (BFS/DFS)

## 1. BFS 적용

이 문제에서는 BFS를 적용해 시작 상태 `(0, 0, C)`에서 도달 가능한 상태를 순차적으로 탐색합니다. 문제의 목표가 최적값 하나를 찾는 것이 아니라 가능한 결과 집합을 빠짐없이 수집하는 것이기 때문에, 방문 배열을 두고 도달 가능한 상태를 전부 순회하는 방식이 적합합니다.

탐색 흐름은 일반적인 BFS와 동일합니다. 초기 상태를 큐에 넣고, 상태를 하나씩 꺼내며 다음 상태를 큐에 추가합니다. 이때 A 물통이 비어 있는 상태(`a == 0`)를 만나면 C 물통의 양을 정답에 기록합니다.

```java
Queue<int[]> q = new ArrayDeque<>();
q.offer(new int[]{0, 0}); // 시작 상태 (a=0, b=0)

while (!q.isEmpty()) {
    int[] cur = q.poll();
    int a = cur[0], b = cur[1];
    int c = C - a - b;

    if (a == 0) possible[c] = true;
    // 현재 상태에서 갈 수 있는 다음 상태들을 생성해 큐에 추가
}
```

---

## 2. 상태와 전이의 설계

이전 BFS 문제(격자 최단거리 등)는 정점과 간선이 입력으로 주어지거나, 인접 규칙이 고정된 경우가 많았습니다. 반면 이 문제는 그래프가 직접 주어지지 않아 상태와 전이를 직접 설계해야 합니다. 핵심은 "상태를 무엇으로 저장할지"와 "전이를 어떻게 만들지"입니다.

먼저 상태는 `(a,b,c)`를 그대로 저장할 수도 있지만, 총 물의 양이 항상 `C`로 보존되므로 `c = C - a - b`로 복원할 수 있습니다. 그래서 방문 배열을 2차원으로 축소해 `visited[a][b]`로 관리할 수 있습니다. 이때 첫 번째 인덱스는 A 물통의 현재 물의 양, 두 번째 인덱스는 B 물통의 현재 물의 양을 의미합니다.

```java
boolean[][] visited = new boolean[A + 1][B + 1];

// 의미: A통에 a리터, B통에 b리터가 담긴 상태 방문 여부
if (!visited[a][b]) visited[a][b] = true;
```

다음으로 간선은 고정된 인접 목록이 아니라, 현재 상태에서 가능한 붓기 연산 6가지를 동적으로 생성해 만듭니다. 이 부분을 `pour(...)` 함수로 분리하면 BFS 본문이 "탐색"에 집중되고, 상태 전이 계산은 별도 로직으로 관리할 수 있습니다.

```java
int[] next = pour(a, b, c, from, to, A, B, C); // from -> to 한 번 붓기 결과
int na = next[0], nb = next[1];
```

`pour(...)` 내부에서는 이동량을 다음처럼 계산합니다. 이 계산이 문제의 "한 물통이 빌 때 또는 다른 물통이 찰 때까지" 조건을 그대로 반영합니다.

```java
int move = Math.min(amount[from], limit[to] - amount[to]);
```

즉, 이 문제의 핵심 차이는 BFS 자체가 아니라 상태 설계와 전이 생성 방식에 있습니다. 이 두 부분을 정확히 구현하면 탐색 구조는 일반적인 BFS와 동일하게 동작합니다.

---

## 3. 복잡도

2차원 상태공간 기준으로 다음과 같이 계산할 수 있습니다.

- 상태 수: `(A + 1) * (B + 1)`
- 상태당 전이: 최대 6개
- 시간 복잡도: `O(A * B)`
- 공간 복잡도: `O(A * B)`

제약 `A, B, C <= 200`에서 최대 상태 수는 `201 * 201 = 40401`이므로 완전탐색이 충분히 안전합니다.
