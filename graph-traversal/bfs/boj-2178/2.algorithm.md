# 알고리즘: BFS (너비 우선 탐색)

> 📖 **전체 알고리즘 설명**: [BFS (너비 우선 탐색) 정리](../bfs.md)

이 문제는 **BFS (Breadth-First Search, 너비 우선 탐색)** 알고리즘을 사용하여 해결합니다.  
상위 폴더의 [BFS 정리 문서](../bfs.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 BFS 적용

### 문제 특성

* **2차원 격자 탐색**: 미로를 2차원 배열로 표현
* **가중치 없는 그래프**: 모든 이동의 비용이 동일 (1칸)
* **최단 경로**: 시작점에서 도착점까지의 최소 칸 수
* **입력 크기**: N, M ≤ 100 (작은 크기)

---

## 이 문제의 특이사항

### 1️⃣ 2차원 격자 BFS 패턴

이 문제는 **2차원 격자에서의 BFS**를 사용합니다.

**특징:**
* 각 칸을 정점으로, 상하좌우 이동을 간선으로 표현
* `dx[]`, `dy[]` 배열을 사용하여 4방향 이동 처리
* 2차원 방문 배열 `visited[][]` 사용
* 2차원 거리 배열 `distance[][]` 사용

### 2️⃣ 그래프 모델링

* **칸 → 정점(Vertex)**: 각 칸 `(x, y)`를 하나의 정점으로 표현
* **인접 칸 → 간선(Edge)**: 상하좌우로 이동 가능한 칸들 간의 간선
* **가중치**: 모든 간선의 가중치는 1 (한 칸 이동)

### 3️⃣ 거리 계산

* 시작점 `(0, 0)`의 거리를 1로 초기화 (시작 위치 포함)
* 각 칸에 도달할 때마다 이전 칸의 거리 + 1로 업데이트
* 도착점 `(N-1, M-1)`에 도달하면 즉시 거리 반환

### 4️⃣ 시간 복잡도

* **그래프 구성**: O(N × M) (미로 입력 읽기)
* **BFS 수행**: O(N × M) (모든 칸을 최대 한 번씩 방문)
* **전체 시간 복잡도**: **O(N × M)**

입력 크기가 작으므로(N, M ≤ 100) 충분히 빠르게 동작합니다.

### 5️⃣ 공간 복잡도

* **미로 저장**: O(N × M)
* **방문 배열**: O(N × M)
* **거리 배열**: O(N × M)
* **큐**: O(N × M) (최악의 경우)
* **전체 공간 복잡도**: **O(N × M)**

---

## 핵심 구현 패턴

이 문제에 특화된 2차원 격자 BFS 구현:

```java
// 4방향 이동을 위한 배열
// 좌표계 기준: x는 가로(왼쪽→오른쪽), y는 세로(아래→위)
// 
// dx[i]: i번째 방향의 x(가로) 변화량
// dy[i]: i번째 방향의 y(세로) 변화량
// 
// 방향별 변화량:
// 인덱스 0: 상 → y가 늘어남 (dx=0, dy=1)   [위로 이동]
// 인덱스 1: 하 → y가 줄어듦 (dx=0, dy=-1)  [아래로 이동]
// 인덱스 2: 좌 → x가 줄어듦 (dx=-1, dy=0)  [왼쪽으로 이동]
// 인덱스 3: 우 → x가 늘어남 (dx=1, dy=0)   [오른쪽으로 이동]
int[] dx = {0, 0, -1, 1};  // 상, 하, 좌, 우의 x(가로) 변화량
int[] dy = {1, -1, 0, 0};  // 상, 하, 좌, 우의 y(세로) 변화량

Queue<int[]> queue = new ArrayDeque<>();
boolean[][] visited = new boolean[N][M];
int[][] distance = new int[N][M];

// 시작점 처리
queue.offer(new int[]{0, 0});
visited[0][0] = true;
distance[0][0] = 1;

while (!queue.isEmpty()) {
    int[] current = queue.poll();
    int y = current[0];  // y는 세로 (행)
    int x = current[1];  // x는 가로 (열)
    
    // 도착점 확인
    // 주의: 배열은 map[y][x] 형태 (y가 행, x가 열)
    if (y == N - 1 && x == M - 1) {
        return distance[y][x];
    }
    
    // 4방향 탐색
    // i=0: 상, i=1: 하, i=2: 좌, i=3: 우
    for (int i = 0; i < 4; i++) {
        int ny = y + dy[i];  // y(세로) 변화
        int nx = x + dx[i];  // x(가로) 변화
        
        // 범위 체크, 방문 체크, 이동 가능 체크
        // 주의: 배열 인덱스는 [y][x] 순서
        if (ny >= 0 && ny < N && nx >= 0 && nx < M 
            && !visited[ny][nx] && map[ny][nx] == 1) {
            visited[ny][nx] = true;
            distance[ny][nx] = distance[y][x] + 1;
            queue.offer(new int[]{ny, nx});
        }
    }
}
```

---

## 다른 BFS 문제와의 차이점

| 특징 | 일반 BFS | 이 문제 (2178) |
|------|---------|---------------|
| 그래프 형태 | 1차원 인접 리스트 | 2차원 격자 |
| 정점 표현 | 단일 정수 | (x, y) 좌표 쌍 |
| 간선 탐색 | `graph[current]` 순회 | `dx[]`, `dy[]` 배열 사용 |
| 거리 계산 | 필요 시에만 | 항상 계산 (최단 경로) |
| 도착점 확인 | 선택적 | 필수 (도착 시 즉시 반환) |

---

## 참고

* 전체 BFS 알고리즘 설명: [../bfs.md](../bfs.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)

