# 미로 탐색

## 📌 문제 요약

N×M 크기의 미로에서 (1, 1)에서 출발하여 (N, M)까지 이동할 때 지나야 하는 **최소 칸 수**를 구하는 문제입니다.

미로에서 1은 이동할 수 있는 칸, 0은 이동할 수 없는 칸을 나타냅니다. 한 칸에서 다른 칸으로 이동할 때는 **서로 인접한 칸(상하좌우)**으로만 이동할 수 있습니다.

---

## 🔍 문제 설명

* 미로는 **N×M 크기의 2차원 배열**로 표현됨
* 각 칸은 `1`(이동 가능) 또는 `0`(이동 불가)으로 표시됨
* 시작 위치: `(1, 1)` (문제 설명 기준, 1-based 인덱스)
* 도착 위치: `(N, M)` (문제 설명 기준, 1-based 인덱스)
* 이동 방향: 상하좌우 4방향만 가능
* **최소 칸 수**를 구해야 함 (시작 위치와 도착 위치 포함)

> **인덱스 설명**:
> * **1-based 인덱스**: 인덱스가 1부터 시작 (문제 설명에서 사용)
>   * 예: 첫 번째 칸이 (1, 1), 두 번째 칸이 (1, 2)
> * **0-based 인덱스**: 인덱스가 0부터 시작 (실제 코드 구현에서 사용)
>   * 예: 첫 번째 칸이 (0, 0), 두 번째 칸이 (0, 1)
> * 문제에서는 (1, 1)에서 (N, M)까지라고 하지만, 실제 코드에서는 배열 인덱스가 0부터 시작하므로 `(0, 0)`에서 `(N-1, M-1)`까지 탐색합니다.

---

## 📥 입력 조건

* 첫째 줄에 두 정수 `N`, `M` (2 ≤ N, M ≤ 100)
* 다음 N개의 줄에는 M개의 정수로 미로가 주어짐
* 각각의 수들은 **붙어서** 입력으로 주어짐 (공백 없음)
* 항상 도착 위치로 이동할 수 있는 경우만 입력으로 주어짐

---

## 📤 출력 조건

* 첫째 줄에 지나야 하는 **최소의 칸 수**를 출력
* 시작 위치와 도착 위치도 포함하여 계산

---

## 💡 문제 핵심 해석

* 2차원 격자를 **그래프**로 모델링 가능
* 각 칸을 **정점(Vertex)**, 인접한 칸으로의 이동을 **간선(Edge)**로 표현
* 상하좌우로만 이동 가능하므로 **가중치가 없는 그래프**
* 시작점에서 도착점까지의 **최단 경로**를 찾는 문제

➡️ **가중치 없는 그래프에서의 최단 경로 문제**이므로 **BFS** 알고리즘을 사용

---

## 🧠 해결 전략 개요

* **BFS (너비 우선 탐색)** 사용
* 시작점에서 도착점까지의 **최단 거리**를 BFS로 계산
* 각 칸까지의 거리를 저장하면서 탐색
* 도착점에 도달하면 즉시 거리 반환

---

## ✨ 예시

### 예시 1: 문제에서 제공한 예시

**입력**
```
4 6
101111
101010
101011
111011
```

**미로 구조** (1-based 인덱스)
```
(1,1) (1,2) (1,3) (1,4) (1,5) (1,6)
  1     0     1     1     1     1
(2,1) (2,2) (2,3) (2,4) (2,5) (2,6)
  1     0     1     0     1     0
(3,1) (3,2) (3,3) (3,4) (3,5) (3,6)
  1     0     1     0     1     1
(4,1) (4,2) (4,3) (4,4) (4,5) (4,6)
  1     1     1     0     1     1
```

**출력**
```
15
```

**설명**: (1,1)에서 (4,6)까지 최소 15칸을 지나야 도달할 수 있습니다.

**최단 경로 예시** (경로를 `*`로 표시)
```
* 0 * * * *
* 0 * 0 * 0
* 0 * 0 * *
* * * 0 * *
```

**경로 설명**:
- 시작: (1,1) → 아래로 이동
- (2,1) → 아래로 이동  
- (3,1) → 아래로 이동
- (4,1) → 오른쪽으로 이동
- (4,2) → 오른쪽으로 이동
- (4,3) → 위로 이동
- (3,3) → 위로 이동
- (2,3) → 위로 이동
- (1,3) → 오른쪽으로 이동
- (1,4) → 오른쪽으로 이동
- (1,5) → 아래로 이동
- (2,5) → 아래로 이동
- (3,5) → 오른쪽으로 이동
- (3,6) → 아래로 이동
- 도착: (4,6)

총 15칸을 지나게 됩니다.

---

### 예시 2: 간단한 케이스

**입력**
```
2 2
11
11
```

**출력**
```
3
```

**설명**: (1,1) → (1,2) → (2,2) 또는 (1,1) → (2,1) → (2,2)로 3칸 이동

---

### 예시 3: 직선 경로

**입력**
```
3 3
111
001
111
```

**출력**
```
5
```

**설명**: (1,1) → (1,2) → (1,3) → (2,3) → (3,3)로 5칸 이동

---

## 📝 정리

이 문제는 **2차원 격자에서의 최단 경로 찾기** 문제로, 가중치가 없는 그래프에서 BFS를 사용하여 효율적으로 해결할 수 있습니다. BFS는 가중치 없는 그래프에서 시작점으로부터의 최단 거리를 보장하므로, 이 문제에 적합한 알고리즘입니다.

