# 알고리즘: 다익스트라 알고리즘 (Dijkstra's Algorithm)

> 📖 **전체 알고리즘 설명**: [다익스트라 알고리즘 정리](../dijkstra.md)

이 문제는 **다익스트라 알고리즘**을 사용하여 해결합니다.  
상위 폴더의 [다익스트라 알고리즘 정리 문서](../dijkstra.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

---

## 이 문제에서의 다익스트라 적용

### 문제 특성

* **가중치 있는 방향 그래프**: 각 버스는 출발 도시에서 도착 도시로 가는 방향성 있는 간선
* **가중치**: 각 버스의 비용 (0 이상 100,000 미만)
* **최단 경로**: 시작 도시에서 목표 도시까지의 최소 비용
* **입력 크기**: N ≤ 1,000, M ≤ 100,000

### 이 문제의 특이사항

#### 1️⃣ 방향 그래프

* 도시 A에서 도시 B로 가는 버스가 있어도, 도시 B에서 도시 A로 가는 버스가 없을 수 있음
* 간선을 추가할 때 한 방향으로만 추가

#### 2️⃣ 목표 정점까지의 최단 거리

* 목표 도시에 도달하면 즉시 거리 반환 (조기 종료)
* 불필요한 탐색을 줄여 성능 향상

#### 3️⃣ 시간/공간 복잡도

* **시간 복잡도**: O((N + M) log N)
  * 그래프 구성: O(M)
  * 다익스트라 수행: O((N + M) log N)
* **공간 복잡도**: O(N + M)
  * 그래프 저장: O(N + M)
  * 거리 배열: O(N)
  * 우선순위 큐: O(N)

---

## 핵심 구현 코드

```java
import java.util.*;

class Edge {
    int to, weight;
    Edge(int to, int weight) {
        this.to = to;
        this.weight = weight;
    }
}

int dijkstra(int start, int end, List<Edge>[] graph, int N) {
    // 거리 배열 초기화
    int[] dist = new int[N + 1];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[start] = 0;
    
    // 우선순위 큐: (거리, 도시) 쌍을 거리 순으로 정렬
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
    pq.offer(new int[]{0, start});
    
    boolean[] visited = new boolean[N + 1];
    
    while (!pq.isEmpty()) {
        int[] current = pq.poll();
        int distance = current[0];
        int city = current[1];
        
        // 목표 도시 도달 시 즉시 반환
        if (city == end) {
            return distance;
        }
        
        if (visited[city]) continue;
        visited[city] = true;
        
        // 현재 도시에서 출발하는 모든 버스 확인
        for (Edge edge : graph[city]) {
            int next = edge.to;
            int cost = edge.weight;
            
            if (dist[next] > distance + cost) {
                dist[next] = distance + cost;
                pq.offer(new int[]{dist[next], next});
            }
        }
    }
    
    return dist[end];
}
```

### 그래프 구성

```java
// 그래프 초기화
List<Edge>[] graph = new ArrayList[N + 1];
for (int i = 1; i <= N; i++) {
    graph[i] = new ArrayList<>();
}

// 버스 정보 입력 (방향 그래프)
for (int i = 0; i < M; i++) {
    int from = Integer.parseInt(st.nextToken());
    int to = Integer.parseInt(st.nextToken());
    int cost = Integer.parseInt(st.nextToken());
    
    graph[from].add(new Edge(to, cost));
}
```

---

## 최적화 기법

### 1. 목표 도시 도달 시 조기 종료

```java
if (city == end) {
    return distance;
}
```

* 목표 도시에 도달하면 즉시 반환
* 불필요한 탐색을 줄여 성능 향상

### 2. 방문 체크로 중복 처리 방지

```java
if (visited[city]) continue;
visited[city] = true;
```

* 같은 도시가 여러 번 큐에 들어갈 수 있으므로 방문 체크 필수

---

## 다른 알고리즘과의 비교

| 특징 | BFS | 다익스트라 | 이 문제 (1916) |
|------|-----|-----------|---------------|
| 그래프 형태 | 가중치 없는 그래프 | 가중치 있는 그래프 | 가중치 있는 방향 그래프 |
| 가중치 | 모든 간선이 1 | 간선마다 다름 | 버스 비용 (0 이상) |
| 자료구조 | 큐 | 우선순위 큐 | 우선순위 큐 |
| 시간 복잡도 | O(V + E) | O((V + E) log V) | O((N + M) log N) |

**다익스트라를 사용하는 이유:**
* 버스 비용이 다르므로 가중치가 있는 그래프
* 음수 가중치가 없으므로 다익스트라 사용 가능
* 단일 시작점에서 단일 목표점까지의 최단 거리

---

## 참고

* 전체 다익스트라 알고리즘 설명: [../dijkstra.md](../dijkstra.md)
* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 적용 근거: [3.reasoning.md](./3.reasoning.md)
