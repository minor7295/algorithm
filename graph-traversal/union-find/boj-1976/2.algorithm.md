# 알고리즘: Union-Find (Disjoint Set Union)

> 📖 **전체 알고리즘 설명**: [Union-Find (Disjoint Set Union) 정리](../union-find.md)

이 문제는 **Union-Find (Disjoint Set Union)** 알고리즘을 사용하여 해결합니다.

---

## 이 문제에서의 Union-Find 적용

### 적용 방법

1. **인접 행렬 읽기**: 모든 도시 쌍의 연결 정보를 읽으면서
2. **Union 연산**: 연결된 두 도시를 같은 그룹으로 묶기
3. **Find 연산**: 여행 계획의 연속된 두 도시가 같은 그룹인지 확인

### 핵심 구현 패턴

```java
// 1. Union-Find 초기화
int[] parent = new int[N + 1];
for (int i = 1; i <= N; i++) {
    parent[i] = i;
}

// 2. 인접 행렬을 읽으면서 연결된 도시들을 Union
for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= N; j++) {
        if (adjMatrix[i][j] == 1) {
            union(i, j, parent);
        }
    }
}

// 3. 여행 계획 확인
for (int i = 0; i < M - 1; i++) {
    if (find(plan[i], parent) != find(plan[i + 1], parent)) {
        return false;  // 다른 그룹이면 여행 불가능
    }
}
```

---

## 일반적인 Union-Find 사용과의 차이점

### 일반적인 사용 패턴

일반적으로 Union-Find는:
- **간선 리스트**를 받아서 각 간선에 대해 Union 연산 수행
- 동적으로 간선이 추가되거나 제거되는 경우 처리

### 이 문제의 특이점

1. **인접 행렬 입력**: 간선 리스트가 아닌 인접 행렬로 주어짐
   - 모든 도시 쌍을 확인해야 함 (O(N²))
   - 대칭 행렬이므로 중복 처리 가능하지만, Union 연산이 중복 호출되어도 결과는 동일

2. **모든 연결 정보를 미리 처리**: 
   - 입력 단계에서 모든 연결을 Union으로 처리
   - 이후에는 Find 연산만으로 연결 여부 확인

3. **여행 계획의 연속된 도시 확인**:
   - 전체 경로가 아닌 연속된 두 도시씩만 확인
   - 하나라도 다른 그룹이면 즉시 종료 가능

### 구현 차이

```java
// 일반적인 Union-Find: 간선 리스트 처리
for (Edge edge : edges) {
    union(edge.u, edge.v);
}

// 이 문제: 인접 행렬 처리
for (int i = 1; i <= N; i++) {
    for (int j = 1; j <= N; j++) {
        if (adjMatrix[i][j] == 1) {
            union(i, j, parent);
        }
    }
}
```

---

## 시간 복잡도

* **인접 행렬 읽기**: O(N²)
* **Union-Find 연산**: O(N² × α(N)) ≈ O(N²) (α는 역 아커만 함수, 실질적으로 상수)
* **여행 계획 확인**: O(M)
* **전체 시간 복잡도**: **O(N²)**

입력 크기가 작으므로(N ≤ 200) 충분히 빠르게 동작합니다.

---

## 공간 복잡도

* **Union-Find 배열**: O(N)
* **여행 계획 저장**: O(M)
* **전체 공간 복잡도**: **O(N + M)**

인접 행렬을 저장하지 않고 읽기만 하면 O(1) 추가 공간만 필요합니다.

---

## 참고

* 문제 분석: [1.analysis.md](./1.analysis.md)
* 알고리즘 선택 근거: [3.reasoning.md](./3.reasoning.md)
