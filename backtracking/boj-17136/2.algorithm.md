# 알고리즘: 백트래킹

> 📖 **전체 알고리즘 설명**: [백트래킹(Backtracking) 정리](../backtracking.md)

이 문제는 **백트래킹(Backtracking)** 알고리즘을 사용하여 해결합니다.  
상위 폴더의 [백트래킹 정리 문서](../backtracking.md)에서 알고리즘의 전체 이론과 개념을 확인할 수 있습니다.

> **참고**: 백트래킹은 DFS(깊이 우선 탐색)의 한 형태로, 상태를 되돌리는 특수한 형태의 DFS입니다. 자세한 내용은 [백트래킹과 DFS의 관계](../backtracking.md#4️⃣-백트래킹과-dfs의-관계)를 참고하세요.

---

## 이 문제에서의 백트래킹 적용

### 문제 특성

* **2차원 보드 탐색**: 10×10 보드에서 1이 적힌 칸을 찾아 색종이로 덮기
* **제한된 자원**: 각 크기의 색종이가 최대 5개씩만 사용 가능
* **최소 개수 찾기**: 모든 1을 덮는데 필요한 색종이의 최소 개수
* **상태 되돌리기**: 색종이를 놓은 후 되돌려서 다른 경우 탐색 ✅
* **제약 조건**: 보드 크기 10×10, 색종이 크기 1~5, 각 5개씩

---

## 이 문제의 특이사항

### 1️⃣ 왼쪽 위부터 첫 번째 1 찾기

일반적인 백트래킹 문제와 달리, 이 문제는 **왼쪽 위부터 오른쪽 아래로 순회하여 첫 번째 덮이지 않은 1을 찾는** 전략을 사용합니다.

**이유:**
- 첫 번째 1은 반드시 덮어야 합니다 (덮지 않으면 불가능)
- 모든 위치를 순회할 필요 없이, 첫 번째 1만 찾으면 됩니다
- 이렇게 하면 탐색 공간을 크게 줄일 수 있습니다

**구현:**
```java
// 왼쪽 위부터 오른쪽 아래로 순회
for (int r = 0; r < 10; r++) {
    for (int c = 0; c < 10; c++) {
        if (board[r][c] == 1) {
            // 첫 번째 1을 찾음
            // 이 위치를 반드시 덮어야 함
            return (r, c);
        }
    }
}
```

### 2️⃣ 큰 종이부터 시도하는 전략

일반적인 백트래킹에서는 모든 선택지를 동등하게 고려하지만, 이 문제는 **큰 종이(5×5)부터 작은 종이(1×1)까지 순서대로 시도**합니다.

**이유:**
- 큰 종이를 먼저 사용하면 전체적으로 종이 개수를 줄일 가능성이 높습니다
- 가지치기 효과: 큰 종이를 먼저 시도하면 더 빨리 최적해에 도달할 수 있습니다
- 하지만 이것이 항상 최적은 아니므로, 백트래킹으로 모든 경우를 탐색해야 합니다

**구현:**
```java
// 큰 종이부터 작은 종이까지 순서대로 시도
for (int size = 5; size >= 1; size--) {
    if (papers[size] > 0 && canPlace(r, c, size)) {
        // 종이 놓기
        placePaper(r, c, size);
        papers[size]--;
        
        // 재귀 호출
        backtrack(count + 1);
        
        // 상태 되돌리기
        removePaper(r, c, size);
        papers[size]++;
    }
}
```

### 3️⃣ 상태 되돌리기 (백트래킹의 핵심)

이 문제는 **보드 상태와 색종이 개수를 되돌려야** 합니다.

**특징:**
- 보드 상태: 색종이를 놓은 위치의 1을 0으로 변경
- 색종이 개수: 사용한 색종이의 개수를 감소/증가
- 재귀 호출 후 반드시 상태를 복원해야 다른 경로 탐색 가능

**구현:**
```java
// 상태 변경: 종이 놓기
placePaper(r, c, size);  // 보드 업데이트
papers[size]--;          // 색종이 개수 감소

// 재귀 호출
backtrack(count + 1);

// ✅ 상태 되돌리기: 종이 제거
removePaper(r, c, size);  // 보드 복원
papers[size]++;           // 색종이 개수 복원
```

### 4️⃣ 가지치기 (Pruning)

이 문제는 **가지치기를 통해 불필요한 탐색을 줄입니다**.

**가지치기 조건:**

1. **현재 사용한 개수 >= 최소값**
   ```java
   if (count >= minCount) {
       return;  // 더 이상 탐색할 필요 없음
   }
   ```

2. **더 이상 덮을 수 없는 경우**
   - 첫 번째 1을 찾았지만, 사용 가능한 색종이로 덮을 수 없는 경우
   - 이 경우는 불가능한 경우이므로 조기 종료

### 5️⃣ 종료 조건

**성공 조건:**
- 모든 1이 덮였는지 확인
- 최소값 갱신

**실패 조건:**
- 첫 번째 1을 찾았지만 덮을 수 없는 경우
- 더 이상 덮을 수 없는 경우

---

## 핵심 구현 패턴

### 기본 구조

```java
static int minCount = Integer.MAX_VALUE;
static int[] papers = {0, 5, 5, 5, 5, 5};  // 크기별 색종이 개수
static int[][] board = new int[10][10];

static void backtrack(int count) {
    // 가지치기: 현재 개수가 최소값보다 크면 종료
    if (count >= minCount) {
        return;
    }
    
    // 첫 번째 덮이지 않은 1 찾기
    int[] pos = findFirstOne();
    if (pos == null) {
        // 모든 1이 덮임
        minCount = Math.min(minCount, count);
        return;
    }
    
    int r = pos[0], c = pos[1];
    
    // 큰 종이부터 작은 종이까지 순서대로 시도
    for (int size = 5; size >= 1; size--) {
        if (papers[size] > 0 && canPlace(r, c, size)) {
            // 상태 변경: 종이 놓기
            placePaper(r, c, size);
            papers[size]--;
            
            // 재귀 호출
            backtrack(count + 1);
            
            // ✅ 상태 되돌리기: 종이 제거
            removePaper(r, c, size);
            papers[size]++;
        }
    }
}
```

### 보조 함수들

**1. 첫 번째 1 찾기**
```java
static int[] findFirstOne() {
    for (int r = 0; r < 10; r++) {
        for (int c = 0; c < 10; c++) {
            if (board[r][c] == 1) {
                return new int[]{r, c};
            }
        }
    }
    return null;  // 모든 1이 덮임
}
```

**2. 종이를 놓을 수 있는지 확인**
```java
static boolean canPlace(int r, int c, int size) {
    // 범위 체크
    if (r + size > 10 || c + size > 10) {
        return false;
    }
    
    // 해당 영역이 모두 1인지 확인
    for (int i = r; i < r + size; i++) {
        for (int j = c; j < c + size; j++) {
            if (board[i][j] != 1) {
                return false;
            }
        }
    }
    return true;
}
```

**3. 종이 놓기**
```java
static void placePaper(int r, int c, int size) {
    for (int i = r; i < r + size; i++) {
        for (int j = c; j < c + size; j++) {
            board[i][j] = 0;  // 덮인 칸은 0으로 변경
        }
    }
}
```

**4. 종이 제거**
```java
static void removePaper(int r, int c, int size) {
    for (int i = r; i < r + size; i++) {
        for (int j = c; j < c + size; j++) {
            board[i][j] = 1;  // 원래대로 복원
        }
    }
}
```

---

## 시간 복잡도

**이론적 최악의 경우:**
- 각 단계에서 5가지 종이 크기 선택
- 각 크기별로 최대 (11-size)² 개의 위치 선택 가능
- 재귀 깊이: 최대 25개 (모든 색종이 사용)
- 이론적 경우의 수: 매우 큼 (지수적)

**실제 시간 복잡도:**
- 가지치기로 인해 실제 탐색은 훨씬 적음
- 첫 번째 1을 찾는 전략으로 탐색 공간 크게 감소
- 큰 종이부터 시도하는 전략으로 빠르게 최적해 도달 가능
- **실제로는 시간 제한 내에 해결 가능**

**근거:**
- 보드 크기가 10×10으로 작음
- 각 색종이 크기별로 최대 5개씩만 사용 가능
- 가지치기 효과가 큼

---

## 공간 복잡도

**전체 공간 복잡도: `O(1)`**

- 보드 저장: O(10×10) = O(100) = O(1)
- 색종이 개수 배열: O(5) = O(1)
- 재귀 호출 스택: O(최대 깊이) = O(25) = O(1)

**BOJ 17136 제약 조건:**
- 보드 크기: 10×10 (고정)
- 색종이 개수: 각 5개씩 (고정)
- 재귀 깊이: 최대 25 (고정)

**결론:**
- 공간 복잡도는 상수 시간으로 충분히 효율적입니다.

---

## 다른 백트래킹 문제와의 차이점

| 특징 | 일반 백트래킹 | 이 문제 (17136) |
|------|-------------|----------------|
| 탐색 대상 | 상태 공간 트리 | 2차원 보드의 1 위치 |
| 선택지 개수 | 가변적 | 고정 (5가지 종이 크기) |
| 탐색 순서 | 모든 선택지 동등 | 큰 종이부터 작은 종이까지 |
| 첫 번째 선택 | 모든 선택지 고려 | 첫 번째 1을 반드시 덮어야 함 |
| 상태 저장 | 선택한 항목들 | 보드 상태 + 색종이 개수 |
| 상태 되돌리기 | 선택적 | 필수 (보드 + 색종이 개수) |
| 가지치기 | 조건 불만족 시 | 현재 개수 >= 최소값 |
| 구현 복잡도 | 중간 | 높음 |

---

## 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적인 탐색**: 첫 번째 1을 찾는 전략으로 탐색 공간 감소
* **가지치기**: 현재 개수가 최소값보다 크면 조기 종료
* **큰 종이 우선**: 빠르게 최적해에 도달 가능

### 추가 최적화 가능성

* **더 강력한 가지치기**: 남은 1의 개수와 사용 가능한 종이로 덮을 수 있는지 확인
  * 하지만 구현이 복잡하고, 보드 크기가 작아 큰 효과가 없을 수 있음
* **메모이제이션**: 하지만 상태 공간이 크고 패턴이 다양하여 효과가 제한적일 수 있음
