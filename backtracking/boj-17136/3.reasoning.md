# 알고리즘 선택 및 코드 설계 근거

이 문서는 **BOJ 17136 색종이 붙이기 문제**에 대한 알고리즘 선택과 코드 설계의 근거를 설명합니다.

---

## 1️⃣ 알고리즘 선택 근거: 백트래킹

### 🔑 문제 해석: 제한된 자원으로 최소 개수 찾기

**핵심 사고 과정:**

1. **목표: 모든 1을 덮는데 필요한 색종이의 최소 개수**
   - 문제: "10×10 보드에서 1이 적힌 모든 칸을 색종이로 덮기"
   - 각 색종이 크기별로 최대 5개씩만 사용 가능
   - 최소 개수를 찾아야 함

2. **전략: 모든 가능한 경우를 탐색**
   - 어떤 색종이를 어디에 놓을지 결정하는 문제
   - 각 단계에서 여러 선택지가 있음
   - 모든 가능한 조합을 탐색하여 최적해를 찾아야 함

3. **왜 백트래킹인가?**
   - 그리디 알고리즘으로는 해결할 수 없음 (큰 종이를 먼저 사용하는 것이 항상 최적이 아님)
   - 완전 탐색이 필요하지만, 가지치기를 통해 효율적으로 탐색 가능
   - 상태를 되돌려서 다른 경우를 탐색해야 함

**구체적인 예시:**

```
보드 상태:
0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
```

**그리디 접근 (큰 종이 우선):**
- (1,1) 위치에 2×2 종이를 놓으면 → (1,1)~(2,2) 덮음
- 하지만 (2,2)의 1은 이미 덮였으므로, (3,4)~(4,5) 영역을 덮기 위해 추가 종이 필요
- 결과: 2×2 종이 2개 + 1×1 종이 1개 = 3개

**최적 해 (다른 조합):**
- (1,1) 위치에 1×1 종이를 놓으면 → (1,1)만 덮음
- (1,2) 위치에 1×1 종이를 놓으면 → (1,2)만 덮음
- (2,2) 위치에 1×1 종이를 놓으면 → (2,2)만 덮음
- (3,4)~(4,5) 영역에 2×2 종이를 놓으면 → 해당 영역 덮음
- 결과: 1×1 종이 3개 + 2×2 종이 1개 = 4개

**하지만 실제로는:**
- 다른 조합이 더 최적일 수 있음
- 모든 가능한 조합을 탐색해야 최적해를 찾을 수 있음

➡️ **백트래킹이 필요합니다.**

---

## 2️⃣ 다른 접근 방식과의 비교

### 대안 1: 그리디 알고리즘 ❌

**접근:**
- 큰 종이부터 작은 종이까지 순서대로 사용
- 각 단계에서 가장 큰 종이를 가능한 위치에 놓기

**장점:**
- 구현이 간단
- 빠른 실행 시간

**단점:**
- ❌ **문제: 항상 최적해를 보장하지 않음**
- 큰 종이를 먼저 사용하는 것이 항상 최적이 아님
- 예: 큰 종이를 사용하면 나머지 영역을 덮기 어려워질 수 있음

**예시:**
```
보드 상태:
1 1 1 1 1 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
```

**그리디 접근:**
- (0,0) 위치에 5×5 종이를 놓으면 → 왼쪽 상단 덮음
- (5,5) 위치에 5×5 종이를 놓으면 → 오른쪽 하단 덮음
- 결과: 5×5 종이 2개 = 2개 ✅ (이 경우는 최적)

**하지만 다른 경우:**
```
보드 상태:
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```

**그리디 접근:**
- 5×5 종이 4개 사용 → 총 4개 ✅ (이 경우도 최적)

**하지만 복잡한 패턴에서는:**
- 그리디가 실패할 수 있음
- 모든 가능한 조합을 탐색해야 최적해를 찾을 수 있음

**결론: ❌ 그리디 알고리즘은 사용할 수 없음**

---

### 대안 2: 동적 계획법 (DP) ❌

**접근:**
- `dp[i][j] = (i, j) 위치까지의 최소 색종이 개수`
- 또는 `dp[mask] = mask 상태에서의 최소 색종이 개수`

**장점:**
- 중복 계산을 피할 수 있음
- 메모이제이션으로 효율적일 수 있음

**단점:**
- ❌ **문제: 상태 공간이 너무 큼**
- 보드 상태를 표현하려면 2^100 개의 상태가 필요 (각 칸마다 덮였는지 여부)
- 색종이 개수 정보도 포함해야 하므로 상태 공간이 더 커짐
- 메모이제이션 테이블이 너무 커서 비효율적

**예시:**
```
상태 정의: dp[mask][papers]
- mask: 보드 상태 (100비트)
- papers: 각 색종이 크기별 개수 (5×5 = 25비트)

상태 개수: 2^100 × 6^5 ≈ 매우 큼
```

**결론: ❌ 동적 계획법은 사용할 수 없음**

---

### 대안 3: 백트래킹 (현재 방식) ✅

**접근:**
- 모든 가능한 경우를 탐색
- 가지치기를 통해 불필요한 탐색 제거
- 상태를 되돌려서 다른 경우 탐색

**장점:**
- ✅ **모든 가능한 경우를 탐색하여 최적해 보장**
- ✅ **가지치기로 인해 효율적으로 탐색 가능**
- ✅ **상태 공간이 작아서 (보드 10×10, 색종이 각 5개) 충분히 처리 가능**
- ✅ **구현이 상대적으로 간단**

**단점:**
- 최악의 경우 시간이 오래 걸릴 수 있음
- 하지만 가지치기로 인해 실제로는 충분히 빠름

**핵심 구현:**
```java
static void backtrack(int count) {
    // 가지치기
    if (count >= minCount) return;
    
    // 첫 번째 1 찾기
    int[] pos = findFirstOne();
    if (pos == null) {
        minCount = Math.min(minCount, count);
        return;
    }
    
    // 큰 종이부터 작은 종이까지 시도
    for (int size = 5; size >= 1; size--) {
        if (canPlace(pos[0], pos[1], size)) {
            placePaper(pos[0], pos[1], size);
            papers[size]--;
            backtrack(count + 1);
            removePaper(pos[0], pos[1], size);
            papers[size]++;
        }
    }
}
```

**결론: ✅ 백트래킹이 가장 적합함**

---

## 3️⃣ 핵심 설계 결정 사항

### 결정 1: 왼쪽 위부터 첫 번째 1 찾기 ✅

**이유:**
- 첫 번째 1은 반드시 덮어야 함 (덮지 않으면 불가능)
- 모든 위치를 순회할 필요 없이, 첫 번째 1만 찾으면 됨
- 탐색 공간을 크게 줄일 수 있음

**다른 방법과의 비교:**

| 방법 | 탐색 공간 | 효율성 |
|------|----------|--------|
| 모든 위치 순회 | 매우 큼 | ❌ 비효율적 |
| 첫 번째 1 찾기 | 작음 | ✅ 효율적 |

**결론: ✅ 첫 번째 1을 찾는 전략이 더 효율적**

---

### 결정 2: 큰 종이부터 작은 종이까지 시도 ✅

**이유:**
- 큰 종이를 먼저 사용하면 전체적으로 종이 개수를 줄일 가능성이 높음
- 가지치기 효과: 큰 종이를 먼저 시도하면 더 빨리 최적해에 도달 가능
- 하지만 이것이 항상 최적은 아니므로, 백트래킹으로 모든 경우를 탐색해야 함

**다른 방법과의 비교:**

| 방법 | 가지치기 효과 | 최적해 도달 속도 |
|------|-------------|----------------|
| 작은 종이부터 | 낮음 | 느림 |
| 큰 종이부터 | 높음 | 빠름 ✅ |
| 랜덤 순서 | 중간 | 중간 |

**결론: ✅ 큰 종이부터 시도하는 전략이 더 효율적**

---

### 결정 3: 가지치기 조건 ✅

**조건 1: 현재 개수 >= 최소값**
```java
if (count >= minCount) {
    return;
}
```

**이유:**
- 현재 사용한 종이 개수가 이미 찾은 최소값보다 크면 더 이상 탐색할 필요 없음
- 이 조건으로 많은 불필요한 탐색을 제거할 수 있음

**조건 2: 더 이상 덮을 수 없는 경우**
- 첫 번째 1을 찾았지만, 사용 가능한 색종이로 덮을 수 없는 경우
- 이 경우는 불가능한 경우이므로 조기 종료

**결론: ✅ 가지치기로 탐색 효율성 크게 향상**

---

## 4️⃣ 시간 복잡도 분석

### 이론적 최악의 경우

**상태 공간 크기:**
- 각 단계에서 5가지 종이 크기 선택
- 각 크기별로 최대 (11-size)² 개의 위치 선택 가능
  - 5×5: (11-5)² = 36개
  - 4×4: (11-4)² = 49개
  - 3×3: (11-3)² = 64개
  - 2×2: (11-2)² = 81개
  - 1×1: (11-1)² = 100개
- 재귀 깊이: 최대 25개 (모든 색종이 사용)

**이론적 경우의 수:**
- 매우 큼 (지수적)
- 하지만 실제로는 가지치기로 인해 훨씬 적음

### 실제 시간 복잡도

**가지치기 효과:**
- 첫 번째 1을 찾는 전략으로 탐색 공간 크게 감소
- 현재 개수 >= 최소값 조건으로 많은 경로 조기 종료
- 큰 종이부터 시도하는 전략으로 빠르게 최적해 도달 가능

**실제 실행 시간:**
- 보드 크기가 10×10으로 작음
- 각 색종이 크기별로 최대 5개씩만 사용 가능
- 가지치기 효과가 큼
- **시간 제한 내에 해결 가능** ✅

**근거:**
- BOJ 17136 시간 제한: 1초
- 실제 테스트에서 시간 제한 내에 해결 가능
- 가지치기로 인해 실제 탐색 노드 수는 이론적 최악보다 훨씬 적음

---

## 5️⃣ 공간 복잡도 분석

**전체 공간 복잡도: `O(1)`**

**구성 요소:**
- 보드 저장: O(10×10) = O(100) = O(1)
- 색종이 개수 배열: O(5) = O(1)
- 재귀 호출 스택: O(최대 깊이) = O(25) = O(1)

**BOJ 17136 제약 조건:**
- 보드 크기: 10×10 (고정)
- 색종이 개수: 각 5개씩 (고정)
- 재귀 깊이: 최대 25 (고정)

**결론:**
- 공간 복잡도는 상수 시간으로 충분히 효율적입니다. ✅

---

## 6️⃣ 종합 비교

| 방식 | 시간 복잡도 | 공간 복잡도 | 최적해 보장 | 구현 난이도 | 평가 |
|------|------------|------------|-----------|------------|------|
| 그리디 | O(N²) | O(1) | ❌ | 쉬움 | ❌ |
| 동적 계획법 | O(상태 공간) | O(상태 공간) | ✅ | 어려움 | ❌ |
| 백트래킹 | O(상태 공간) | O(1) | ✅ | 보통 | ✅ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **백트래킹이 가장 적합함**
- 시간 복잡도는 이론적으로 크지만, 가지치기로 인해 실제로는 충분히 빠름
- 공간 복잡도는 상수 시간으로 효율적
- 최적해를 보장하면서도 구현이 상대적으로 간단

---

## 7️⃣ 코드 설계 원칙

### 원칙 1: 간단하고 명확한 구조

- 알고리즘의 의도가 코드에 잘 드러남
- 각 함수의 역할이 명확함
- 주석으로 설명 보완

### 원칙 2: 효율적인 탐색

- 첫 번째 1을 찾는 전략으로 탐색 공간 감소
- 큰 종이부터 시도하는 전략으로 빠르게 최적해 도달
- 가지치기로 불필요한 탐색 제거

### 원칙 3: 상태 관리

- 보드 상태와 색종이 개수를 명확히 관리
- 상태 되돌리기를 정확히 구현
- 재귀 호출 후 반드시 상태 복원

---

## 8️⃣ 최종 정리

이 문제는 **제한된 자원으로 최소 개수를 찾는 문제**로, 다음과 같은 이유로 백트래킹이 가장 적합합니다:

1. **그리디 알고리즘으로는 해결할 수 없음**
   - 큰 종이를 먼저 사용하는 것이 항상 최적이 아님
   - 모든 가능한 조합을 탐색해야 최적해를 찾을 수 있음

2. **동적 계획법으로는 해결할 수 없음**
   - 상태 공간이 너무 커서 메모이제이션 테이블이 비효율적

3. **백트래킹이 가장 적합함**
   - 모든 가능한 경우를 탐색하여 최적해 보장
   - 가지치기로 인해 효율적으로 탐색 가능
   - 보드 크기가 작아서 충분히 처리 가능

**핵심 설계 결정:**
- 왼쪽 위부터 첫 번째 1 찾기
- 큰 종이부터 작은 종이까지 시도
- 가지치기로 탐색 효율성 향상

**결과:**
- 시간 제한 내에 해결 가능
- 공간 복잡도는 상수 시간으로 효율적
- 최적해를 보장하면서도 구현이 상대적으로 간단

