# 같은 나머지 (BOJ 1684) 알고리즘

## 1) 문제 변형 과정
처음 식:

- `N_1 = D*Q_1 + R`
- `N_2 = D*Q_2 + R`
- `N_3 = D*Q_3 + R`

여기서 `R`을 모르면 직접 접근이 어렵습니다.
그래서 식끼리 빼서 `R`을 제거합니다.

- `A_1 = N_2 - N_1 = D*(Q_2 - Q_1)`
- `A_2 = N_3 - N_2 = D*(Q_3 - Q_2)`

즉, 차분 `A_i`들은 모두 `D`의 배수입니다.
그러면 `D`는 차분들의 공약수이고, 가장 큰 `D`는 차분들의 최대공약수입니다.

## 2) 구현 포인트
차분들을 한 번에 모을 필요 없이, 입력을 읽으면서 바로 `gcd`를 누적합니다.

1. 첫 수를 `prev`로 저장
2. 다음 수 `cur`를 읽음
3. `diff = |cur - prev|` 계산
4. `g = gcd(g, diff)` 갱신
5. `prev = cur`로 이동

초기값 `g = 0`을 사용한 이유:
- `gcd(0, x) = x` 이므로 첫 차분을 자연스럽게 시작값으로 잡을 수 있음

음수 입력 처리:
- 예제처럼 음수가 있으므로 차분은 반드시 `Math.abs(cur - prev)` 사용

## 3) gcd 함수
유클리드 호제법:

```java
static int gcd(int a, int b) {
    while (b != 0) {
        int t = a % b;
        a = b;
        b = t;
    }
    return Math.abs(a);
}
```

## 4) 복잡도
- 시간: `O(n * logV)`
- 공간: `O(1)`
