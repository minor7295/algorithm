# 알고리즘 선택 및 코드 설계 근거

이 문서는 **BOJ 11689 GCD(n, k) = 1 문제**에서 왜 이 알고리즘을 선택했는지, 그리고 코드가 어떻게 설계되었는지를 설명합니다.

---

## 1️⃣ 알고리즘 선택 근거: 왜 "오일러 파이 함수 공식"인가?

### 🔑 핵심 사고 과정

**문제 분석:**
- "GCD(n, k) = 1을 만족하는 k의 개수" = 오일러 파이 함수 φ(n)의 정의

**직접 계산의 한계:**
- O(n × log n) 시간 → n = 10¹²일 때 시간 초과

**해결책:**
- 오일러 파이 함수 공식 활용 → O(√n) 시간

---

### 🔍 다른 접근 방식과의 비교

**알고리즘을 결정할 때, 여러 방식 중에서 왜 "오일러 파이 함수 공식"을 선택했을까?**

#### 방식 1: 직접 계산 (브루트 포스)

**접근:**
```java
int count = 0;
for (long k = 1; k <= n; k++) {
    if (gcd(n, k) == 1) {
        count++;
    }
}
```

**장점:**
- 구현이 간단하고 직관적
- 모든 경우를 확인하므로 정확함

**단점:**
- ❌ **시간 복잡도 O(n × log n)**: n=10¹²일 때 4×10¹³ 연산
- 시간 초과 확실

---

#### 방식 2: 에라토스테네스의 체 변형

**접근:**
```java
boolean[] isCoprime = new boolean[n + 1];
Arrays.fill(isCoprime, true);

// n의 소인수들을 찾아서 그 배수들을 제거
for (long p : primeFactors) {
    for (long i = p; i <= n; i += p) {
        isCoprime[i] = false;
    }
}

int count = 0;
for (int i = 1; i <= n; i++) {
    if (isCoprime[i]) count++;
}
```

**장점:**
- 구현이 비교적 간단
- O(n) 시간 (소인수 개수에 비례)

**단점:**
- ❌ **공간 복잡도 O(n)**: n=10¹²일 때 10¹² bytes = 1TB 메모리 필요
- 메모리 초과 확실

---

#### 방식 3: 오일러 파이 함수 공식 (현재 방식) ✅

> 📖 **오일러 파이 함수 계산 알고리즘**: [수론(Number Theory) 정리](../number-theory.md#3-오일러-파이-함수-계산)

**접근:**
- 소인수 분해를 통해 오일러 파이 함수 공식 적용

**장점:**
- ✅ **시간 복잡도 O(√n)**: n=10¹²일 때 10⁶ 연산
- ✅ **공간 복잡도 O(1)**: 상수 공간만 사용
- ✅ **수학적으로 정확하고 효율적**

**단점:**
- 없음 (이 문제에 완벽하게 적합)

---

### 📊 종합 비교

| 방식 | 시간 복잡도 | 공간 복잡도 | 구현 난이도 | 효율성 |
|------|------------|------------|------------|--------|
| 직접 계산 | O(n × log n) | O(1) | 쉬움 | ❌ |
| 에라토스테네스 체 변형 | O(n) | O(n) | 보통 | ❌ |
| 오일러 파이 함수 공식 | O(√n) | O(1) | 보통 | ✅ |

**결론:**
- 각 방식의 장단점을 고려한 결과
- **"오일러 파이 함수 공식"이 가장 적합함**
- 시간 복잡도 O(√n)로 효율적
- 공간 복잡도 O(1)로 메모리 효율적

---

## 2️⃣ 코드 설계 근거: 코드와 알고리즘의 1:1 대응

### ① 소인수 분해

> 📖 **소인수 분해 상세 설명**: [수론(Number Theory) 정리](../number-theory.md#1-소인수-분해)

* **목적**: n의 모든 서로 다른 소인수를 찾기
* **시간**: O(√n)
* **최적화**: i * i <= temp로 √temp까지만 확인

### ② 오일러 파이 함수 계산

**"φ(n) = n × ∏(1 - 1/p)"를 코드로 구현:**

```java
long result = n;
// ...
if (temp % i == 0) {
    result = result / i * (i - 1);
    // result = result × (1 - 1/i) = result × (i-1)/i
}
```

**수학적 변환:**
- φ(n) = n × (1 - 1/p₁) × (1 - 1/p₂) × ... × (1 - 1/pₖ)
- result = result / i * (i - 1) = result × (i - 1) / i
- 이것은 result × (1 - 1/i)와 동일

**왜 이렇게 구현하는가?**

**정수 연산의 정확성:**
- result × (1 - 1/i)는 부동소수점 연산이 필요
- result / i * (i - 1)는 정수 연산으로 정확하게 계산 가능
- 나눗셈이 먼저 일어나므로 오버플로우 위험도 줄임

**예시:**
- result = 45 / 3 * 2 = 30 ✓ (정수 연산)
- result = 45 * (1 - 1/3) = 30.0 ❌ (부동소수점 오차 가능)

### ③ 중복 소인수 제거

```java
while (temp % i == 0) {
    temp /= i;
}
```

**왜 중복 소인수를 제거해야 하는가?**

**핵심 이유: 같은 소인수는 한 번만 처리해야 하기 때문**

**중복 처리 시 문제:**
```
n = 12 = 2² × 3

잘못된 구현 (중복 처리):
- i = 2: result = 12 / 2 * 1 = 6, temp = 6
- i = 2: result = 6 / 2 * 1 = 3, temp = 3 (중복 처리!)
- i = 3: result = 3 / 3 * 2 = 2
- 결과: φ(12) = 2 ❌ (잘못된 답)

올바른 구현 (중복 제거):
- i = 2: result = 12 / 2 * 1 = 6, temp = 3 (모든 2 제거)
- i = 3: result = 6 / 3 * 2 = 4
- 결과: φ(12) = 4 ✓ (올바른 답)
```

**결론:**
- while 루프로 같은 소인수의 모든 인수를 제거
- 각 소인수는 정확히 한 번만 처리됨

### ④ 마지막 소인수 처리

```java
if (temp > 1) {
    result = result / temp * (temp - 1);
}
```

**왜 마지막 소인수를 별도로 처리해야 하는가?**

**핵심 이유: √n보다 큰 소인수는 루프에서 확인되지 않기 때문**

> 📖 **큰 소인수 처리 상세 설명**: [2.algorithm.md](./2.algorithm.md#큰-소인수는-어떻게-처리하나) 참고

**결론:**
- 소인수 분해 후 남은 temp > 1이면 temp 자체가 소수
- 이 경우도 result에 반영해야 함

---

## 4️⃣ 코드 최적화 고려사항

### 현재 구현의 특징

* **간단하고 명확함**: 알고리즘의 의도가 코드에 잘 드러남
* **효율적**: O(√n) 시간 복잡도
* **메모리 효율적**: O(1) 공간 복잡도
* **정수 연산**: 부동소수점 오차 없이 정확하게 계산

### 추가 최적화 가능성

* **소수 판별 최적화**: i가 소수인지 확인하는 과정을 생략 (나누어떨어지면 소인수)
* **입력 최적화**: BufferedReader 사용 (이미 사용 중)
* 현재 구현이 문제 제약 조건 내에서 충분히 효율적

---

## 5️⃣ 정리

이 `Main.java`는 단순히 정답을 출력하는 코드가 아니라,

* 문제의 **"서로소의 개수"를 "오일러 파이 함수"로 해석**하여 수학적 공식을 활용하고
* 알고리즘 문서에서 설명한 **소인수 분해를 통한 효율적 계산**을 그대로 활용하며
* 제약 조건 내에서 효율적으로 동작하는

**설계 의도가 드러나는 해답 코드**이다.

즉, 설명 → 알고리즘 → 코드가
**하나의 사고 흐름으로 완전히 일치**하도록 작성된 최종 결과물이다.

---

## 6️⃣ 핵심 설계 원칙

1. **효율성**: O(√n) 시간 복잡도로 최적화
2. **정확성**: 정수 연산으로 부동소수점 오차 없이 정확하게 계산
3. **명확성**: 코드만 봐도 알고리즘의 동작을 이해할 수 있음
4. **일관성**: 알고리즘 문서의 설명과 코드가 1:1로 대응
5. **간결성**: 불필요한 복잡성 없이 핵심만 구현
