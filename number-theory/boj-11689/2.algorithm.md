# 알고리즘: 오일러 파이 함수 계산

> 📖 **문제 분석**: [1.analysis.md](./1.analysis.md)를 먼저 읽어보세요.  
> 📖 **수론 알고리즘 설명**: [수론(Number Theory) 정리](../number-theory.md)

이 문제는 **오일러 파이 함수 φ(n)**를 계산하는 문제입니다.

**알고리즘 분류**: 수론(Number Theory) - 오일러 파이 함수

---

## 🎯 핵심 아이디어

**문제**: 1부터 n까지의 수 중에서 n과 서로소인 수의 개수 구하기

**접근 방법:**
- 직접 계산: O(n × log n) → 시간 초과 ❌
- 오일러 파이 함수 공식: O(√n) → 충분히 빠름 ✅

### 오일러 파이 함수 공식

> 📖 **공식 상세 설명**: [수론(Number Theory) 정리](../number-theory.md#3-오일러-파이-함수-eulers-totient-function)

**공식:**
- n의 소인수가 p₁, p₂, ..., pₖ라면
- **φ(n) = n × (1 - 1/p₁) × (1 - 1/p₂) × ... × (1 - 1/pₖ)**

#### 직관적 이해: "제외하기"의 관점

이 공식은 **"n 이하의 수 중에서 n의 소인수들의 배수를 제외한 개수"**를 의미합니다.

**핵심 아이디어:**
1. 처음에는 n개의 수가 모두 가능하다고 가정
2. 각 소인수 pᵢ의 배수를 제외
3. (1 - 1/pᵢ)는 "pᵢ의 배수가 아닌 비율"을 의미

**예시로 이해하기: n = 45**

```
45 = 3² × 5
소인수: 3, 5

1단계: 처음에는 45개 모두 가능
  → 45개

2단계: 3의 배수 제외
  → 45개 중 3의 배수는 45/3 = 15개
  → 남은 수: 45 × (1 - 1/3) = 45 × (2/3) = 30개

3단계: 5의 배수 제외
  → 현재 30개 중 5의 배수는 30/5 = 6개
  → 남은 수: 30 × (1 - 1/5) = 30 × (4/5) = 24개

결과: φ(45) = 24
```

**왜 이렇게 계산하는가?**
- 3의 배수와 5의 배수를 모두 제외하면
- 3과 5 둘 다의 배수(15의 배수)는 두 번 제외됨
- 하지만 각 소인수를 독립적으로 처리하면 자동으로 중복이 해결됨

#### 확률적 관점 (더 직관적)

**"1부터 n까지의 수 중에서 n과 서로소일 확률"**로 생각하면:

```
n = 45 = 3² × 5

- 3의 배수가 아닐 확률: (1 - 1/3) = 2/3
- 5의 배수가 아닐 확률: (1 - 1/5) = 4/5
- 둘 다 아닐 확률: (2/3) × (4/5) = 8/15

따라서 서로소인 수의 개수:
  45 × (8/15) = 24개
```

#### 구체적인 계산 과정

**n = 45일 때:**

```
초기: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ..., 45
      총 45개

3의 배수 제외: 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45
              → 15개 제외, 30개 남음

5의 배수 제외: 5, 10, 15, 20, 25, 30, 35, 40, 45
              → 9개 제외 (하지만 15, 30, 45는 이미 제외됨)
              → 실제로는 6개만 추가 제외, 24개 남음

최종: 1, 2, 4, 7, 8, 11, 13, 14, 16, 17, 19, 22, 23, 26, 28, 29, 31, 32, 34, 37, 38, 41, 43, 44
     → 총 24개 ✓
```

**공식으로 계산:**
```
φ(45) = 45 × (1 - 1/3) × (1 - 1/5)
      = 45 × (2/3) × (4/5)
      = 45 × 8/15
      = 24 ✓
```

#### 왜 공식이 맞는가?

**핵심 원리:**
- 각 소인수 pᵢ에 대해, n 이하의 수 중 pᵢ의 배수는 정확히 n/pᵢ개
- pᵢ의 배수가 아닌 수는 n × (1 - 1/pᵢ)개
- 여러 소인수에 대해 독립적으로 적용하면 곱셈으로 계산 가능
- (각 소인수의 배수가 아닐 확률을 곱하는 것과 같음)

**주의:** 이 공식은 소인수의 **거듭제곱**과 무관합니다.
- n = 3² × 5 = 45와 n = 3 × 5 = 15는 같은 소인수(3, 5)를 가지므로
- φ(45) = 45 × (2/3) × (4/5) = 24
- φ(15) = 15 × (2/3) × (4/5) = 8
- 공식에서 중요한 것은 **서로 다른 소인수**입니다!

---

## 💻 구현 코드

> 📖 **오일러 파이 함수 계산 알고리즘**: [수론(Number Theory) 정리](../number-theory.md#3-오일러-파이-함수-계산)

```java
long result = n;
long temp = n;

// 소인수 찾기: 2부터 √temp까지
for (long i = 2; i * i <= temp; i++) {
    if (temp % i == 0) {
        result = result / i * (i - 1);  // 공식 적용
        while (temp % i == 0) temp /= i; // 모든 인수 제거
    }
}

// 남은 큰 소인수 처리
if (temp > 1) {
    result = result / temp * (temp - 1);
}

System.out.println(result);
```

---

## 🔍 동작 예시

**n = 45일 때:**
- 소인수: 3, 5
- i = 3: result = 45 / 3 × 2 = 30, temp = 5
- i = 5: result = 30 / 5 × 4 = 24, temp = 1
- 결과: φ(45) = 24 ✓

---

## ❓ 왜 √n까지만 확인하는가?

> 📖 **소인수 분해 상세 설명**: [수론(Number Theory) 정리](../number-theory.md#1-소인수-분해)

**핵심 원리:**
- n이 합성수라면, 최소한 하나의 소인수는 √n 이하입니다
- n = a × b (a ≤ b)일 때, a ≤ √n

**큰 소인수는 어떻게 처리하나?**

루프는 √n까지만 확인하므로, √n보다 큰 소인수는 루프에서 발견되지 않습니다.

**하지만 걱정할 필요 없습니다!**

**이유:**
- 작은 소인수들을 모두 제거하면, 남은 temp에 큰 소인수가 그대로 남아있습니다
- 예: n = 21 = 3 × 7
  - √21 ≈ 4.58
  - i = 3에서 3을 제거하면 temp = 7
  - i = 4에서 7 % 4 ≠ 0이므로 건너뜀
  - 루프 종료 (i² = 16 > 7)
  - **temp = 7이 남아있음** → 이것이 바로 큰 소인수!

**따라서:**
- 루프 종료 후 temp > 1이면
- temp 자체가 √n보다 큰 소인수 (또는 그 자체가 소수)
- 마지막에 `result = result / temp × (temp-1)`로 처리하면 됨

**구체적 예시 (n = 21):**
- √21 ≈ 4.58
- i = 3: result = 21 / 3 × 2 = 14, temp = 7
- 루프 종료 후 temp = 7 > 1 → 큰 소인수!
- 별도 처리: result = 14 / 7 × 6 = 12
- 결과: φ(21) = 12 ✓

**효율성:**
- √n까지만 확인: O(√n) 시간
- n까지 확인: O(n) 시간
- n = 10¹²일 때: √n = 10⁶ vs n = 10¹² → **100만 배 차이**

---

## ⏱️ 시간/공간 복잡도

**시간 복잡도: `O(√n)`**
- 소인수 분해: 2부터 √n까지 반복
- n = 10¹²일 때 √n = 10⁶ 연산 → 약 0.01초 ✅

**공간 복잡도: `O(1)`**
- 변수: result, temp, i 등 상수 개
- 메모리: 약 24 bytes ✅

---

## 🔑 핵심 포인트

1. **소인수 분해**: 2부터 √n까지만 확인하면 충분
2. **공식 적용**: 각 소인수 p에 대해 result = result / p × (p-1)
3. **중복 제거**: 같은 소인수는 한 번만 처리 (while 루프로 모든 인수 제거)
4. **큰 소인수**: 루프 종료 후 temp > 1이면 별도 처리

---

## 📝 정리

이 문제는 **오일러 파이 함수의 수학적 공식**을 활용하여 효율적으로 해결합니다.

- 직접 계산: O(n × log n) → 시간 초과 ❌
- 공식 활용: O(√n) → 충분히 빠름 ✅

핵심은 **소인수 분해를 통해 공식을 적용**하는 것입니다.
