# 수론 (Number Theory)

수론은 정수의 성질과 관계를 연구하는 수학의 한 분야입니다. 알고리즘 문제 해결에서 수론은 소수, 최대공약수, 최소공배수, 모듈로 연산 등과 관련된 문제를 효율적으로 해결하는 데 사용됩니다.

---

## 📚 주요 개념

### 1. 소수 (Prime Number)

**정의**: 1과 자기 자신으로만 나누어떨어지는 1보다 큰 자연수

**성질:**
- 2는 유일한 짝수 소수
- 소수의 개수는 무한하다
- 합성수 n은 최소한 하나의 소인수를 √n 이하에 가짐

**소수 판별:**
- O(√n) 시간: 2부터 √n까지 나누어떨어지는지 확인

**소인수 분해:**
- O(√n) 시간: 2부터 √n까지 반복하며 소인수 찾기

---

### 2. 최대공약수 (GCD)와 최소공배수 (LCM)

**최대공약수 (GCD):**
- 두 수의 공약수 중 가장 큰 수
- 유클리드 호제법: `gcd(a, b) = gcd(b, a % b)`
- 시간 복잡도: O(log min(a, b))

**최소공배수 (LCM):**
- 두 수의 공배수 중 가장 작은 수
- `lcm(a, b) = a × b / gcd(a, b)`

**서로소 (Coprime):**
- 두 수의 최대공약수가 1인 경우
- GCD(a, b) = 1

---

### 3. 오일러 파이 함수 (Euler's Totient Function)

**정의**: φ(n)은 1부터 n까지의 자연수 중에서 n과 서로소인 수의 개수

**공식:**
- n의 소인수가 p₁, p₂, ..., pₖ라면
- **φ(n) = n × (1 - 1/p₁) × (1 - 1/p₂) × ... × (1 - 1/pₖ)**

**성질:**
- n이 소수 p이면: φ(p) = p - 1
- n이 두 소수 p, q의 곱이면: φ(p × q) = (p - 1) × (q - 1)
- n = pᵏ이면: φ(pᵏ) = pᵏ - pᵏ⁻¹ = pᵏ⁻¹ × (p - 1)

**계산 방법:**
1. n의 소인수 분해: O(√n)
2. 각 소인수 p에 대해 result = result / p × (p - 1) 적용
3. 총 시간 복잡도: O(√n)

**응용:**
- RSA 암호화
- 모듈로 역원 계산
- 서로소인 수의 개수 구하기

---

### 4. 모듈로 연산 (Modular Arithmetic)

**기본 연산:**
- (a + b) mod m = ((a mod m) + (b mod m)) mod m
- (a × b) mod m = ((a mod m) × (b mod m)) mod m
- (a - b) mod m = ((a mod m) - (b mod m) + m) mod m

**거듭제곱:**
- 분할정복을 이용한 거듭제곱: O(log b)
- `a^b mod m`을 효율적으로 계산

**모듈로 역원:**
- 확장 유클리드 호제법으로 계산
- 페르마의 소정리 활용 (m이 소수일 때)

---

## 🔧 주요 알고리즘

### 1. 소인수 분해

**목적**: 주어진 수를 소인수들의 곱으로 표현

**알고리즘:**
```java
List<Long> factors = new ArrayList<>();
long temp = n;

for (long i = 2; i * i <= temp; i++) {
    while (temp % i == 0) {
        factors.add(i);
        temp /= i;
    }
}

if (temp > 1) {
    factors.add(temp);
}
```

**시간 복잡도:** O(√n)

**핵심:**
- 2부터 √n까지만 확인하면 충분
- 큰 소인수는 루프 종료 후 temp에 남아있음

---

### 2. 유클리드 호제법 (GCD 계산)

**알고리즘:**
```java
long gcd(long a, long b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
```

**시간 복잡도:** O(log min(a, b))

**확장 유클리드 호제법:**
- ax + by = gcd(a, b)를 만족하는 x, y를 찾음
- 모듈로 역원 계산에 사용

---

### 3. 오일러 파이 함수 계산

**알고리즘:**
```java
long eulerPhi(long n) {
    long result = n;
    long temp = n;
    
    for (long i = 2; i * i <= temp; i++) {
        if (temp % i == 0) {
            result = result / i * (i - 1);
            while (temp % i == 0) {
                temp /= i;
            }
        }
    }
    
    if (temp > 1) {
        result = result / temp * (temp - 1);
    }
    
    return result;
}
```

**시간 복잡도:** O(√n)

**핵심:**
- 소인수 분해와 동시에 φ(n) 계산
- 각 소인수는 한 번만 처리 (중복 제거)

---

## 📊 시간 복잡도 요약

| 알고리즘 | 시간 복잡도 | 설명 |
|---------|-----------|------|
| 소수 판별 | O(√n) | 2부터 √n까지 확인 |
| 소인수 분해 | O(√n) | 2부터 √n까지 반복 |
| GCD (유클리드) | O(log min(a, b)) | 재귀 호출 |
| 오일러 파이 함수 | O(√n) | 소인수 분해 기반 |
| 거듭제곱 (분할정복) | O(log b) | 지수를 절반으로 분할 |

---

## 💡 문제 해결 전략

### 1. 소인수 분해 활용

**언제 사용:**
- 약수의 개수 구하기
- 최대공약수/최소공배수 구하기
- 오일러 파이 함수 계산

**핵심:**
- √n까지만 확인하면 충분
- 큰 소인수는 별도 처리

### 2. 모듈로 연산 활용

**언제 사용:**
- 큰 수의 연산 결과를 특정 수로 나눈 나머지 구하기
- 오버플로우 방지

**주의사항:**
- 나눗셈은 모듈로 역원 필요
- 음수 처리: (a - b) mod m = ((a mod m) - (b mod m) + m) mod m

### 3. 수학적 공식 활용

**오일러 파이 함수:**
- 서로소인 수의 개수를 직접 계산하는 대신 공식 활용
- O(n) → O(√n) 시간 복잡도 개선

---

## 🔗 관련 문제

- **BOJ 11689**: GCD(n, k) = 1 (오일러 파이 함수)
- **BOJ 1629**: 곱셈 (분할정복 거듭제곱)
- 소인수 분해 관련 문제들
